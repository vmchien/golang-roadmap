
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Roadmap Golang</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <nav>
    
<h2>ğŸ§­ Má»¥c lá»¥c</h2>
<ul>
  <li><strong>Pháº§n I â€“ Ná»n táº£ng cÆ¡ báº£n (Beginner)</strong>
    <ul>
      <li><a href="#1-kiá»ƒu-dá»¯-liá»‡u-cÆ¡-báº£n-vÃ -khai-bÃ¡o-biáº¿n">1. Kiá»ƒu dá»¯ liá»‡u cÆ¡ báº£n vÃ  khai bÃ¡o biáº¿n</a></li>
      <li><a href="#2-cáº¥u-trÃºc-Ä‘iá»u-kiá»‡n-vÃ -vÃ²ng-láº·p">2. Cáº¥u trÃºc Ä‘iá»u kiá»‡n vÃ  vÃ²ng láº·p</a></li>
      <li><a href="#3-hÃ m-closure-vÃ -hÃ m-variadic">3. HÃ m, Closure, vÃ  HÃ m Variadic</a></li>
      <li><a href="#4-slice-map-array-vÃ -type-casting">4. Slice, Map, Array vÃ  Type Casting</a></li>
      <li><a href="#5-struct-method-vÃ -embedded-struct">5. Struct, Method, vÃ  Embedded Struct</a></li>
      <li><a href="#6-interface-vÃ -type-assertion">6. Interface vÃ  Type Assertion</a></li>
      <li><a href="#7-module-package-vÃ -go-mod">7. Module, Package vÃ  go mod</a></li>
    </ul>
  </li>
  <li><strong>Pháº§n II â€“ TÆ° duy láº­p trÃ¬nh trung cáº¥p (Intermediate)</strong>
    <ul>
      <li><a href="#8-goroutine-vÃ -channel">8. Goroutine vÃ  Channel</a></li>
      <li><a href="#9-Ä‘á»“ng-bá»™-hoÃ¡-vá»›i-mutex-rwmutex-waitgroup">9. Äá»“ng bá»™ hoÃ¡ vá»›i Mutex, RWMutex, WaitGroup</a></li>
      <li><a href="#10-context-vÃ -lifecycle-control">10. Context vÃ  Lifecycle Control</a></li>
      <li><a href="#11-error-handling-vÃ -panicrecover">11. Error Handling vÃ  Panic/Recover</a></li>
      <li><a href="#12-logging-nÃ¢ng-cao-vá»›i-logrus-zap-zerolog">12. Logging nÃ¢ng cao vá»›i logrus, zap, zerolog</a></li>
      <li><a href="#13-testing-benchmark-table-driven-test">13. Testing, Benchmark, Table-Driven Test</a></li>
      <li><a href="#14-debugging-race-condition-deadlock">14. Debugging, Race Condition, Deadlock</a></li>
    </ul>
  </li>
  <li><strong>Pháº§n III â€“ Kiáº¿n thá»©c chuyÃªn sÃ¢u vÃ  phá»ng váº¥n Senior</strong>
    <ul>
      <li><a href="#15-memory-management--escape-analysis">15. Memory Management & Escape Analysis</a></li>
      <li><a href="#16-garbage-collection-vÃ -runtime-scheduler">16. Garbage Collection vÃ  Runtime Scheduler</a></li>
      <li><a href="#17-build-system-vÃ -cross-compilation">17. Build System vÃ  Cross Compilation</a></li>
      <li><a href="#18-generics-type-parameter-vÃ -constraint">18. Generics: Type Parameter vÃ  Constraint</a></li>
      <li><a href="#19-api--middleware-rest-grpc-interceptor">19. API & Middleware: REST, gRPC, Interceptor</a></li>
      <li><a href="#20-error-wrapping-stacktrace-vÃ -structured-logging">20. Error Wrapping, Stacktrace, vÃ  Structured Logging</a></li>
      <li><a href="#21-staticcheck-golangci-lint-go-vet-go-fmt">21. Staticcheck, GolangCI-Lint, go vet, go fmt</a></li>
      <li><a href="#22-design-patterns-trong-go">22. Design Patterns trong Go</a></li>
      <li><a href="#23-system-design-worker-pool-fan-inout-pipeline">23. System Design: Worker Pool, Fan-in/out, Pipeline</a></li>
      <li><a href="#24-secure-coding-vÃ -cicd-workflow">24. Secure Coding vÃ  CI/CD Workflow</a></li>
      <li><a href="#25-distributed-systems-redis-kafka-envoyproxy">25. Distributed Systems: Redis, Kafka, EnvoyProxy</a></li>
    </ul>
  </li>
</ul>

  </nav>
  <main>
    <h1 id="1-kiá»ƒu-dá»¯-liá»‡u-cÆ¡-báº£n-vÃ -khai-bÃ¡o-biáº¿n">âœ… 1. Kiá»ƒu dá»¯ liá»‡u cÆ¡ báº£n vÃ  khai bÃ¡o biáº¿n</h1>

<hr />



<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>

<p>Trong Golang, viá»‡c hiá»ƒu rÃµ <strong>kiá»ƒu dá»¯ liá»‡u</strong> vÃ  <strong>cÃ¡ch khai bÃ¡o biáº¿n</strong> lÃ  bÆ°á»›c ná»n táº£ng khÃ´ng thá»ƒ thiáº¿u. Tá»« viá»‡c xÃ¡c Ä‘á»‹nh giÃ¡ trá»‹ cá»¥ thá»ƒ Ä‘Æ°á»£c lÆ°u trá»¯ á»Ÿ Ä‘Ã¢u trong bá»™ nhá»› (stack vs heap), Ä‘áº¿n cÃ¡ch Go runtime tá»‘i Æ°u hÃ³a truy cáº­p, má»i thá»© Ä‘á»u báº¯t Ä‘áº§u tá»« Ä‘Ã¢y.</p>

<p>NgÃ´n ngá»¯ Go cÃ³ cÃ¡c nhÃ³m dá»¯ liá»‡u chÃ­nh:</p>

<ul>
<li><p><strong>Sá»‘ nguyÃªn (Integer)</strong>:<br />
<code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> vÃ  cÃ¡c biáº¿n thá»ƒ khÃ´ng dáº¥u nhÆ° <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></p></li>
<li><p><strong>Sá»‘ thá»±c (Floating Point)</strong>:<br />
<code>float32</code>, <code>float64</code></p></li>
<li><p><strong>Boolean</strong>:<br />
<code>true</code>, <code>false</code></p></li>
<li><p><strong>Chuá»—i (String)</strong>:<br />
Kiá»ƒu dá»¯ liá»‡u UTF-8 báº¥t biáº¿n</p></li>
<li><p><strong>KÃ½ tá»± Ä‘áº·c biá»‡t</strong>:<br />
<code>byte</code> (alias cá»§a <code>uint8</code>), <code>rune</code> (alias cá»§a <code>int32</code>, Ä‘áº¡i diá»‡n cho Unicode code point)</p></li>
<li><p><strong>Cáº¥u trÃºc dá»¯ liá»‡u tÄ©nh/Ä‘á»™ng</strong>:<br />
<code>array</code>, <code>slice</code></p></li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>

<ul>
<li><code>int</code> lÃ  kiá»ƒu phá»¥ thuá»™c kiáº¿n trÃºc mÃ¡y (32-bit hoáº·c 64-bit). DÃ¹ng máº·c Ä‘á»‹nh nhÆ°ng <strong>nÃªn rÃµ rÃ ng khi cáº§n tÃ­nh toÃ¡n chÃ­nh xÃ¡c kÃ­ch thÆ°á»›c bá»™ nhá»›</strong>.</li>
<li><code>string</code> trong Go lÃ  immutable â€” má»i thao tÃ¡c nhÆ° cáº¯t, ná»‘i chuá»—i Ä‘á»u táº¡o báº£n sao má»›i.</li>
<li><code>rune</code> Ä‘áº¡i diá»‡n 1 kÃ½ tá»± Unicode, dÃ¹ng Ä‘á»ƒ xá»­ lÃ½ kÃ½ tá»± Ä‘a byte nhÆ° tiáº¿ng Viá»‡t, emoji.</li>
<li><code>slice</code> khÃ´ng pháº£i lÃ  máº£ng. NÃ³ lÃ  má»™t â€œviewâ€ gá»“m: pointer tá»›i underlying array, Ä‘á»™ dÃ i vÃ  capacity. Ráº¥t nháº¹, dá»… truyá»n qua hÃ m mÃ  khÃ´ng copy dá»¯ liá»‡u.</li>
<li><code>const</code> Ä‘Æ°á»£c xá»­ lÃ½ á»Ÿ thá»i Ä‘iá»ƒm compile. GiÃ¡ trá»‹ <code>const</code> khÃ´ng chiáº¿m vÃ¹ng nhá»› runtime.</li>
</ul>

<hr />

<h2>ğŸ’¡ VÃ­ dá»¥: CÃ¡c kiá»ƒu dá»¯ liá»‡u</h2>

<div class="codehilite">
<pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">age</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">30</span><span class="w">              </span><span class="c1">// biáº¿n kiá»ƒu sá»‘ nguyÃªn, 32 hoáº·c 64-bit tÃ¹y OS</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">Pi</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">3.1415</span><span class="w">     </span><span class="c1">// háº±ng sá»‘ kiá»ƒu sá»‘ thá»±c (float64)</span>
<span class="w">    </span><span class="nx">isAdmin</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">true</span><span class="w">               </span><span class="c1">// boolean vá»›i short declaration :=</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">letter</span><span class="w"> </span><span class="kt">rune</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sc">&#39;ğ”Š&#39;</span><span class="w">         </span><span class="c1">// kÃ½ tá»± Unicode (rune = int32)</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="kt">byte</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="w">           </span><span class="c1">// byte lÃ  alias cá»§a uint8</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Gopher&quot;</span><span class="w">    </span><span class="c1">// chuá»—i UTF-8, immutable</span>

<span class="w">    </span><span class="nx">nums</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">        </span><span class="c1">// slice Ä‘á»™ng chá»©a int</span>
<span class="w">    </span><span class="nx">arr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">        </span><span class="c1">// array tÄ©nh vá»›i Ä‘á»™ dÃ i cá»‘ Ä‘á»‹nh</span>

<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Age:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Pi:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">Pi</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Admin:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isAdmin</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Letter:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">letter</span><span class="p">))</span><span class="w"> </span><span class="c1">// chuyá»ƒn rune thÃ nh chuá»—i</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Byte:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Name:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Slice:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">nums</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Array:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<hr />


<h2>ğŸ“Š Báº£ng giÃ¡ trá»‹ (Range) cÃ¡c kiá»ƒu dá»¯ liá»‡u phá»• biáº¿n</h2>

<table>
<thead>
<tr>
  <th>Kiá»ƒu dá»¯ liá»‡u</th>
  <th>Bit</th>
  <th>Min GiÃ¡ trá»‹</th>
  <th>Max GiÃ¡ trá»‹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>int8</td>
  <td>8</td>
  <td>-128</td>
  <td>127</td>
</tr>
<tr>
  <td>uint8 (byte)</td>
  <td>8</td>
  <td>0</td>
  <td>255</td>
</tr>
<tr>
  <td>int16</td>
  <td>16</td>
  <td>-32,768</td>
  <td>32,767</td>
</tr>
<tr>
  <td>uint16</td>
  <td>16</td>
  <td>0</td>
  <td>65,535</td>
</tr>
<tr>
  <td>int32 (rune)</td>
  <td>32</td>
  <td>-2,147,483,648</td>
  <td>2,147,483,647</td>
</tr>
<tr>
  <td>uint32</td>
  <td>32</td>
  <td>0</td>
  <td>4,294,967,295</td>
</tr>
<tr>
  <td>int64</td>
  <td>64</td>
  <td>-9,223,372,036,854,775,808</td>
  <td>9,223,372,036,854,775,807</td>
</tr>
<tr>
  <td>uint64</td>
  <td>64</td>
  <td>0</td>
  <td>18,446,744,073,709,551,615</td>
</tr>
<tr>
  <td>float32</td>
  <td>32</td>
  <td>â‰ˆ -3.4e38</td>
  <td>â‰ˆ +3.4e38</td>
</tr>
<tr>
  <td>float64</td>
  <td>64</td>
  <td>â‰ˆ -1.8e308</td>
  <td>â‰ˆ +1.8e308</td>
</tr>
<tr>
  <td>bool</td>
  <td>1</td>
  <td>false</td>
  <td>true</td>
</tr>
</tbody>
</table>


<h2>ğŸ“Œ Ã nghÄ©a há»‡ thá»‘ng</h2>

<p>Viá»‡c náº¯m rÃµ cÃ¡c kiá»ƒu dá»¯ liá»‡u khÃ´ng chá»‰ giÃºp báº¡n trÃ¡nh lá»—i type mismatch, mÃ  cÃ²n:
- Tá»‘i Æ°u hiá»‡u suáº¥t xá»­ lÃ½ vÃ  quáº£n lÃ½ bá»™ nhá»›
- TrÃ¡nh bug liÃªn quan Ä‘áº¿n Unicode/string slicing
- Viáº¿t API rÃµ rÃ ng, khÃ´ng ambiguous vá»›i kiá»ƒu dá»¯ liá»‡u cá»¥ thá»ƒ (<code>[]byte</code>, <code>string</code>, <code>rune</code>)
- PhÃ¢n biá»‡t khi truyá»n dá»¯ liá»‡u qua hÃ m: array (copy toÃ n bá»™) vs slice (chia sáº» vÃ¹ng nhá»›)</p>


  
<hr />
<h1 id="2-cáº¥u-trÃºc-Ä‘iá»u-kiá»‡n-vÃ -vÃ²ng-láº·p">2. Cáº¥u trÃºc Ä‘iá»u kiá»‡n vÃ  vÃ²ng láº·p</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<p>Golang cung cáº¥p ba cáº¥u trÃºc Ä‘iá»u khiá»ƒn cÆ¡ báº£n:</p>
<ul>
  <li><strong>if / else if / else</strong>: kiá»ƒm tra Ä‘iá»u kiá»‡n logic</li>
  <li><strong>switch</strong>: thay tháº¿ cho nhiá»u if lá»“ng nhau, há»— trá»£ fallthrough</li>
  <li><strong>for</strong>: vÃ²ng láº·p duy nháº¥t trong Go, dÃ¹ng Ä‘Æ°á»£c cho loop, while, foreach</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li><code>if</code> trong Go khÃ´ng cáº§n dáº¥u ngoáº·c trÃ²n quanh Ä‘iá»u kiá»‡n (nhÆ° trong C).</li>
  <li><code>switch</code> trong Go khÃ´ng cáº§n <code>break</code>; nÃ³ tá»± Ä‘á»™ng khÃ´ng fallthrough, trá»« khi Ä‘Æ°á»£c khai bÃ¡o rÃµ rÃ ng.</li>
  <li><code>for</code> cÃ³ thá»ƒ hoáº¡t Ä‘á»™ng nhÆ°:
    <ul>
      <li>vÃ²ng láº·p chuáº©n: <code>for i := 0; i &lt; n; i++</code></li>
      <li>vÃ²ng láº·p while: <code>for cond</code></li>
      <li>vÃ²ng láº·p vÃ´ háº¡n: <code>for &#123;&#125;</code></li>
      <li>range loop: <code>for i, v := range collection</code></li>
    </ul>
  </li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ code: if, switch, for</h2>

<pre><code class="go">// Cáº¥u trÃºc Ä‘iá»u kiá»‡n vá»›i if/else
x := 5
if x > 10 {
    fmt.Println("Lá»›n hÆ¡n 10")
} else if x == 5 {
    fmt.Println("Báº±ng 5")
} else {
    fmt.Println("KhÃ¡c")
}

// switch cÆ¡ báº£n khÃ´ng cáº§n break
switch x {
case 1:
    fmt.Println("One")
case 5:
    fmt.Println("Five") // Ä‘Ãºng
default:
    fmt.Println("Other")
}

// for chuáº©n
for i := 0; i < 3; i++ {
    fmt.Println(i)
}

// for nhÆ° while
i := 0
for i < 3 {
    fmt.Println(i)
    i++
}

// for vÃ´ háº¡n
// for {
//     fmt.Println("Cháº¡y mÃ£i mÃ£i")
// }

// range trÃªn slice
nums := []int{1, 2, 3}
for idx, val := range nums {
    fmt.Println("index:", idx, "value:", val)
}
</code></pre>

<h2>ğŸ“Œ Ã nghÄ©a há»‡ thá»‘ng</h2>
<ul>
  <li>Viá»‡c sá»­ dá»¥ng Ä‘Ãºng cáº¥u trÃºc Ä‘iá»u khiá»ƒn giÃºp mÃ£ rÃµ rÃ ng, dá»… Ä‘á»c.</li>
  <li>Go khuyáº¿n khÃ­ch viáº¿t code Ä‘Æ¡n giáº£n: <code>switch</code> thay vÃ¬ nhiá»u <code>if</code> lá»“ng nhau.</li>
  <li><code>range</code> ráº¥t máº¡nh vá»›i slice, map, channel â€” há»— trá»£ clean code khi láº·p.</li>
</ul>


<hr />
<h1 id="3-hÃ m-closure-vÃ -hÃ m-variadic">3. HÃ m, Closure vÃ  HÃ m Variadic</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>HÃ m (function)</strong> trong Go lÃ  <em>first-class citizen</em>: cÃ³ thá»ƒ gÃ¡n vÃ o biáº¿n, truyá»n lÃ m tham sá»‘, hoáº·c tráº£ vá» tá»« hÃ m.</li>
  <li><strong>Closure</strong>: hÃ m bÃªn trong cÃ³ thá»ƒ "báº¯t" vÃ  ghi nhá»› giÃ¡ trá»‹ tá»« scope bÃªn ngoÃ i.</li>
  <li><strong>Variadic function</strong>: hÃ m nháº­n sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ Ä‘á»™ng, biá»ƒu diá»…n báº±ng <code>...</code> vÃ  hoáº¡t Ä‘á»™ng nhÆ° slice trong runtime.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Closure cÃ³ thá»ƒ lÃ m biáº¿n escape sang heap náº¿u giá»¯ tham chiáº¿u ra ngoÃ i vÃ²ng Ä‘á»i ban Ä‘áº§u.</li>
  <li>Truyá»n hÃ m nhÆ° parameter cho phÃ©p tÃ¡ch biá»‡t logic vÃ  tuÃ¢n thá»§ nguyÃªn táº¯c SOLID.</li>
  <li>Variadic function báº£n cháº¥t lÃ  nháº­n má»™t slice â€” ráº¥t phá»• biáº¿n trong logging, middleware, builder pattern.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ code nÃ¢ng cao</h2>
<pre><code class="go">// HÃ m nhÆ° biáº¿n
hello := func(name string) string {
    return "Hello " + name
}
fmt.Println(hello("Gopher"))

// HÃ m nháº­n hÃ m khÃ¡c lÃ m tham sá»‘
func execute(fn func(string) string) {
    fmt.Println(fn("Golang"))
}
execute(hello) // truyá»n hÃ m

// Closure ghi nhá»› giÃ¡ trá»‹ bÃªn ngoÃ i
func counter() func() int {
    x := 0
    return func() int {
        x++
        return x
    }
}
c := counter()
fmt.Println(c()) // 1
fmt.Println(c()) // 2

// HÃ m tráº£ vá» hÃ m: factory pattern
func prefixer(prefix string) func(string) string {
    return func(s string) string {
        return prefix + s
    }
}
addGo := prefixer("Go-")
fmt.Println(addGo("Lang")) // Go-Lang

// Variadic function
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}
fmt.Println(sum(1, 2, 3)) // 6

// Truyá»n slice vÃ o hÃ m variadic
nums := []int{10, 20, 30}
fmt.Println(sum(nums...)) // cáº§n dáº¥u ...
</code></pre>

<h2>ğŸ“Œ GÃ³c nhÃ¬n há»‡ thá»‘ng & tá»‘i Æ°u</h2>
<ul>
  <li>HÃ m nhÆ° tham sá»‘ lÃ  ná»n táº£ng cá»§a pattern functional (e.g., handler chain, config builder).</li>
  <li>Closure cÃ³ thá»ƒ giÃºp "Ä‘Ã³ng gÃ³i logic + tráº¡ng thÃ¡i" giá»‘ng object â€” nhÆ°ng cáº§n quáº£n lÃ½ heap allocation.</li>
  <li>Go khÃ´ng há»— trá»£ default parameter â€” variadic function káº¿t há»£p vá»›i pattern giÃºp láº¥p chá»— trá»‘ng nÃ y.</li>
</ul>

<hr />
<h1 id="4-slice-map-array-vÃ -type-casting">4. Slice, Map, Array vÃ  Type Casting</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m vÃ  khÃ¡c biá»‡t</h2>
<ul>
  <li><strong>Array</strong>: KÃ­ch thÆ°á»›c cá»‘ Ä‘á»‹nh, lÃ  giÃ¡ trá»‹, khi gÃ¡n lÃ  <code>copy</code>.</li>
  <li><strong>Slice</strong>: Trá» vÃ o underlying array, cÃ³ <code>pointer + len + cap</code>, khi gÃ¡n lÃ  <code>reference</code>.</li>
  <li><strong>Map</strong>: Reference type, Ã¡nh xáº¡ key-value.</li>
  <li><strong>Type Casting</strong>: Ã‰p kiá»ƒu tÆ°á»ng minh, khÃ´ng cÃ³ implicit conversion nhÆ° C/C++.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch nÃ¢ng cao</h2>
<ul>
  <li><code>slice1 := slice2</code> â†’ cáº£ 2 cÃ¹ng trá» 1 underlying array.</li>
  <li><code>copy(slice2, slice1)</code> Ä‘á»ƒ clone slice.</li>
  <li><code>map</code> khÃ´ng cáº§n init vá»›i <code>make</code> sáº½ panic khi gÃ¡n.</li>
  <li>KhÃ´ng thá»ƒ Ã©p kiá»ƒu <code>float64 â†’ int</code> ngáº§m â€” cáº§n <code>int(f)</code>.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥</h2>
<pre><code class="go">arr := [3]int{1, 2, 3}
arr2 := arr
arr2[0] = 99 // arr[0] khÃ´ng Ä‘á»•i

slice := []int{1, 2, 3}
s2 := slice
s2[0] = 88 // áº£nh hÆ°á»Ÿng slice gá»‘c

clone := make([]int, len(slice))
copy(clone, slice) // Ä‘Ãºng cÃ¡ch clone slice

m := make(map[string]int)
m["x"] = 100

var f float64 = 3.99
i := int(f) // Ã©p kiá»ƒu rÃµ rÃ ng
</code></pre>

<hr />
<h1 id="5-struct-method-vÃ -embedded-struct">5. Struct, Method vÃ  Embedded Struct</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Struct</strong>: gom cÃ¡c field thÃ nh cáº¥u trÃºc dá»¯ liá»‡u.</li>
  <li><strong>Method</strong>: hÃ m gáº¯n vá»›i kiá»ƒu (cÃ³ thá»ƒ lÃ  pointer hoáº·c value).</li>
  <li><strong>Embedded Struct</strong>: cho phÃ©p káº¿ thá»«a hÃ nh vi.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li><code>Value receiver</code>: dÃ¹ng khi khÃ´ng cáº§n thay Ä‘á»•i data, copy.</li>
  <li><code>Pointer receiver</code>: dÃ¹ng Ä‘á»ƒ thay Ä‘á»•i trá»±c tiáº¿p hoáº·c tiáº¿t kiá»‡m copy.</li>
  <li>Sáº¯p xáº¿p field áº£nh hÆ°á»Ÿng padding/memory layout.</li>
</ul>

<pre><code class="go">type User struct {
    ID   int64
    Name string
    Age  int8
    Flag bool
}

// memory align tá»‘t hÆ¡n náº¿u sáº¯p: int64, string, bool, int8

func (u User) Greet() string {
    return "Hi " + u.Name
}
func (u *User) SetAge(age int8) {
    u.Age = age
}

type Admin struct {
    User
    Role string
}
</code></pre>

<hr />
<h1 id="6-interface-vÃ -type-assertion">6. Interface vÃ  Type Assertion</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m chuyÃªn sÃ¢u</h2>
<ul>
  <li>Interface gá»“m 2 pháº§n: <code>type</code> + <code>value</code>.</li>
  <li>Empty interface <code>interface{{}}</code>: cháº¥p nháº­n má»i kiá»ƒu, dÃ¹ng trong JSON, log...</li>
  <li>Interface lÆ°u <strong>báº£n sao</strong> giÃ¡ trá»‹ (khÃ´ng trá» trá»±c tiáº¿p unless pointer).</li>
</ul>

<h2>ğŸ’¡ PhÃ¢n tÃ­ch</h2>
<ul>
  <li><code>type assertion</code> Ã©p vá» kiá»ƒu cá»¥ thá»ƒ <code>val.(string)</code>.</li>
  <li><code>type switch</code> dÃ¹ng Ä‘á»ƒ xá»­ lÃ½ Ä‘a kiá»ƒu khi biáº¿t lÃ  interface.</li>
</ul>

<pre><code class="go">type Printer interface {
    Print()
}

type File struct{ Path string }

func (f File) Print() {
    fmt.Println("File:", f.Path)
}

func inspect(i interface{}) {
    switch v := i.(type) {
    case string:
        fmt.Println("string:", v)
    case int:
        fmt.Println("int:", v)
    default:
        fmt.Println("unknown")
    }
}
</code></pre>

<hr />
<h1 id="7-module-package-vÃ -go-mod">7. Module, Package vÃ  go mod</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m</h2>
<ul>
  <li><strong>Package</strong>: nhÃ³m logic nhá», má»—i thÆ° má»¥c cÃ³ file <code>package x</code>.</li>
  <li><strong>Module</strong>: táº­p há»£p package, báº¯t Ä‘áº§u tá»« thÆ° má»¥c cÃ³ file <code>go.mod</code>.</li>
</ul>

<h2>ğŸ“Œ CÃ¡c lá»‡nh quan trá»ng</h2>
<ul>
  <li><code>go mod init module_name</code>: khá»Ÿi táº¡o module</li>
  <li><code>go mod tidy</code>: dá»n dependency, xÃ³a unused</li>
  <li><code>go get</code>: thÃªm thÆ° viá»‡n</li>
  <li><code>go mod edit</code>: sá»­a go.mod thá»§ cÃ´ng</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥</h2>
<pre><code>// go.mod
module github.com/example/myapp

go 1.21

require (
    github.com/sirupsen/logrus v1.9.0
)

// thÆ° má»¥c project
myapp/
â”œâ”€â”€ go.mod
â”œâ”€â”€ main.go
â”œâ”€â”€ util/
â”‚   â””â”€â”€ math.go  (package util)
</code></pre>


<hr />
<h1 id="8-goroutine-vÃ -channel">8. Goroutine vÃ  Channel</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Goroutine</strong> lÃ  Ä‘Æ¡n vá»‹ thá»±c thi nháº¹ cá»§a Go, hoáº¡t Ä‘á»™ng song song (concurrent) dá»±a trÃªn cÆ¡ cháº¿ <code>M:N scheduling</code>.</li>
  <li><strong>Channel</strong> lÃ  cáº¥u trÃºc truyá»n thÃ´ng Ä‘á»“ng bá»™ giá»¯a cÃ¡c goroutine, giÃºp trao Ä‘á»•i dá»¯ liá»‡u an toÃ n.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Goroutine ráº¥t nháº¹ (~2KB stack), Ä‘Æ°á»£c Go runtime quáº£n lÃ½, cÃ³ thá»ƒ scale hÃ ng nghÃ¬n.</li>
  <li>Go sá»­ dá»¥ng M:N scheduler: nhiá»u goroutine cháº¡y trÃªn nhiá»u OS thread thÃ´ng qua logical processor (GOMAXPROCS).</li>
  <li><code>channel</code> cÃ³ 2 loáº¡i: buffered vÃ  unbuffered â€” áº£nh hÆ°á»Ÿng trá»±c tiáº¿p Ä‘áº¿n hÃ nh vi block.</li>
  <li><strong>select</strong> cho phÃ©p chá» nhiá»u channel cÃ¹ng lÃºc.</li>
  <li><code>close(chan)</code> bÃ¡o hiá»‡u channel Ä‘Ã£ Ä‘Ã³ng, khÃ´ng gá»­i thÃªm Ä‘Æ°á»£c.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("worker %d processing job %d\n", id, j)
        time.Sleep(time.Second)
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 5)
    results := make(chan int, 5)

    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)

    for r := 1; r <= 5; r++ {
        fmt.Println("result:", <-results)
    }
}
</code></pre>

<h2>ğŸ“Œ TÆ° duy há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Fan-out:</strong> nhiá»u goroutine cÃ¹ng xá»­ lÃ½ chung 1 channel Ä‘áº§u vÃ o (nhÆ° worker pool).</li>
  <li><strong>Fan-in:</strong> nhiá»u nguá»“n channel gá»™p láº¡i vá» má»™t channel Ä‘áº§u ra.</li>
  <li>TrÃ¡nh deadlock báº±ng viá»‡c luÃ´n <strong>Ä‘Ã³ng channel</strong> náº¿u khÃ´ng dÃ¹ng ná»¯a, vÃ  kiá»ƒm soÃ¡t ká»¹ unbuffered channel.</li>
  <li>DÃ¹ng <code>select {}</code> káº¿t há»£p vá»›i <code>context</code> Ä‘á»ƒ xá»­ lÃ½ timeout, cancel.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">// Goroutine Ä‘Æ¡n giáº£n
go func() {
    fmt.Println("Cháº¡y song song")
}()

// Channel Ä‘á»“ng bá»™ (unbuffered)
ch := make(chan int)
go func() {
    ch <- 10 // gá»­i dá»¯ liá»‡u
}()
val := <-ch // nháº­n dá»¯ liá»‡u
fmt.Println("Nháº­n Ä‘Æ°á»£c:", val)

// Buffered channel
cb := make(chan string, 2)
cb <- "hello"
cb <- "world"
fmt.Println(<-cb)
fmt.Println(<-cb)

// Select trÃªn nhiá»u channel
c1 := make(chan string)
c2 := make(chan string)

go func() { c1 <- "one" }()
go func() { c2 <- "two" }()

select {
case msg1 := <-c1:
    fmt.Println("tá»« c1:", msg1)
case msg2 := <-c2:
    fmt.Println("tá»« c2:", msg2)
}

// Channel Ä‘Ã³ng
done := make(chan struct{})
close(done)
_, ok := <-done
fmt.Println("Channel Ä‘Ã£ Ä‘Ã³ng:", !ok)
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li>Sá»­ dá»¥ng goroutine Ä‘á»ƒ xÃ¢y dá»±ng mÃ´ hÃ¬nh <strong>worker pool</strong>, <strong>fan-out</strong>, <strong>pipeline processing</strong>.</li>
  <li>Channel giÃºp loáº¡i bá» lock trong nhiá»u tÃ¬nh huá»‘ng, nhÆ°ng cÅ©ng dá»… gÃ¢y deadlock náº¿u khÃ´ng hiá»ƒu rÃµ blocking behavior.</li>
  <li>KhÃ´ng bao giá» Ä‘Æ°á»£c <code>close()</code> channel á»Ÿ phÃ­a nháº­n.</li>
  <li>Nil channel sáº½ block vÄ©nh viá»…n â€“ cáº§n trÃ¡nh trong production logic.</li>
</ul>

<h2>ğŸ§  NÃ¢ng cao: main cÅ©ng lÃ  má»™t Goroutine</h2>
<ul>
  <li>HÃ m <code>main()</code> trong Go thá»±c cháº¥t cháº¡y trong má»™t goroutine Ä‘áº§u tiÃªn Ä‘Æ°á»£c táº¡o bá»Ÿi runtime.</li>
  <li>Khi <code>main()</code> káº¿t thÃºc, toÃ n bá»™ chÆ°Æ¡ng trÃ¬nh sáº½ <strong>exit ngay láº­p tá»©c</strong>, ká»ƒ cáº£ cÃ¡c goroutine khÃ¡c chÆ°a hoÃ n táº¥t.</li>
  <li>VÃ¬ váº­y: náº¿u báº¡n khá»Ÿi táº¡o goroutine trong <code>main()</code> mÃ  khÃ´ng dÃ¹ng <code>WaitGroup</code>, <code>channel</code>, hoáº·c <code>sleep</code>, chÆ°Æ¡ng trÃ¬nh cÃ³ thá»ƒ káº¿t thÃºc khi goroutine chÆ°a cháº¡y xong.</li>
</ul>

<h2>ğŸ§  Khá»Ÿi táº¡o vÃ  thá»© tá»± thá»±c thi: func init, import</h2>
<ul>
  <li>Go tá»± Ä‘á»™ng cháº¡y táº¥t cáº£ <code>func init()</code> cá»§a tá»«ng file trÆ°á»›c khi <code>main()</code> cháº¡y.</li>
  <li>Trong má»—i package:
    <ul>
      <li>Biáº¿n toÃ n cá»¥c Ä‘Æ°á»£c khá»Ÿi táº¡o trÆ°á»›c</li>
      <li>Sau Ä‘Ã³ cháº¡y <code>init()</code> theo thá»© tá»± khai bÃ¡o</li>
    </ul>
  </li>
  <li>Thá»© tá»± import vÃ  khá»Ÿi táº¡o package lÃ  <strong>Ä‘á»‡ quy theo dependency</strong>: Go Ä‘áº£m báº£o cÃ¡c package phá»¥ thuá»™c Ä‘Æ°á»£c init trÆ°á»›c khi package cha cháº¡y init.</li>
</ul>

<pre><code class="go">package main

import "fmt"

var G = initVar()

func initVar() int {
    fmt.Println("initVar gá»i trÆ°á»›c main")
    return 100
}

func init() {
    fmt.Println("init cháº¡y trÆ°á»›c main")
}

func main() {
    fmt.Println("main báº¯t Ä‘áº§u")
}
</code></pre>


<hr />
<h1 id="9-Ä‘á»“ng-bá»™-hoÃ¡-vá»›i-mutex-rwmutex-waitgroup">9. Äá»“ng bá»™ hoÃ¡ vá»›i Mutex, RWMutex, WaitGroup</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Mutex (Mutual Exclusion)</strong>: dÃ¹ng Ä‘á»ƒ báº£o vá»‡ vÃ¹ng tÃ i nguyÃªn chá»‰ cho phÃ©p 1 goroutine truy cáº­p táº¡i 1 thá»i Ä‘iá»ƒm.</li>
  <li><strong>RWMutex</strong>: cho phÃ©p nhiá»u goroutine Ä‘á»c Ä‘á»“ng thá»i (Read Lock), nhÆ°ng chá»‰ 1 ghi (Write Lock).</li>
  <li><strong>WaitGroup</strong>: dÃ¹ng Ä‘á»ƒ chá» táº¥t cáº£ goroutine hoÃ n táº¥t cÃ´ng viá»‡c trÆ°á»›c khi tiáº¿p tá»¥c.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Mutex hoáº¡t Ä‘á»™ng giá»‘ng nhÆ° critical section â€“ khÃ´ng dÃ¹ng Ä‘Ãºng cÃ³ thá»ƒ gÃ¢y <strong>deadlock</strong>.</li>
  <li>RWMutex dÃ¹ng tá»‘t khi tá»‰ lá»‡ Ä‘á»c cao hÆ¡n ghi, giÃºp tÄƒng concurrency.</li>
  <li>WaitGroup giÃºp báº¡n trÃ¡nh gá»i <code>time.Sleep</code> trong cÃ¡c tÃ¡c vá»¥ song song.</li>
  <li><strong>LuÃ´n</strong> unlock sau lock â€“ dÃ¹ng <code>defer</code> Ä‘á»ƒ an toÃ n.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">import (
    "fmt"
    "sync"
)

var mu sync.Mutex
var count int

func increment() {
    mu.Lock()
    defer mu.Unlock()
    count++
}

// RWMutex cho Ä‘á»c nhiá»u - ghi 1
var rw sync.RWMutex
var data = make(map[string]string)

func readData(key string) string {
    rw.RLock()
    defer rw.RUnlock()
    return data[key]
}

func writeData(key, val string) {
    rw.Lock()
    defer rw.Unlock()
    data[key] = val
}

// WaitGroup vÃ­ dá»¥
var wg sync.WaitGroup

func worker(id int) {
    defer wg.Done()
    fmt.Printf("Worker %d xong viá»‡c\n", id)
}

func main() {
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i)
    }
    wg.Wait() // chá» táº¥t cáº£ worker káº¿t thÃºc
    fmt.Println("Táº¥t cáº£ goroutine Ä‘Ã£ hoÃ n táº¥t")
}
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Mutex</strong>: dÃ¹ng Ä‘á»ƒ Ä‘á»“ng bá»™ hÃ³a cÃ¡c biáº¿n toÃ n cá»¥c khi nhiá»u goroutine Ä‘á»c/ghi cÃ¹ng lÃºc.</li>
  <li><strong>RWMutex</strong>: tá»‘i Æ°u hoÃ¡ hiá»‡u suáº¥t khi sá»‘ lÆ°á»£ng Ä‘á»c nhiá»u gáº¥p nhiá»u láº§n ghi.</li>
  <li><strong>WaitGroup</strong>: thay tháº¿ cho sleep/wait thá»§ cÃ´ng, cá»±c ká»³ hiá»‡u quáº£ trong batch job, worker pool, async task.</li>
  <li><strong>Tips:</strong> LuÃ´n unlock báº±ng <code>defer</code>, trÃ¡nh quÃªn vÃ  gÃ¢y block toÃ n chÆ°Æ¡ng trÃ¬nh.</li>
</ul>



<hr />
<h1 id="10-context-vÃ -lifecycle-control">10. Context vÃ  Lifecycle Control</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Context</strong> lÃ  chuáº©n cá»§a Go Ä‘á»ƒ truyá»n timeout, deadline, cancel signal vÃ  dá»¯ liá»‡u nháº¹ giá»¯a cÃ¡c goroutine.</li>
  <li>NÃ³ giÃºp quáº£n lÃ½ <strong>vÃ²ng Ä‘á»i</strong> cá»§a tÃ¡c vá»¥ hoáº·c request xuyÃªn suá»‘t há»‡ thá»‘ng.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Context nÃªn Ä‘Æ°á»£c truyá»n dÆ°á»›i dáº¡ng parameter Ä‘áº§u tiÃªn: <code>func(ctx context.Context, ...)</code></li>
  <li>CÃ¡c loáº¡i context:
    <ul>
      <li><code>context.Background()</code>: gá»‘c, khÃ´ng bao giá» bá»‹ cancel</li>
      <li><code>context.TODO()</code>: placeholder khi chÆ°a rÃµ context thá»±c sá»±</li>
      <li><code>context.WithCancel</code>, <code>WithTimeout</code>, <code>WithDeadline</code>: táº¡o context cÃ³ kháº£ nÄƒng dá»«ng</li>
    </ul>
  </li>
  <li>Context tá»± Ä‘á»™ng cancel khi deadline timeout hoáº·c cha bá»‹ cancel</li>
  <li>LÃ½ tÆ°á»Ÿng dÃ¹ng trong: HTTP request, job, stream, signal handling, database...</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, name string) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Stopped:", name)
            return
        default:
            fmt.Println("Working:", name)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    go worker(ctx, "A")
    go worker(ctx, "B")

    <-ctx.Done()
    fmt.Println("Main: Timeout reached")
}
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li>Context Ä‘Æ°á»£c dÃ¹ng rá»™ng rÃ£i trong <strong>HTTP server</strong>, <strong>database/sql</strong>, <strong>gRPC</strong>, <strong>Kafka</strong>, etc.</li>
  <li>Truyá»n <code>context.Context</code> Ä‘Ãºng chuáº©n giÃºp dá»… debug, trace, stop task theo yÃªu cáº§u</li>
  <li>Context há»— trá»£ <strong>cancel propagation</strong> â†’ goroutine con tá»± Ä‘á»™ng dá»«ng khi cha timeout</li>
  <li><strong>LÆ°u Ã½:</strong> KhÃ´ng dÃ¹ng context Ä‘á»ƒ lÆ°u dá»¯ liá»‡u lá»›n hoáº·c logic â€” chá»‰ dÃ¹ng Ä‘á»ƒ truyá»n metadata nháº¹.</li>
</ul>
<h2>ğŸ“Š Flow: Truyá»n context tá»« Envoy xuá»‘ng cÃ¡c táº§ng trong há»‡ thá»‘ng</h2>

<p>Trong há»‡ thá»‘ng microservice dÃ¹ng Envoy hoáº·c gRPC gateway, context thÆ°á»ng Ä‘Æ°á»£c truyá»n xuyÃªn suá»‘t tá»« request gá»‘c tá»›i tá»«ng táº§ng function vÃ  database.</p>

<pre><code>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Envoy Proxy  â”‚
â”‚ - Truyá»n header: x-request-id, deadline, trace-id
â”‚ - Forward HTTP/gRPC request
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Gateway API  â”‚
â”‚ - Táº¡o context gá»‘c: context.WithTimeout(...)
â”‚ - ÄÃ­nh trace-id vÃ o context
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application Handler        â”‚
â”‚ - ctx Ä‘Æ°á»£c truyá»n vÃ o hÃ m â”‚
â”‚   func(ctx context.Context)â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Layer / Usecase    â”‚
â”‚ - ctx tiáº¿p tá»¥c Ä‘Æ°á»£c truyá»nâ”‚
â”‚ - Add logging/tracing tag â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Database / Repository Layerâ”‚
â”‚ - DÃ¹ng ctx trong query:    â”‚
â”‚   db.QueryContext(ctx, ...)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<h2>ğŸ“Œ Ã nghÄ©a thiáº¿t káº¿</h2>
<ul>
  <li><strong>Truyá»n context xuyÃªn suá»‘t</strong> giÃºp enforce timeout, cancel toÃ n bá»™ call chain khi request timeout tá»« Ä‘áº§u.</li>
  <li><code>ctx</code> chá»©a metadata nhÆ° trace-id, user-id â†’ dÃ¹ng cho log/tracing/monitoring.</li>
  <li><code>db.QueryContext</code> giÃºp tá»± Ä‘á»™ng abort query khi context bá»‹ cancel (timeout hoáº·c shutdown).</li>
  <li>Viá»‡c propagate Ä‘Ãºng context giÃºp báº¡n build há»‡ thá»‘ng resilient, observable vÃ  debuggable.</li>
</ul>


<hr />
<h1 id="11-error-handling-vÃ -panicrecover">11. Error Handling vÃ  Panic/Recover</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Error</strong>: lÃ  giÃ¡ trá»‹ tráº£ vá» Ä‘áº§u tiÃªn cho má»i hÃ m cÃ³ thá»ƒ tháº¥t báº¡i â€“ dáº¡ng <code>error</code> interface.</li>
  <li><strong>Panic</strong>: ngáº¯t luá»“ng xá»­ lÃ½ hiá»‡n táº¡i ngay láº­p tá»©c â€“ chá»‰ nÃªn dÃ¹ng cho lá»—i láº­p trÃ¬nh nghiÃªm trá»ng.</li>
  <li><strong>Recover</strong>: giÃºp "báº¯t" panic trong <code>defer</code>, phá»¥c há»“i Ä‘iá»u khiá»ƒn chÆ°Æ¡ng trÃ¬nh vÃ  trÃ¡nh crash toÃ n bá»™ service.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li><code>error</code> nÃªn Ä‘Æ°á»£c wrap láº¡i Ä‘á»ƒ giá»¯ ngá»¯ cáº£nh: dÃ¹ng <code>fmt.Errorf("thao tÃ¡c tháº¥t báº¡i: %w", err)</code>.</li>
  <li>DÃ¹ng <code>errors.Is</code>, <code>errors.As</code>, <code>errors.Unwrap</code> Ä‘á»ƒ phÃ¢n tÃ­ch chain lá»—i khi cáº§n.</li>
  <li><code>recover()</code> chá»‰ hoáº¡t Ä‘á»™ng bÃªn trong <code>defer</code>. BÃªn ngoÃ i sáº½ khÃ´ng ngÄƒn panic.</li>
  <li>Go runtime khi panic:
    <ul>
      <li>Gá»i toÃ n bá»™ defer stack</li>
      <li>Náº¿u cÃ³ recover â†’ láº¥y láº¡i Ä‘iá»u khiá»ƒn</li>
      <li>Náº¿u khÃ´ng â†’ in stacktrace vÃ  <strong>exit</strong></li>
    </ul>
  </li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥: error wrapping + panic/recover</h2>
<pre><code class="go">func doSomething() error {
    err := errors.New("káº¿t ná»‘i tháº¥t báº¡i")
    return fmt.Errorf("lá»—i khi gá»i backend: %w", err)
}

func safeRun() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("ÄÃ£ recover tá»« panic:", r)
        }
    }()
    panic("há»‡ thá»‘ng lá»—i nghiÃªm trá»ng")
}
</code></pre>
<h2>ğŸ§  Graceful Shutdown hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?</h2>
<ul>
  <li>Khi báº¡n nháº¥n <code>Ctrl+C</code> hoáº·c há»‡ thá»‘ng gá»­i tÃ­n hiá»‡u <code>SIGINT</code>, <code>SIGTERM</code> (tá»« orchestrator nhÆ° Kubernetes), Go program cÃ³ thá»ƒ <strong>báº¯t tÃ­n hiá»‡u nÃ y</strong> qua <code>os/signal</code>.</li>
  <li>Khi báº¯t Ä‘Æ°á»£c tÃ­n hiá»‡u, báº¡n gá»i <code>cancel()</code> tá»« <code>context.WithCancel</code> Ä‘á»ƒ truyá»n tÃ­n hiá»‡u dá»«ng xuá»‘ng táº¥t cáº£ cÃ¡c táº§ng bÃªn dÆ°á»›i.</li>
  <li>Má»—i goroutine Ä‘ang cháº¡y cáº§n láº¯ng nghe <code>ctx.Done()</code> Ä‘á»ƒ biáº¿t khi nÃ o cáº§n dá»«ng.</li>
  <li>Báº¡n cÃ³ thá»ƒ dÃ¹ng <code>sync.WaitGroup</code> Ä‘á»ƒ Ä‘áº£m báº£o táº¥t cáº£ goroutine xá»­ lÃ½ xong trÆ°á»›c khi main káº¿t thÃºc.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥: shutdown Ä‘á»£i worker xá»­ lÃ½ xong</h2>
<pre><code class="go">func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    sig := make(chan os.Signal, 1)
    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        <-sig
        fmt.Println("Nháº­n tÃ­n hiá»‡u táº¯t, huá»· context...")
        cancel()
    }()

    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()
        runJob(ctx)
    }()

    wg.Wait() // Ä‘á»£i toÃ n bá»™ goroutine hoÃ n táº¥t
    fmt.Println("Shutdown hoÃ n táº¥t")
}

func runJob(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Dá»«ng xá»­ lÃ½ cÃ´ng viá»‡c")
            return
        default:
            fmt.Println("Äang xá»­ lÃ½ cÃ´ng viá»‡c...")
            time.Sleep(1 * time.Second)
        }
    }
}
</code></pre>

<h2>ğŸ“Œ TÃ³m táº¯t lá»£i Ã­ch Graceful Shutdown</h2>
<ul>
  <li>Cho phÃ©p há»‡ thá»‘ng <strong>hoÃ n táº¥t cÃ´ng viá»‡c dang dá»Ÿ</strong> trÆ°á»›c khi thoÃ¡t.</li>
  <li>Giáº£i phÃ³ng tÃ i nguyÃªn Ä‘Ãºng cÃ¡ch (database, network, file, goroutine).</li>
  <li>KhÃ´ng bá»‹ máº¥t dá»¯ liá»‡u hoáº·c ngáº¯t káº¿t ná»‘i giá»¯a chá»«ng.</li>
  <li>Chuáº©n ká»¹ thuáº­t báº¯t buá»™c vá»›i <strong>microservice, HTTP/gRPC API, cronjob</strong> production.</li>
</ul>


<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Error wrapping</strong>: duy trÃ¬ stack trace, logic táº§ng cao dá»… debug.</li>
  <li><strong>Recover</strong>: chá»‘ng crash há»‡ thá»‘ng â€” Ä‘áº·c biá»‡t á»Ÿ cÃ¡c goroutine, worker hoáº·c middleware.</li>
  <li><strong>Graceful shutdown</strong>: báº¯t buá»™c á»Ÿ service production â€” trÃ¡nh máº¥t dá»¯ liá»‡u, close connection Ä‘Ãºng cÃ¡ch.</li>
</ul>



<hr />
<h1 id="12-logging-nÃ¢ng-cao-vá»›i-logrus-zap-zerolog">12. Logging nÃ¢ng cao vá»›i logrus, zap, zerolog</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li>Logging lÃ  thÃ nh pháº§n cá»‘t lÃµi trong má»i service Ä‘á»ƒ <strong>trace, debug, audit</strong> vÃ  <strong>monitor</strong>.</li>
  <li>Go há»— trá»£ logging qua nhiá»u thÆ° viá»‡n ná»•i báº­t:
    <ul>
      <li><strong>logrus</strong>: phá»• biáº¿n, Ä‘Æ¡n giáº£n, dá»… dÃ¹ng.</li>
      <li><strong>zap</strong>: hiá»‡u nÄƒng cao, JSON structured log, production ready.</li>
      <li><strong>zerolog</strong>: tá»‘c Ä‘á»™ cao, encode trá»±c tiáº¿p vÃ o writer.</li>
    </ul>
  </li>
</ul>

<h2>ğŸ” So sÃ¡nh 3 thÆ° viá»‡n phá»• biáº¿n</h2>
<table>
<thead>
<tr><th>ThÆ° viá»‡n</th><th>Æ¯u Ä‘iá»ƒm</th><th>NhÆ°á»£c Ä‘iá»ƒm</th></tr>
</thead>
<tbody>
<tr>
  <td>logrus</td>
  <td>Dá»… dÃ¹ng, phá»• biáº¿n</td>
  <td>Hiá»‡u nÄƒng tháº¥p hÆ¡n (dÃ¹ng reflection)</td>
</tr>
<tr>
  <td>zap</td>
  <td>Structured, nhanh, JSON tá»‘t</td>
  <td>API hÆ¡i verbose</td>
</tr>
<tr>
  <td>zerolog</td>
  <td>Ráº¥t nhanh, binary-safe</td>
  <td>API khÃ¡c biá»‡t, khÃ³ debug náº¿u quen logrus</td>
</tr>
</tbody>
</table>

<h2>ğŸ’¡ VÃ­ dá»¥ sá»­ dá»¥ng logrus</h2>
<pre><code class="go">import log "github.com/sirupsen/logrus"

func main() {
    log.SetFormatter(&log.JSONFormatter{})
    log.SetLevel(log.InfoLevel)

    log.WithFields(log.Fields{
        "user_id":  123,
        "action":   "login",
    }).Info("User logged in")
}
</code></pre>

<h2>ğŸ’¡ VÃ­ dá»¥ zap production logger</h2>
<pre><code class="go">import (
    "go.uber.org/zap"
)

func main() {
    logger, _ := zap.NewProduction()
    defer logger.Sync()

    logger.Info("Xá»­ lÃ½ xong",
        zap.String("user", "abc"),
        zap.Int("duration_ms", 124),
    )
}
</code></pre>

<h2>ğŸ“Œ Best Practice logging</h2>
<ul>
  <li><strong>KhÃ´ng</strong> dÃ¹ng <code>fmt.Println</code> cho production log.</li>
  <li>Sá»­ dá»¥ng logging <strong>structured (JSON)</strong> Ä‘á»ƒ mÃ¡y cÃ³ thá»ƒ parse Ä‘Æ°á»£c.</li>
  <li>Log theo <strong>ngá»¯ cáº£nh</strong>: user, request-id, trace-id (log-enrichment theo context).</li>
  <li>TÃ¡ch <strong>stdout</strong> (info, debug) vÃ  <strong>stderr</strong> (error) náº¿u cháº¡y trong container/Kubernetes.</li>
  <li>Káº¿t há»£p vá»›i tools nhÆ° <code>ELK stack</code>, <code>Grafana Loki</code> Ä‘á»ƒ visualize vÃ  alert.</li>
</ul>


<hr />
<h1 id="13-testing-benchmark-table-driven-test">13. Testing, Benchmark, Table-Driven Test</h1>

<h2>ğŸ§  Tá»•ng quan testing trong Go</h2>
<ul>
  <li>Go cung cáº¥p testing built-in qua package <code>testing</code>.</li>
  <li>Test file cÃ³ háº­u tá»‘ <code>_test.go</code>, tÃªn hÃ m báº¯t Ä‘áº§u báº±ng <code>Test*</code>.</li>
  <li>Benchmark test dÃ¹ng Ä‘á»ƒ Ä‘o hiá»‡u nÄƒng (<code>Benchmark*</code>).</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ Ä‘Æ¡n giáº£n</h2>
<pre><code class="go">func Add(a, b int) int {
    return a + b
}

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("expected 5, got %d", result)
    }
}
</code></pre>

<h2>ğŸ§ª Table-Driven Test (pattern chuáº©n)</h2>
<pre><code class="go">func TestAddTable(t *testing.T) {
    cases := []struct {
        name     string
        a, b, out int
    }{
        {"2+3", 2, 3, 5},
        {"-1+1", -1, 1, 0},
    }

    for _, c := range cases {
        t.Run(c.name, func(t *testing.T) {
            res := Add(c.a, c.b)
            if res != c.out {
                t.Errorf("got %d, want %d", res, c.out)
            }
        })
    }
}
</code></pre>

<h2>âš™ Benchmark</h2>
<pre><code class="go">func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = Add(1, 2)
    }
}
</code></pre>

<h2>ğŸ“Œ Tips</h2>
<ul>
  <li>DÃ¹ng <code>go test -v ./...</code> Ä‘á»ƒ test toÃ n bá»™ module.</li>
  <li>DÃ¹ng <code>-bench</code> Ä‘á»ƒ benchmark, <code>-cover</code> Ä‘á»ƒ Ä‘o coverage.</li>
  <li>DÃ¹ng <code>assert</code> libs nhÆ° <code>stretchr/testify</code> khi test lá»›n.</li>
</ul>

<hr />
<hr />
<h1 id="14-debugging-race-condition-deadlock">14. Debugging, Race Condition, Deadlock</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Race condition</strong>: khi nhiá»u goroutine truy cáº­p/ghi vÃ o vÃ¹ng nhá»› mÃ  khÃ´ng Ä‘á»“ng bá»™ â†’ dá»¯ liá»‡u khÃ´ng nháº¥t quÃ¡n, hÃ nh vi ngáº«u nhiÃªn.</li>
  <li><strong>Deadlock</strong>: khi táº¥t cáº£ goroutine Ä‘á»u block â†’ chÆ°Æ¡ng trÃ¬nh Ä‘á»©ng im vÄ©nh viá»…n.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u: CÃ¡c lá»—i race phá»• biáº¿n</h2>

<ul>
  <li><strong>1. Ghi/Ä‘á»c vÃ o shared variable mÃ  khÃ´ng cÃ³ lock</strong></li>
  <li><strong>2. Channel write khÃ´ng cÃ³ goroutine nháº­n â†’ block â†’ deadlock</strong></li>
  <li><strong>3. Truy cáº­p slice/map cÃ¹ng lÃºc â†’ race hoáº·c panic</strong></li>
  <li><strong>4. Database tx/context bá»‹ ghi Ä‘Ã¨ qua goroutine</strong></li>
  <li><strong>5. Truy cáº­p pointer khÃ´ng Ä‘á»“ng bá»™</strong></li>
</ul>

<h2>ğŸ’£ VÃ­ dá»¥ lá»—i Race Condition thá»±c táº¿</h2>

<pre><code class="go">// Ghi vÃ o biáº¿n x tá»« nhiá»u goroutine (race)
var x int
for i := 0; i < 100; i++ {
    go func() {
        x++
    }()
}
</code></pre>

<pre><code class="go">// Race khi truy cáº­p slice cÃ¹ng lÃºc
var nums = []int{}
for i := 0; i < 10; i++ {
    go func(val int) {
        nums = append(nums, val) // race!
    }(i)
}
</code></pre>

<pre><code class="go">// Race khi dÃ¹ng cÃ¹ng transaction
func main() {
    tx, _ := db.BeginTx(ctx, nil)

    go func() {
        tx.Exec("UPDATE users SET ...") // lá»—i náº¿u context bá»‹ cancel hoáº·c tx dÃ¹ng sai thread
    }()
}
</code></pre>

<h2>ğŸ§± Deadlock thÆ°á»ng gáº·p</h2>
<pre><code class="go">// Channel khÃ´ng cÃ³ ngÆ°á»i nháº­n â†’ block mÃ£i mÃ£i
ch := make(chan int)
ch <- 1 // block
</code></pre>

<pre><code class="go">// Goroutine chá» nhau theo vÃ²ng trÃ²n
mu1, mu2 := sync.Mutex{}, sync.Mutex{}

go func() {
    mu1.Lock(); defer mu1.Unlock()
    mu2.Lock(); defer mu2.Unlock()
}()

go func() {
    mu2.Lock(); defer mu2.Unlock()
    mu1.Lock(); defer mu1.Unlock()
}()
</code></pre>

<h2>ğŸ” PhÃ¢n tÃ­ch nguyÃªn nhÃ¢n & fix</h2>
<ul>
  <li><code>append()</code> trÃªn slice khÃ´ng Ä‘á»“ng bá»™ cáº§n dÃ¹ng <code>sync.Mutex</code> hoáº·c <code>channel</code> lÃ m queue</li>
  <li>KhÃ´ng chia sáº» <code>tx</code> hoáº·c <code>context</code> giá»¯a goroutine khi xá»­ lÃ½ DB</li>
  <li>KhÃ´ng dÃ¹ng map hoáº·c slice khÃ´ng Ä‘á»“ng bá»™ trong handler gá»‘c</li>
  <li>LuÃ´n close channel á»Ÿ phÃ­a gá»­i; trÃ¡nh close 2 láº§n</li>
</ul>

<h2>ğŸ§ª CÃ¡ch phÃ¡t hiá»‡n bug race/deadlock</h2>
<ul>
  <li>DÃ¹ng <code>go run -race</code> hoáº·c <code>go test -race</code> â†’ hiá»ƒn thá»‹ dÃ²ng code xáº£y ra race</li>
  <li>DÃ¹ng <code>pprof</code> â†’ theo dÃµi goroutine blocking</li>
  <li>DÃ¹ng <code>runtime.NumGoroutine()</code> Ä‘á»ƒ kiá»ƒm soÃ¡t leak</li>
</ul>

<h2>ğŸ“Œ Gá»£i Ã½ ká»¹ thuáº­t há»‡ thá»‘ng</h2>
<ul>
  <li>LuÃ´n xÃ¡c Ä‘á»‹nh biáº¿n shared cáº§n báº£o vá»‡ báº±ng lock hoáº·c truyá»n dá»¯ liá»‡u qua channel</li>
  <li>Truyá»n dá»¯ liá»‡u â†’ dÃ¹ng channel; chia sáº» tráº¡ng thÃ¡i â†’ dÃ¹ng mutex</li>
  <li>TrÃ¡nh close channel tá»« nhiá»u nÆ¡i</li>
  <li>Viáº¿t log theo traceID Ä‘á»ƒ dá»… theo dáº¥u goroutine trong production</li>
</ul>

<hr />
<h1 id="15-memory-management--escape-analysis">15. Memory Management & Escape Analysis</h1>

<h2>ğŸ§  Tá»•ng quan vá» quáº£n lÃ½ bá»™ nhá»› trong Go</h2>
<ul>
  <li>Go sá»­ dá»¥ng <strong>managed memory model</strong> â€“ báº¡n khÃ´ng cáº§n malloc/free thá»§ cÃ´ng.</li>
  <li>Go runtime quyáº¿t Ä‘á»‹nh biáº¿n Ä‘Æ°á»£c cáº¥p phÃ¡t trÃªn stack hay heap.</li>
  <li><strong>Escape Analysis</strong>: quÃ¡ trÃ¬nh xÃ¡c Ä‘á»‹nh biáº¿n cÃ³ â€œthoÃ¡tâ€ khá»i scope hiá»‡n táº¡i khÃ´ng â†’ náº¿u cÃ³ â†’ Ä‘Æ°a lÃªn heap.</li>
</ul>

<h2>ğŸ” Stack vs Heap</h2>
<ul>
  <li><strong>Stack</strong>: nhanh, vÃ¹ng nhá»› táº¡m thá»i, tá»± Ä‘á»™ng reclaim.</li>
  <li><strong>Heap</strong>: cáº¥p phÃ¡t Ä‘á»™ng, cáº§n GC quÃ©t Ä‘á»ƒ reclaim, cháº­m hÆ¡n.</li>
  <li>Escape sang heap = tÄƒng Ã¡p lá»±c GC, giáº£m hiá»‡u nÄƒng.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥: khi nÃ o biáº¿n escape</h2>
<pre><code class="go">// KhÃ´ng escape - náº±m trÃªn stack
func stackAlloc() int {
    x := 42
    return x
}

// Escape - tráº£ vá» pointer â†’ lÃªn heap
func heapAlloc() *int {
    x := 42
    return &x
}
</code></pre>

<h2>ğŸ§ª Xem káº¿t quáº£ Escape Analysis</h2>
<pre><code class="bash">go build -gcflags="-m" ./main.go
</code></pre>
<p>Káº¿t quáº£:</p>
<pre><code># command-line-arguments
./main.go:10:6: moved to heap: x
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ tá»‘i Æ°u</h2>
<ul>
  <li>TrÃ¡nh tráº£ vá» pointer Ä‘áº¿n local var náº¿u khÃ´ng cáº§n thiáº¿t.</li>
  <li>TrÃ¡nh giá»¯ reference Ä‘áº¿n biáº¿n lá»›n trong closure náº¿u closure sá»‘ng lÃ¢u.</li>
  <li>Chia nhá» function Ä‘á»ƒ giÃºp compiler nháº­n ra vÃ¹ng khÃ´ng cáº§n escape.</li>
</ul>
<hr />
<h1 id="16-garbage-collection-vÃ -runtime-scheduler">16. Garbage Collection vÃ  Runtime Scheduler</h1>

<h2>ğŸ§  Tá»•ng quan GC vÃ  Scheduler</h2>
<ul>
  <li><strong>Garbage Collection (GC)</strong>: há»‡ thá»‘ng tá»± Ä‘á»™ng giáº£i phÃ³ng bá»™ nhá»› khÃ´ng cÃ²n dÃ¹ng ná»¯a trÃªn heap.</li>
  <li><strong>Go Scheduler</strong>: cÆ¡ cháº¿ quáº£n lÃ½ goroutine â†’ Ã¡nh xáº¡ M:N (many goroutine â†’ many OS threads).</li>
</ul>

<h2>ğŸ§  GC: cÆ¡ cháº¿, Ä‘áº·c Ä‘iá»ƒm</h2>
<ul>
  <li>Go sá»­ dá»¥ng GC kiá»ƒu <strong>tracing + concurrent + generational</strong>.</li>
  <li>GC khÃ´ng dá»«ng toÃ n bá»™ chÆ°Æ¡ng trÃ¬nh (stop-the-world ráº¥t ngáº¯n).</li>
  <li>KÃ­ch hoáº¡t khi heap lá»›n, runtime trigger, hoáº·c gá»i <code>runtime.GC()</code>.</li>
</ul>

<h2>ğŸ’¡ Scheduler vÃ  GOMAXPROCS</h2>
<ul>
  <li>Scheduler gá»“m:
    <ul>
      <li><strong>G</strong>: Goroutine</li>
      <li><strong>M</strong>: OS Thread</li>
      <li><strong>P</strong>: Processor â€“ phÃ¢n phá»‘i G lÃªn M</li>
    </ul>
  </li>
  <li><code>GOMAXPROCS</code>: giá»›i háº¡n sá»‘ core Go Ä‘Æ°á»£c dÃ¹ng Ä‘á»“ng thá»i.</li>
</ul>

<h2>ğŸ“Œ Tá»‘i Æ°u</h2>
<ul>
  <li>Dá»n reference khÃ´ng dÃ¹ng Ä‘á»ƒ GC thu há»“i nhanh hÆ¡n.</li>
  <li>Háº¡n cháº¿ object lá»›n sá»‘ng lÃ¢u â†’ giáº£m Ã¡p lá»±c GC.</li>
  <li>DÃ¹ng <code>sync.Pool</code> Ä‘á»ƒ reuse object.</li>
</ul>
<h2>ğŸ§  GC hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o (Deep Working)</h2>

<ul>
  <li>Go GC hoáº¡t Ä‘á»™ng theo chu ká»³, gá»“m 3 phase chÃ­nh:
    <ol>
      <li><strong>STW - Stop the World (Prepare)</strong>: táº¡m dá»«ng toÃ n bá»™ goroutine Ä‘á»ƒ xÃ¡c Ä‘á»‹nh root set.</li>
      <li><strong>Mark phase (concurrent)</strong>: Ä‘Ã¡nh dáº¥u táº¥t cáº£ object cÃ²n Ä‘Æ°á»£c tham chiáº¿u.</li>
      <li><strong>Sweep phase</strong>: thu dá»n object khÃ´ng cÃ²n dÃ¹ng, tráº£ láº¡i heap.</li>
    </ol>
  </li>

  <li>STW diá»…n ra ngáº¯n (~100Âµs), sau Ä‘Ã³ goroutine tiáº¿p tá»¥c cháº¡y song song vá»›i phase mark.</li>
  <li>GC sá»­ dá»¥ng <strong>tri-color marking</strong>: white (chÆ°a quÃ©t), grey (Ä‘ang quÃ©t), black (quÃ©t xong).</li>
  <li>Æ¯u tiÃªn dá»n object nhá», ngáº¯n háº¡n (young gen) â€“ giá»‘ng generational GC trong JVM.</li>
</ul>

<h2>â± Khi nÃ o GC Ä‘Æ°á»£c trigger?</h2>
<ul>
  <li>Heap growth vÆ°á»£t ngÆ°á»¡ng (<code>GOGC</code> % growth)</li>
  <li>Manually gá»i <code>runtime.GC()</code></li>
  <li>TrÃ¬nh runtime tháº¥y tá»· lá»‡ goroutine idle phÃ¹ há»£p</li>
</ul>

<h2>âš™ Tham sá»‘ Ä‘iá»u chá»‰nh GC</h2>
<ul>
  <li><code>GOGC</code>: tá»‰ lá»‡ tÄƒng heap Ä‘á»ƒ kÃ­ch hoáº¡t GC (default 100 â†’ GC cháº¡y khi heap gáº¥p Ä‘Ã´i)</li>
  <li>Set <code>GOGC=off</code> Ä‘á»ƒ disable GC (chá»‰ dÃ¹ng khi debug)</li>
</ul>

<h2>ğŸ“Œ áº¢nh hÆ°á»Ÿng há»‡ thá»‘ng & Tá»‘i Æ°u</h2>
<ul>
  <li>GC cÃ ng cháº¡y thÆ°á»ng xuyÃªn â†’ giáº£m memory usage nhÆ°ng tá»‘n CPU.</li>
  <li>GC cháº¡y Ã­t â†’ tÄƒng latency request do heap phÃ¬nh to.</li>
  <li><strong>Optimize:</strong>
    <ul>
      <li>TrÃ¡nh return pointer â†’ giá»¯ stack allocation</li>
      <li>Dá»n nil object sá»›m (giÃºp mark nhanh)</li>
      <li>DÃ¹ng <code>sync.Pool</code> Ä‘á»ƒ giáº£m new()</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="17-build-system-vÃ -cross-compilation">17. Build System vÃ  Cross Compilation</h1>

<h2>ğŸ§  Tá»•ng quan há»‡ thá»‘ng build trong Go</h2>
<ul>
  <li>Go dÃ¹ng command line tool `go build` Ä‘á»ƒ biÃªn dá»‹ch source code thÃ nh binary standalone.</li>
  <li>KhÃ´ng cáº§n makefile, khÃ´ng cáº§n linker script â€“ táº¥t cáº£ Ä‘Æ°á»£c tÃ­ch há»£p sáºµn trong Go toolchain.</li>
</ul>

<h2>ğŸ” CÆ¡ cháº¿ hoáº¡t Ä‘á»™ng build</h2>
<ul>
  <li><code>go build</code> thá»±c hiá»‡n:
    <ol>
      <li>PhÃ¢n tÃ­ch dependency tá»« <code>import</code></li>
      <li>Resolve module qua <code>go.mod</code></li>
      <li>Compile tá»«ng package â†’ assemble â†’ link thÃ nh binary</li>
    </ol>
  </li>
  <li>Build output lÃ  binary tá»± Ä‘á»§ (no external runtime needed)</li>
</ul>

<h2>ğŸŒ Cross Compilation</h2>
<ul>
  <li>Go há»— trá»£ cross-build máº·c Ä‘á»‹nh â€“ chá»‰ cáº§n set biáº¿n mÃ´i trÆ°á»ng:</li>
</ul>
<pre><code class="bash">GOOS=linux GOARCH=amd64 go build -o app-linux
GOOS=windows GOARCH=386 go build -o app.exe
</code></pre>

<h2>ğŸ“Œ áº¢nh hÆ°á»Ÿng há»‡ thá»‘ng & Tá»‘i Æ°u</h2>
<ul>
  <li>Go build nhanh, khÃ´ng cáº§n toolchain ngoÃ i â†’ phÃ¹ há»£p CI/CD realtime.</li>
  <li>Binary Go tá»± Ä‘á»§ â†’ deploy cá»±c ká»³ dá»… dÃ ng.</li>
  <li>Dá»n dependency báº±ng <code>go mod tidy</code> Ä‘á»ƒ build sáº¡ch vÃ  nháº¹ hÆ¡n.</li>
</ul>

<hr />
<h1 id="18-generics-type-parameter-vÃ -constraint">18. Generics: Type Parameter vÃ  Constraint</h1>

<h2>ğŸ§  Tá»•ng quan vá» Generics trong Go</h2>
<ul>
  <li>Go há»— trá»£ generics tá»« báº£n <strong>1.18+</strong> thÃ´ng qua <strong>type parameter</strong>.</li>
  <li>Generics giÃºp báº¡n viáº¿t function, struct, method cÃ³ kháº£ nÄƒng tÃ¡i sá»­ dá»¥ng, nhÆ°ng váº«n giá»¯ <strong>type-safety</strong>.</li>
  <li>KhÃ´ng cÃ²n cáº§n Ã©p kiá»ƒu báº±ng interface trá»‘ng hay code láº·p cho tá»«ng kiá»ƒu.</li>
</ul>

<h2>ğŸ” Tá»•ng há»£p cÃ¡c loáº¡i Ã¡p dá»¥ng generics</h2>
<table>
<thead>
<tr><th>Loáº¡i</th><th>Ãp dá»¥ng</th><th>VÃ­ dá»¥</th></tr>
</thead>
<tbody>
<tr>
  <td><strong>Function</strong></td>
  <td>HÃ m dÃ¹ng chung cho nhiá»u kiá»ƒu</td>
  <td><code>func Equal[T comparable](a, b T)</code></td>
</tr>
<tr>
  <td><strong>Struct</strong></td>
  <td>Generic container, cache, stack...</td>
  <td><code>type Stack[T any]</code></td>
</tr>
<tr>
  <td><strong>Map</strong></td>
  <td>KhÃ´ng generic trá»±c tiáº¿p<br>nhÆ°ng cÃ³ thá»ƒ wrap qua struct</td>
  <td><code>type Store[K comparable, V any]</code></td>
</tr>
<tr>
  <td><strong>Slice</strong></td>
  <td>DÃ¹ng tá»‘t vá»›i hÃ m <code>Filter</code>, <code>Map</code>, <code>Reduce</code></td>
  <td><code>func Filter[T any](in []T, fn func(T) bool)</code></td>
</tr>
<tr>
  <td><strong>Interface</strong></td>
  <td>Gáº¯n constraint Ä‘á»ƒ enforce behavior</td>
  <td><code>type Adder[T any] interface { Add(T) T }</code></td>
</tr>
<tr>
  <td><strong>Function type</strong></td>
  <td>Generics Ã¡p dá»¥ng cho callback/higher order</td>
  <td><code>func Map[T any, R any](in []T, f func(T) R)</code></td>
</tr>
</tbody>
</table>

<h2>ğŸ“¦ VÃ­ dá»¥ tá»•ng há»£p Ã¡p dá»¥ng thá»±c táº¿</h2>

<pre><code class="go">// Generic function
func Max[T constraints.Ordered](a, b T) T {
    if a > b { return a }
    return b
}

// Generic struct
type Cache[K comparable, V any] struct {
    store map[K]V
}

// Generic slice operator
func Filter[T any](in []T, predicate func(T) bool) []T {
    var out []T
    for _, v := range in {
        if predicate(v) {
            out = append(out, v)
        }
    }
    return out
}
</code></pre>

<h2>ğŸ§  Vá» constraints</h2>
<ul>
  <li><code>any</code>: Ä‘áº¡i diá»‡n cho táº¥t cáº£ cÃ¡c kiá»ƒu</li>
  <li><code>comparable</code>: dÃ¹ng cho key map, so sÃ¡nh <code>==</code>, <code>!=</code></li>
  <li><code>constraints.Ordered</code>: dÃ¹ng cho kiá»ƒu cÃ³ thá»ƒ <code>&lt;, &gt;</code></li>
  <li>CÃ³ thá»ƒ Ä‘á»‹nh nghÄ©a <strong>interface constraint riÃªng</strong> náº¿u muá»‘n enforce method</li>
</ul>

<h2>ğŸ§  Æ¯u Ä‘iá»ƒm vÆ°á»£t trá»™i</h2>
<ul>
  <li>Loáº¡i bá» láº·p code cho má»—i kiá»ƒu</li>
  <li>Äáº£m báº£o type safety mÃ  khÃ´ng cáº§n interface{} + type assertion</li>
  <li>Gáº§n hÆ¡n vá»›i expressive pattern cá»§a functional programming</li>
</ul>

<h2>âš ï¸ Báº¥t lá»£i vÃ  giá»›i háº¡n hiá»‡n táº¡i</h2>
<ul>
  <li>KhÃ´ng cÃ³ runtime type inference hoáº·c reflection trÃªn T</li>
  <li>KhÃ´ng thá»ƒ dÃ¹ng toÃ¡n tá»­ tÃ¹y Ã½ (ngoÃ i constraint)</li>
  <li>Dá»… láº¡m dá»¥ng â†’ code khÃ³ Ä‘á»c, debug kÃ©m</li>
  <li>KhÃ´ng tÆ°Æ¡ng thÃ­ch tá»‘t vá»›i táº¥t cáº£ third-party lib</li>
</ul>

<h2>ğŸ“Œ Gá»£i Ã½ khi dÃ¹ng generics trong há»‡ thá»‘ng</h2>
<ul>
  <li>DÃ¹ng cho lib xá»­ lÃ½ collection: Pagination, Filter, Sorting...</li>
  <li>TrÃ¡nh dÃ¹ng generics trong API layer hoáº·c business logic Ä‘áº·c thÃ¹</li>
  <li>Viáº¿t constraint rÃµ rÃ ng Ä‘á»ƒ code dá»… Ä‘á»c, khÃ´ng Ä‘á»ƒ <code>[T any]</code> quÃ¡ rá»™ng</li>
  <li>DÃ¹ng generics káº¿t há»£p interface Ä‘á»ƒ enforce behavior rÃµ rÃ ng</li>
</ul>
<hr />
<h1 id="19-api--middleware-rest-grpc-interceptor">19. API & Middleware: REST, gRPC, Interceptor</h1>

<h2>ğŸ§  So sÃ¡nh HTTP vs gRPC</h2>
<table>
<thead>
<tr><th>TiÃªu chÃ­</th><th>HTTP REST</th><th>gRPC</th></tr>
</thead>
<tbody>
<tr><td>Protocol</td><td>HTTP/1.1, JSON</td><td>HTTP/2, Protocol Buffers</td></tr>
<tr><td>Contract</td><td>KhÃ´ng rÃ ng buá»™c (OpenAPI optional)</td><td>Strict contract qua .proto</td></tr>
<tr><td>Serialization</td><td>Text (JSON)</td><td>Binary (Protobuf) â€“ nhanh hÆ¡n</td></tr>
<tr><td>Streaming</td><td>KhÃ³ / chunked encoding</td><td>Built-in (client, server, bidi)</td></tr>
<tr><td>Tooling</td><td>Curl, Postman</td><td>grpcurl, Evans, protobuf compiler</td></tr>
<tr><td>Use case</td><td>Public API, Gateway, dá»… debug</td><td>Service internal, high perf</td></tr>
</tbody>
</table>

<h2>ğŸ§° CÃ¡c thÆ° viá»‡n phá»• biáº¿n</h2>
<ul>
  <li><code>net/http</code>: core lib, á»•n Ä‘á»‹nh, native middleware</li>
  <li><code>gin</code>: nhanh, cÃ³ middleware, bind JSON dá»…</li>
  <li><code>echo</code>: giá»‘ng gin, thÃªm nhiá»u tiá»‡n Ã­ch: group, context-rich</li>
  <li><code>grpc-go</code>: lib chÃ­nh thá»‘ng gRPC tá»« Google</li>
</ul>

<h2>ğŸ“¦ Middleware lÃ  gÃ¬?</h2>
<ul>
  <li>HÃ m bao ngoÃ i handler chÃ­nh â†’ xá»­ lÃ½ logic phá»¥: auth, log, recovery...</li>
  <li>DÃ¹ng chain Ä‘á»ƒ xÃ¢y dá»±ng pipeline xá»­ lÃ½ request.</li>
</ul>

<pre><code class="go">// Middleware trong gin
func AuthMiddleware(c *gin.Context) {
    token := c.GetHeader("Authorization")
    if token == "" {
        c.AbortWithStatus(401)
        return
    }
    c.Next()
}
</code></pre>

<h2>ğŸ”§ gRPC: cáº¥u trÃºc vÃ  generate code</h2>
<pre><code class="proto">syntax = "proto3";

package helloworld;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}
message HelloReply {
  string message = 1;
}
</code></pre>

<pre><code class="bash"># Generate Go code
protoc --go_out=. --go-grpc_out=. example.proto
</code></pre>

<h2>ğŸ’¬ Interceptor (gRPC middleware)</h2>
<ul>
  <li>Interceptor lÃ  middleware cho gRPC â€“ hoáº¡t Ä‘á»™ng trÆ°á»›c/sau RPC logic.</li>
  <li>Ãp dá»¥ng cho: logging, tracing, recovery, auth, inject header...</li>
  <li>Chia 2 loáº¡i: <code>UnaryInterceptor</code> vÃ  <code>StreamInterceptor</code></li>
</ul>

<pre><code class="go">func UnaryLogger(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (resp interface{}, err error) {
    log.Println("RPC:", info.FullMethod)
    return handler(ctx, req)
}
</code></pre>

<h2>ğŸ“¬ Header / Metadata truyá»n trong gRPC</h2>
<pre><code class="go">// Client gá»­i header
md := metadata.Pairs("x-trace-id", "abc123")
ctx := metadata.NewOutgoingContext(context.Background(), md)

// Server Ä‘á»c header
md, ok := metadata.FromIncomingContext(ctx)
traceID := md["x-trace-id"]
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li>REST phÃ¹ há»£p public API, dá»… debug.</li>
  <li>gRPC phÃ¹ há»£p ná»™i bá»™ â†’ high throughput, stream.</li>
  <li>DÃ¹ng interceptor Ä‘á»ƒ khÃ´ng viáº¿t láº¡i logging/auth/tracing á»Ÿ má»i handler.</li>
  <li>Header/metadata giÃºp trace qua nhiá»u service â€“ nháº¥t lÃ  trong há»‡ thá»‘ng microservice.</li>
</ul>
<h2>ğŸ§  CÃ¡c loáº¡i RPC trong gRPC</h2>
<ul>
  <li><strong>Unary RPC</strong>: 1 request â†’ 1 response (giá»‘ng HTTP truyá»n thá»‘ng)</li>
  <li><strong>Server Streaming</strong>: 1 request â†’ nhiá»u response (client Ä‘á»c liÃªn tá»¥c)</li>
  <li><strong>Client Streaming</strong>: nhiá»u request â†’ 1 response (client gá»­i liÃªn tá»¥c rá»“i server tráº£ káº¿t quáº£)</li>
  <li><strong>Bidirectional Streaming</strong>: nhiá»u request â†” nhiá»u response (giá»‘ng WebSocket)</li>
</ul>

<pre><code class="proto">service Chat {
  rpc SendMessage (Message) returns (Ack);               // Unary
  rpc StreamMessages (Room) returns (stream Message);    // Server Stream
  rpc UploadFile (stream Chunk) returns (UploadStatus);  // Client Stream
  rpc ChatStream (stream Message) returns (stream Message); // BiDi Stream
}
</code></pre>

<h2>ğŸ“¦ REST vs gRPC: Body vÃ  Serialization</h2>
<table>
<thead>
<tr><th>Aspect</th><th>REST (JSON)</th><th>gRPC (Protobuf)</th></tr>
</thead>
<tbody>
<tr><td>Request/Response</td><td>Body lÃ  JSON (text)</td><td>Binary protobuf</td></tr>
<tr><td>Size</td><td>Lá»›n hÆ¡n vÃ¬ nhiá»u kÃ½ tá»± vÃ  field name</td><td>Nhá» hÆ¡n nhá» encoding</td></tr>
<tr><td>Speed</td><td>Parse cháº­m hÆ¡n, dá»… debug</td><td>Parse nhanh hÆ¡n, khÃ³ debug báº±ng tay</td></tr>
<tr><td>Streaming</td><td>KhÃ³, cáº§n chunked/long polling</td><td>Built-in stream HTTP/2</td></tr>
</tbody>
</table>

<h2>ğŸ”— Giao tiáº¿p giá»¯a cÃ¡c service (microservice)</h2>
<ul>
  <li>gRPC Ä‘Æ°á»£c tá»‘i Æ°u Ä‘á»ƒ dÃ¹ng giá»¯a cÃ¡c service trong ná»™i bá»™:</li>
  <li>
    Æ¯u Ä‘iá»ƒm:
    <ul>
      <li>Strict schema (protoc)</li>
      <li>Compact binary â†’ tiáº¿t kiá»‡m bÄƒng thÃ´ng</li>
      <li>Bi-directional streaming: realtime vÃ  push data dá»… dÃ ng</li>
      <li>Code generation: client/server auto â†’ trÃ¡nh bug manual</li>
    </ul>
  </li>
  <li>
    CÃ¡c service gRPC cÃ³ thá»ƒ káº¿t ná»‘i nhau qua:
    <ul>
      <li>Static IP hoáº·c service discovery (Consul, Kubernetes DNS)</li>
      <li>gRPC-Gateway Ä‘á»ƒ expose HTTP â†’ gRPC hybrid</li>
      <li>Interconnect thÃ´ng qua Envoy Proxy hoáº·c gRPC LoadBalancer</li>
    </ul>
  </li>
</ul>

<h2>ğŸš€ Tá»‘i Æ°u hÃ³a gRPC trong há»‡ thá»‘ng</h2>
<ul>
  <li>Äá»‹nh nghÄ©a proto rÃµ rÃ ng, dÃ¹ng option Ä‘á»ƒ map HTTP náº¿u cáº§n gateway</li>
  <li>Truyá»n trace-id qua metadata Ä‘á»ƒ theo dÃµi request</li>
  <li>DÃ¹ng interceptor Ä‘á»ƒ chia nhá» concern (log, validate, panic recovery)</li>
  <li>Æ¯u tiÃªn bidirectional stream cho cÃ¡c use case realtime (chat, tracking...)</li>
</ul>
<hr />
<h1 id="20-error-wrapping-stacktrace-vÃ -structured-logging">20. Error Wrapping, Stacktrace, vÃ  Structured Logging</h1>

<h2>ğŸ§  Tá»•ng quan</h2>
<ul>
  <li>Go xá»­ lÃ½ lá»—i qua giÃ¡ trá»‹ kiá»ƒu <code>error</code> thay vÃ¬ throw/catch.</li>
  <li><strong>Error Wrapping</strong>: giÃºp giá»¯ láº¡i gá»‘c lá»—i khi truyá»n qua nhiá»u lá»›p.</li>
  <li><strong>Stacktrace</strong>: dÃ¹ng Ä‘á»ƒ trace ngÆ°á»£c nguá»“n gá»‘c lá»—i â†’ debug production.</li>
  <li><strong>Structured Logging</strong>: log cÃ³ field rÃµ rÃ ng (JSON/key-value) â†’ dá»… search, index, alert.</li>
</ul>

<h2>ğŸ” Error Wrapping (Go 1.13+)</h2>
<pre><code class="go">if err := doSomething(); err != nil {
    return fmt.Errorf("gá»i xá»­ lÃ½ tháº¥t báº¡i: %w", err)
}

if errors.Is(err, os.ErrNotExist) {
    // lá»—i cá»¥ thá»ƒ
}

var pathErr *os.PathError
if errors.As(err, &pathErr) {
    fmt.Println("Path lá»—i:", pathErr.Path)
}
</code></pre>

<h2>ğŸ“¦ Stacktrace (pkg/errors hoáº·c zap)</h2>
<pre><code class="go">err := errors.Wrap(err, "ngá»¯ cáº£nh thÃªm")
fmt.Printf("%+v\\n", err) // Ä‘áº§y Ä‘á»§ stack trace
</code></pre>

<h2>ğŸ’¡ Structured Logging (logrus, zap, zerolog)</h2>
<pre><code class="go">log.WithFields(log.Fields{
    "user_id": 42,
    "action":  "create_order",
}).Error("Xáº£y ra lá»—i")
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li>Always wrap error táº¡i biÃªn (usecase/service boundary)</li>
  <li>Structured log Ä‘á»ƒ theo dÃµi, alert qua ELK / Grafana</li>
  <li>ÄÃ­nh trace-id vÃ o log â†’ trace toÃ n hÃ nh trÃ¬nh request</li>
  <li>Middleware â†’ log panic, recover, status code, latency</li>
</ul>
<hr />
<h1 id="21-staticcheck-golangci-lint-go-vet-go-fmt">21. Staticcheck, GolangCI-Lint, go vet, go fmt</h1>

<h2>ğŸ§  Má»¥c tiÃªu</h2>
<ul>
  <li>PhÃ¡t hiá»‡n lá»—i tiá»m áº©n, anti-pattern, bug chÆ°a lá»™ báº±ng runtime.</li>
  <li>Chuáº©n hoÃ¡ style code, Ä‘áº£m báº£o tÃ­nh nháº¥t quÃ¡n trong team.</li>
</ul>

<h2>ğŸ” CÃ´ng cá»¥ phá»• biáº¿n</h2>
<table>
<thead><tr><th>CÃ´ng cá»¥</th><th>Chá»©c nÄƒng</th></tr></thead>
<tbody>
<tr><td><code>go fmt</code></td><td>Format láº¡i code theo chuáº©n Go</td></tr>
<tr><td><code>go vet</code></td><td>Báº¯t lá»—i logic (shadow, sai kiá»ƒu printf...)</td></tr>
<tr><td><code>staticcheck</code></td><td>PhÃ¢n tÃ­ch logic nÃ¢ng cao: unreachable, nil check...</td></tr>
<tr><td><code>golangci-lint</code></td><td>Cháº¡y nhiá»u linter cÃ¹ng lÃºc, tÃ­ch há»£p CI</td></tr>
</tbody>
</table>

<h2>ğŸ’¡ VÃ­ dá»¥ lá»—i</h2>
<pre><code class="go">fmt.Printf("%d", "abc") // sai kiá»ƒu â†’ vet

if x == nil || x == nil { } // check thá»«a â†’ staticcheck

unused := 123 // khÃ´ng dÃ¹ng â†’ unused
</code></pre>

<h2>âš™ Cáº¥u hÃ¬nh GolangCI-Lint</h2>
<pre><code class="yaml">linters:
  enable:
    - govet
    - errcheck
    - staticcheck
    - unused
run:
  timeout: 3m
  tests: true
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ Ã¡p dá»¥ng</h2>
<ul>
  <li>DÃ¹ng <code>go fmt</code> trong pre-commit hoáº·c CI</li>
  <li>TÃ­ch há»£p golangci-lint vÃ o GitHub Actions Ä‘á»ƒ check toÃ n bá»™ project</li>
  <li>DÃ¹ng <code>//nolint</code> Ä‘Ãºng má»¥c tiÃªu â€“ khÃ´ng suppress toÃ n file</li>
</ul>

<hr />
<h1 id="22-design-patterns-trong-go">22. Design Patterns trong Go</h1>

<h2>ğŸ§  Tá»•ng quan</h2>
<ul>
  <li>Go khÃ´ng Ã©p dÃ¹ng OOP â€“ nhiá»u pattern cá»• Ä‘iá»ƒn cáº§n viáº¿t láº¡i theo idiomatic Go.</li>
  <li>Go Æ°u tiÃªn composition, interface nháº¹ vÃ  function-first.</li>
</ul>

<h2>ğŸ“¦ CÃ¡c Pattern phá»• biáº¿n trong Go</h2>
<ul>
  <li><strong>Factory</strong>: sinh object theo config</li>
  <li><strong>Singleton</strong>: duy nháº¥t 1 instance global</li>
  <li><strong>Strategy</strong>: inject logic runtime</li>
  <li><strong>Builder</strong>: khá»Ÿi táº¡o cÃ³ cáº¥u hÃ¬nh theo bÆ°á»›c</li>
  <li><strong>Decorator</strong>: thÃªm behavior qua wrapper</li>
  <li><strong>Functional Option</strong>: idiomatic Go cho config linh hoáº¡t</li>
</ul>

<h2>ğŸ— Functional Option â€“ pattern Go Æ°u tiÃªn</h2>
<pre><code class="go">type Option func(*Server)

func WithTLS(enable bool) Option {
    return func(s *Server) {
        s.TLS = enable
    }
}
</code></pre>


<h2>ğŸ— Factory Pattern</h2>
<pre><code class="go">type DB interface { Connect() error }

type MySQL struct{}
func (MySQL) Connect() error { return nil }

func NewDB(engine string) DB {
    switch engine {
    case "mysql":
        return MySQL{}
    default:
        panic("unsupported")
    }
}
</code></pre>

<h2>ğŸ” Singleton Pattern</h2>
<pre><code class="go">var instance *Logger
var once sync.Once

func GetLogger() *Logger {
    once.Do(func() {
        instance = &Logger{}
    })
    return instance
}
</code></pre>

<h2>âš™ Strategy Pattern</h2>
<pre><code class="go">type Compressor interface {
    Compress(data string) string
}

type Gzip struct{}
func (Gzip) Compress(data string) string { return "GZIP:" + data }

func Run(c Compressor, data string) {
    fmt.Println(c.Compress(data))
}
</code></pre>

<h2>ğŸ›  Builder Pattern</h2>
<pre><code class="go">type UserBuilder struct {
    u User
}
func (b *UserBuilder) Name(name string) *UserBuilder {
    b.u.Name = name; return b
}
func (b *UserBuilder) Build() User { return b.u }
</code></pre>

<h2>ğŸ Decorator Pattern</h2>
<pre><code class="go">func LogWrap(fn func(string) string) func(string) string {
    return func(s string) string {
        fmt.Println("Start")
        res := fn(s)
        fmt.Println("Done")
        return res
    }
}
</code></pre>

<h2>ğŸ§© Functional Option Pattern</h2>
<pre><code class="go">type Server struct {
    Port int
}
type Option func(*Server)

func WithPort(p int) Option {
    return func(s *Server) { s.Port = p }
}
</code></pre>


<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Factory</strong>: khá»Ÿi táº¡o logger, db, gRPC client</li>
  <li><strong>Strategy</strong>: auth engine, retry logic</li>
  <li><strong>Functional Option</strong>: server config, middleware chain</li>
</ul>



<hr />
<h1 id="23-system-design-worker-pool-fan-inout-pipeline">23. System Design: Worker Pool, Fan-in/out, Pipeline</h1>

<h2>ğŸ§  Tá»•ng quan</h2>
<ul>
  <li>Go há»— trá»£ xá»­ lÃ½ song song qua goroutine vÃ  channel â†’ dá»… Ã¡p dá»¥ng cÃ¡c mÃ´ hÃ¬nh nhÆ° pipeline, fan-out, worker pool.</li>
</ul>

<h2>ğŸ” Fan-out Pattern</h2>
<pre><code class="go">jobs := make(chan int, 100)
for w := 1; w <= 3; w++ {
    go func(id int) {
        for j := range jobs {
            fmt.Println("Worker", id, "xá»­ lÃ½ job", j)
        }
    }(w)
}
for j := 1; j <= 5; j++ {
    jobs <- j
}
close(jobs)
</code></pre>

<h2>ğŸ”€ Fan-in Pattern</h2>
<pre><code class="go">func merge(cs ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    for _, c := range cs {
        wg.Add(1)
        go func(ch <-chan int) {
            defer wg.Done()
            for v := range ch {
                out <- v
            }
        }(c)
    }
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}
</code></pre>

<h2>ğŸ›  Worker Pool</h2>
<pre><code class="go">jobs := make(chan int, 10)
results := make(chan int, 10)

worker := func(jobs <-chan int, results chan<- int) {
    for j := range jobs {
        results <- j * 2
    }
}
for i := 0; i < 3; i++ {
    go worker(jobs, results)
}
for j := 1; j <= 5; j++ {
    jobs <- j
}
close(jobs)
for i := 0; i < 5; i++ {
    fmt.Println(<-results)
}
</code></pre>

<h2>ğŸ”— Pipeline Pattern</h2>
<pre><code class="go">func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng thá»±c táº¿</h2>
<ul>
  <li><strong>Fan-out</strong>: xá»­ lÃ½ song song nhiá»u file/API/data chunk</li>
  <li><strong>Fan-in</strong>: gom data tá»« nhiá»u nguá»“n vá» 1 xá»­ lÃ½</li>
  <li><strong>Worker Pool</strong>: giá»›i háº¡n tÃ i nguyÃªn há»‡ thá»‘ng</li>
  <li><strong>Pipeline</strong>: ETL, stream xá»­ lÃ½ log, event</li>
</ul>

<hr />
<h1 id="24-secure-coding-vÃ -cicd-workflow">24. Secure Coding vÃ  CI/CD Workflow</h1>

<h2>ğŸ§  Má»¥c tiÃªu báº£o máº­t</h2>
<ul>
  <li>Báº£o vá»‡ dá»¯ liá»‡u ngÆ°á»i dÃ¹ng vÃ  há»‡ thá»‘ng backend khá»i lá»—i báº£o máº­t, lá»™ thÃ´ng tin, config sai.</li>
</ul>

<h2>ğŸ” Best Practices</h2>
<ul>
  <li>Validate má»i input Ä‘áº§u vÃ o</li>
  <li>KhÃ´ng log token, password, internal error chi tiáº¿t</li>
  <li>DÃ¹ng <code>context.WithTimeout</code> vá»›i DB/API</li>
  <li>KhÃ´ng hardcode secret â€“ dÃ¹ng ENV hoáº·c secret vault</li>
</ul>

<h2>ğŸ›¡ï¸ Static Security Scan</h2>
<pre><code class="bash">gosec ./...    # phÃ¡t hiá»‡n eval, crypto yáº¿u, bind-all, hardcoded token...
</code></pre>

<h2>ğŸš€ CI/CD Workflow Best Practices</h2>
<ul>
  <li>TÃ­ch há»£p go fmt, lint, test, security scan</li>
  <li>KhÃ´ng log secret ra GitHub Actions</li>
  <li>DÃ¹ng docker multi-stage â†’ image gá»n</li>
</ul>

<h2>ğŸ“¦ CI Example (GitHub Actions)</h2>
<pre><code class="yaml">- run: go test -cover ./...
- run: golangci-lint run
- run: gosec ./...
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li>LuÃ´n cÃ³ timeout, trÃ¡nh DDoS báº±ng chá» vÃ´ háº¡n</li>
  <li>Scan code báº£o máº­t má»—i merge request</li>
  <li>Structured logging Ä‘á»ƒ trace behavior nguy hiá»ƒm</li>
</ul>

<hr />
<h1 id="25-distributed-systems-redis-kafka-envoyproxy">25. Distributed Systems: Redis, Kafka, EnvoyProxy</h1>

<h2>ğŸ§  Kiáº¿n trÃºc phÃ¢n tÃ¡n â€“ Redis / Kafka / Envoy</h2>
<ul>
  <li><strong>Redis</strong>: cache, pub/sub, distributed lock</li>
  <li><strong>Kafka</strong>: event queue, pub/sub async microservice</li>
  <li><strong>Envoy</strong>: service proxy, gRPC gateway, observability layer</li>
</ul>

<h2>ğŸš€ Redis</h2>
<pre><code>&lt;!-- Redis Caching Flow --&gt;
Client â†’ API â†’ Redis Cache?
           â†“ miss
         â†’ DB â†’ Cache â†’ Redis
         â† Result
</code></pre>

<pre><code class="go">rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})
val, err := rdb.Get(ctx, "user:1").Result()
if err == redis.Nil {
    // cache miss â†’ DB
}
</code></pre>

<h2>ğŸ“¨ Kafka</h2>
<pre><code>&lt;!-- Kafka Event Flow --&gt;
Producer â†’ Kafka topic: order.created
                       â†“
            Consumer A â†’ Email
            Consumer B â†’ Billing
</code></pre>

<pre><code class="go">r := kafka.NewReader(kafka.ReaderConfig{Topic: "order.created"})
for {
    m, _ := r.ReadMessage(ctx)
    fmt.Println(string(m.Value))
}
</code></pre>

<h2>ğŸŒ Envoy</h2>
<pre><code>&lt;!-- Envoy Service Flow --&gt;
Client â†’ Envoy Proxy â†’ gRPC Service
            â†‘ log, TLS, retry, metrics
</code></pre>

<pre><code class="yaml"># envoy.yaml
grpc_services:
  - google.api.http:
      post: "/v1/send"
      body: "*"
    selector: messaging.SendMessage
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Redis</strong>: tÄƒng throughput, TTL, lock job</li>
  <li><strong>Kafka</strong>: tÃ¡ch sync â†’ async, log store, broadcast</li>
  <li><strong>Envoy</strong>: observability, retry, circuit breaker</li>
</ul>
<h2>ğŸ§  Má»Ÿ rá»™ng: Chi tiáº¿t Redis / Kafka / EnvoyProxy</h2>

<h3>ğŸ”´ Redis â€“ Nhá»¯ng chá»©c nÄƒng máº¡nh máº½</h3>
<ul>
  <li><strong>GET / SET</strong>: lÆ°u dá»¯ liá»‡u dáº¡ng key-value cá»±c nhanh</li>
  <li><strong>TTL / EXPIRE</strong>: key tá»± xoÃ¡ sau má»™t thá»i gian</li>
  <li><strong>INCR / DECR</strong>: Ä‘áº¿m truy cáº­p, lÆ°á»£t vote</li>
  <li><strong>Pub/Sub</strong>: push real-time event (chat, notify)</li>
  <li><strong>ZSET</strong>: sort theo score â€“ dÃ¹ng cho ranking/leaderboard</li>
  <li><strong>Stream</strong>: giá»‘ng Kafka nháº¹, há»— trá»£ nhÃ³m, backlog</li>
  <li><strong>Distributed Lock</strong>: SETNX + EXPIRE giÃºp lock an toÃ n</li>
</ul>

<h3>ğŸ”¶ Kafka â€“ CÃ¡c thÃ nh pháº§n cá»‘t lÃµi</h3>
<ul>
  <li><strong>Topic</strong>: nÆ¡i cÃ¡c producer ghi vÃ  consumer Ä‘á»c</li>
  <li><strong>Partition</strong>: giÃºp scale, Ä‘áº£m báº£o thá»© tá»± trong partition</li>
  <li><strong>Consumer Group</strong>: chia táº£i â€“ má»—i partition â†’ 1 consumer trong group</li>
  <li><strong>Offset</strong>: vá»‹ trÃ­ message trong partition</li>
  <li><strong>Payload</strong>: ná»™i dung message, dáº¡ng []byte â†’ thÆ°á»ng lÃ  JSON, Protobuf</li>
  <li><strong>Retention</strong>: lÆ°u message nhiá»u giá»/ngÃ y Ä‘á»ƒ replay</li>
</ul>

<h3>ğŸ“Œ Kafka Patterns</h3>
<ul>
  <li><strong>Fan-out</strong>: 1 event â†’ nhiá»u service xá»­ lÃ½ song song</li>
  <li><strong>Retry Queue</strong>: gá»­i láº¡i náº¿u consumer fail</li>
  <li><strong>Compaction</strong>: chá»‰ giá»¯ báº£n má»›i nháº¥t theo key</li>
</ul>

<h3>ğŸ”µ Envoy â€“ Kháº£ nÄƒng máº¡nh</h3>
<ul>
  <li><strong>gRPC transcoding</strong>: REST â†’ gRPC â†’ handler</li>
  <li><strong>Per-route policy</strong>: config riÃªng tá»«ng endpoint</li>
  <li><strong>Rate limit</strong>: cháº·n láº¡m dá»¥ng theo header/client IP</li>
  <li><strong>Retry & Circuit breaker</strong>: Ä‘áº£m báº£o resiliency khi backend fail</li>
  <li><strong>RBAC / AuthZ</strong>: cháº·n/cho phÃ©p request theo role, path, header</li>
  <li><strong>Access log</strong>: JSON log cho má»i request</li>
  <li><strong>Tracing</strong>: tÃ­ch há»£p Zipkin/Jaeger</li>
</ul>


</main>
<div class="sidebar-image">
  <img src="Golang.png" alt="System Overview" />
</div>
  <script src="main.js"></script>
</body>
</html>
