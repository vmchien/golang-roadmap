
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Roadmap Golang</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <nav>
    
<h2>ğŸ§­ Má»¥c lá»¥c</h2>
<ul>
  <li><strong>Pháº§n I â€“ Basic</strong>
    <ul>
      <li><a href="#1-kiá»ƒu-dá»¯-liá»‡u-cÆ¡-báº£n-vÃ -khai-bÃ¡o-biáº¿n">1. Kiá»ƒu dá»¯ liá»‡u cÆ¡ báº£n vÃ  khai bÃ¡o biáº¿n</a></li>
      <li><a href="#2-cáº¥u-trÃºc-Ä‘iá»u-kiá»‡n-vÃ -vÃ²ng-láº·p">2. Cáº¥u trÃºc Ä‘iá»u kiá»‡n vÃ  vÃ²ng láº·p</a></li>
      <li><a href="#3-hÃ m-closure-vÃ -hÃ m-variadic">3. HÃ m, Closure, vÃ  HÃ m Variadic</a></li>
      <li><a href="#4-slice-map-array-vÃ -type-casting">4. Slice, Map, Array vÃ  Type Casting</a></li>
      <li><a href="#5-struct-method-vÃ -embedded-struct">5. Struct, Method, vÃ  Embedded Struct</a></li>
      <li><a href="#6-interface-vÃ -type-assertion">6. Interface vÃ  Type Assertion</a></li>
      <li><a href="#7-module-package-vÃ -go-mod">7. Module, Package vÃ  go mod</a></li>
    </ul>
  </li>
  <li><strong>Pháº§n II â€“ Advance</strong>
    <ul>
      <li><a href="#8-goroutine-vÃ -channel">8. Goroutine vÃ  Channel</a></li>
      <li><a href="#9-Ä‘á»“ng-bá»™-hoÃ¡-vá»›i-mutex-rwmutex-waitgroup">9. Äá»“ng bá»™ hoÃ¡ vá»›i Mutex, RWMutex, WaitGroup</a></li>
      <li><a href="#10-context-vÃ -lifecycle-control">10. Context vÃ  Lifecycle Control</a></li>
      <li><a href="#11-error-handling-vÃ -panicrecover">11. Error Handling vÃ  Panic/Recover</a></li>
      <li><a href="#12-logging-nÃ¢ng-cao-vá»›i-logrus-zap-zerolog">12. Logging nÃ¢ng cao vá»›i logrus, zap, zerolog</a></li>
      <li><a href="#13-testing-benchmark-table-driven-test">13. Testing, Benchmark, Table-Driven Test</a></li>
      <li><a href="#14-debugging-race-condition-deadlock">14. Debugging, Race Condition, Deadlock</a></li>
    </ul>
  </li>
  <li><strong>Pháº§n III â€“ System</strong>
    <ul>
      <li><a href="#15-memory-management--escape-analysis">15. Memory Management & Escape Analysis</a></li>
      <li><a href="#16-garbage-collection-vÃ -runtime-scheduler">16. Garbage Collection vÃ  Runtime Scheduler</a></li>
      <li><a href="#17-build-system-vÃ -cross-compilation">17. Build System vÃ  Cross Compilation</a></li>
      <li><a href="#18-generics-type-parameter-vÃ -constraint">18. Generics: Type Parameter vÃ  Constraint</a></li>
      <li><a href="#19-api--middleware-rest-grpc-interceptor">19. API & Middleware: REST, gRPC, Interceptor</a></li>
      <li><a href="#20-error-wrapping-stacktrace-vÃ -structured-logging">20. Error Wrapping, Stacktrace, vÃ  Structured Logging</a></li>
      <li><a href="#21-staticcheck-golangci-lint-go-vet-go-fmt">21. Staticcheck, GolangCI-Lint, go vet, go fmt</a></li>
      <li><a href="#22-design-patterns-trong-go">22. Design Patterns trong Go</a></li>
      <li><a href="#23-system-design-worker-pool-fan-inout-pipeline">23. System Design: Worker Pool, Fan-in/out, Pipeline</a></li>
      <li><a href="#24-secure-coding-vÃ -cicd-workflow">24. Secure Coding vÃ  CI/CD Workflow</a></li>
      <li><a href="#25-distributed-systems-redis-kafka-envoyproxy">25. Distributed Systems: Redis, Kafka, EnvoyProxy</a></li>
    </ul>
  </li>
  <li><strong>Pháº§n IV â€“ Go Mistakes</strong>
    <ul>
      <li><a href="#mistake-1-interface-vs-nil">Mistake #1 â€“ So sÃ¡nh interface vá»›i nil</a></li>
      <li><a href="#mistake-2-closure-trong-vÃ²ng-láº·p">Mistake #2 â€“ Closure trong vÃ²ng láº·p</a></li>
      <li><a href="#mistake-3-defer-trong-vÃ²ng-láº·p">Mistake #3 â€“ DÃ¹ng defer trong vÃ²ng láº·p</a></li>
      <li><a href="#mistake-4-truy-cáº­p-map-tá»«-nhiá»u-goroutine">Mistake #4 â€“ Truy cáº­p map tá»« nhiá»u goroutine</a></li>
      <li><a href="#mistake-5-goroutine-leak-khÃ´ng-listen-channel">Mistake #5 â€“ Goroutine leak vÃ¬ khÃ´ng listen channel</a></li>
      <li><a href="#mistake-6-truyá»n-slice-mÃ -tÆ°á»Ÿng-ráº±ng-copy">Mistake #6 â€“ Truyá»n slice mÃ  tÆ°á»Ÿng ráº±ng copy</a></li>
      <li><a href="#mistake-7-dÃ¹ng-value-receiver-khi-cáº§n-pointer">Mistake #7 â€“ DÃ¹ng value receiver khi cáº§n pointer</a></li>
      <li><a href="#mistake-8-context-khÃ´ng-bá»‹-cancel">Mistake #8 â€“ KhÃ´ng cancel context â†’ goroutine leak</a></li>
      <li><a href="#mistake-9-panic-khÃ´ng-Ä‘Æ°á»£c-recover">Mistake #9 â€“ Panic khÃ´ng Ä‘Æ°á»£c recover Ä‘Ãºng cÃ¡ch</a></li>
      <li><a href="#mistake-10-type-assertion-khÃ´ng-check-ok">Mistake #10 â€“ Type assertion khÃ´ng check ok</a></li>
      <li><a href="#mistake-11-slice-capacity-bá»‹-giá»¯-ngáº§m">Mistake #11 â€“ Slice giá»¯ capacity ngáº§m gÃ¢y memory leak</a></li>
      <li><a href="#mistake-12-ghi-map-áº©n-trong-json">Mistake #12 â€“ Map khi marshal JSON cÃ³ thá»© tá»± khÃ´ng xÃ¡c Ä‘á»‹nh</a></li>
      <li><a href="#mistake-13-defer-cÃ³-thá»©-tá»±-lifo">Mistake #13 â€“ Nháº§m láº«n thá»© tá»± thá»±c thi defer (LIFO)</a></li>
      <li><a href="#mistake-14-buffered-channel-váº«n-deadlock">Mistake #14 â€“ Buffered channel váº«n cÃ³ thá»ƒ gÃ¢y deadlock</a></li>
      <li><a href="#mistake-15-pointer-trÃªn-loop-variable">Mistake #15 â€“ Trá» tá»›i biáº¿n vÃ²ng láº·p â†’ táº¥t cáº£ trá» cÃ¹ng Ä‘á»‹a chá»‰</a></li>
      <li><a href="#mistake-16-lá»—i-fmtprintf-sai-kiá»ƒu">Mistake #16 â€“ fmt.Printf dÃ¹ng sai format type</a></li>
      <li><a href="#mistake-17-struct-tag-khÃ´ng-Ä‘Æ°á»£c-parser">Mistake #17 â€“ Struct tag bá»‹ lá»—i vÃ¬ khÃ´ng Ä‘Ãºng format</a></li>
      <li><a href="#mistake-18-sync-waitgroup-dÃ¹ng-thiáº¿u-done">Mistake #18 â€“ WaitGroup khÃ´ng gá»i Done â†’ block mÃ£i mÃ£i</a></li>
      <li><a href="#mistake-19-khÃ´ng-wrap-error-gá»‘c">Mistake #19 â€“ KhÃ´ng wrap error â†’ máº¥t ngá»¯ cáº£nh khi debug</a></li>
      <li><a href="#mistake-20-shadow-biáº¿n-lÃ m-hiá»ƒu-nháº§m-logic">Mistake #20 â€“ Biáº¿n bá»‹ shadow trong block â†’ bug khÃ³ phÃ¡t hiá»‡n</a></li>
    </ul>
  </li>
  
</ul>

  </nav>
  <main>
    <h1 id="1-kiá»ƒu-dá»¯-liá»‡u-cÆ¡-báº£n-vÃ -khai-bÃ¡o-biáº¿n">1. Kiá»ƒu dá»¯ liá»‡u cÆ¡ báº£n vÃ  khai bÃ¡o biáº¿n</h1>

<hr />



<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>

<p>Trong Golang, viá»‡c hiá»ƒu rÃµ <strong>kiá»ƒu dá»¯ liá»‡u</strong> vÃ  <strong>cÃ¡ch khai bÃ¡o biáº¿n</strong> lÃ  bÆ°á»›c ná»n táº£ng khÃ´ng thá»ƒ thiáº¿u. Tá»« viá»‡c xÃ¡c Ä‘á»‹nh giÃ¡ trá»‹ cá»¥ thá»ƒ Ä‘Æ°á»£c lÆ°u trá»¯ á»Ÿ Ä‘Ã¢u trong bá»™ nhá»› (stack vs heap), Ä‘áº¿n cÃ¡ch Go runtime tá»‘i Æ°u hÃ³a truy cáº­p, má»i thá»© Ä‘á»u báº¯t Ä‘áº§u tá»« Ä‘Ã¢y.</p>

<p>NgÃ´n ngá»¯ Go cÃ³ cÃ¡c nhÃ³m dá»¯ liá»‡u chÃ­nh:</p>

<ul>
<li><p><strong>Sá»‘ nguyÃªn (Integer)</strong>:<br />
<code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> vÃ  cÃ¡c biáº¿n thá»ƒ khÃ´ng dáº¥u nhÆ° <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></p></li>
<li><p><strong>Sá»‘ thá»±c (Floating Point)</strong>:<br />
<code>float32</code>, <code>float64</code></p></li>
<li><p><strong>Boolean</strong>:<br />
<code>true</code>, <code>false</code></p></li>
<li><p><strong>Chuá»—i (String)</strong>:<br />
Kiá»ƒu dá»¯ liá»‡u UTF-8 báº¥t biáº¿n</p></li>
<li><p><strong>KÃ½ tá»± Ä‘áº·c biá»‡t</strong>:<br />
<code>byte</code> (alias cá»§a <code>uint8</code>), <code>rune</code> (alias cá»§a <code>int32</code>, Ä‘áº¡i diá»‡n cho Unicode code point)</p></li>
<li><p><strong>Cáº¥u trÃºc dá»¯ liá»‡u tÄ©nh/Ä‘á»™ng</strong>:<br />
<code>array</code>, <code>slice</code></p></li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>

<ul>
<li><code>int</code> lÃ  kiá»ƒu phá»¥ thuá»™c kiáº¿n trÃºc mÃ¡y (32-bit hoáº·c 64-bit). DÃ¹ng máº·c Ä‘á»‹nh nhÆ°ng <strong>nÃªn rÃµ rÃ ng khi cáº§n tÃ­nh toÃ¡n chÃ­nh xÃ¡c kÃ­ch thÆ°á»›c bá»™ nhá»›</strong>.</li>
<li><code>string</code> trong Go lÃ  immutable â€” má»i thao tÃ¡c nhÆ° cáº¯t, ná»‘i chuá»—i Ä‘á»u táº¡o báº£n sao má»›i.</li>
<li><code>rune</code> Ä‘áº¡i diá»‡n 1 kÃ½ tá»± Unicode, dÃ¹ng Ä‘á»ƒ xá»­ lÃ½ kÃ½ tá»± Ä‘a byte nhÆ° tiáº¿ng Viá»‡t, emoji.</li>
<li><code>slice</code> khÃ´ng pháº£i lÃ  máº£ng. NÃ³ lÃ  má»™t â€œviewâ€ gá»“m: pointer tá»›i underlying array, Ä‘á»™ dÃ i vÃ  capacity. Ráº¥t nháº¹, dá»… truyá»n qua hÃ m mÃ  khÃ´ng copy dá»¯ liá»‡u.</li>
<li><code>const</code> Ä‘Æ°á»£c xá»­ lÃ½ á»Ÿ thá»i Ä‘iá»ƒm compile. GiÃ¡ trá»‹ <code>const</code> khÃ´ng chiáº¿m vÃ¹ng nhá»› runtime.</li>
</ul>

<hr />

<h2>ğŸ’¡ VÃ­ dá»¥: CÃ¡c kiá»ƒu dá»¯ liá»‡u</h2>

<div class="codehilite">
<pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">age</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">30</span><span class="w">              </span><span class="c1">// biáº¿n kiá»ƒu sá»‘ nguyÃªn, 32 hoáº·c 64-bit tÃ¹y OS</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">Pi</span><span class="w"> </span><span class="kt">float64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">3.1415</span><span class="w">     </span><span class="c1">// háº±ng sá»‘ kiá»ƒu sá»‘ thá»±c (float64)</span>
<span class="w">    </span><span class="nx">isAdmin</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kc">true</span><span class="w">               </span><span class="c1">// boolean vá»›i short declaration :=</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">letter</span><span class="w"> </span><span class="kt">rune</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sc">&#39;ğ”Š&#39;</span><span class="w">         </span><span class="c1">// kÃ½ tá»± Unicode (rune = int32)</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="kt">byte</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="w">           </span><span class="c1">// byte lÃ  alias cá»§a uint8</span>

<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Gopher&quot;</span><span class="w">    </span><span class="c1">// chuá»—i UTF-8, immutable</span>

<span class="w">    </span><span class="nx">nums</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">        </span><span class="c1">// slice Ä‘á»™ng chá»©a int</span>
<span class="w">    </span><span class="nx">arr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">        </span><span class="c1">// array tÄ©nh vá»›i Ä‘á»™ dÃ i cá»‘ Ä‘á»‹nh</span>

<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Age:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Pi:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">Pi</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Admin:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">isAdmin</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Letter:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">string</span><span class="p">(</span><span class="nx">letter</span><span class="p">))</span><span class="w"> </span><span class="c1">// chuyá»ƒn rune thÃ nh chuá»—i</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Byte:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Name:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Slice:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">nums</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Array:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<hr />


<h2>ğŸ“Š Báº£ng giÃ¡ trá»‹ (Range) cÃ¡c kiá»ƒu dá»¯ liá»‡u phá»• biáº¿n</h2>

<table>
<thead>
<tr>
  <th>Kiá»ƒu dá»¯ liá»‡u</th>
  <th>Bit</th>
  <th>Min GiÃ¡ trá»‹</th>
  <th>Max GiÃ¡ trá»‹</th>
</tr>
</thead>
<tbody>
<tr>
  <td>int8</td>
  <td>8</td>
  <td>-128</td>
  <td>127</td>
</tr>
<tr>
  <td>uint8 (byte)</td>
  <td>8</td>
  <td>0</td>
  <td>255</td>
</tr>
<tr>
  <td>int16</td>
  <td>16</td>
  <td>-32,768</td>
  <td>32,767</td>
</tr>
<tr>
  <td>uint16</td>
  <td>16</td>
  <td>0</td>
  <td>65,535</td>
</tr>
<tr>
  <td>int32 (rune)</td>
  <td>32</td>
  <td>-2,147,483,648</td>
  <td>2,147,483,647</td>
</tr>
<tr>
  <td>uint32</td>
  <td>32</td>
  <td>0</td>
  <td>4,294,967,295</td>
</tr>
<tr>
  <td>int64</td>
  <td>64</td>
  <td>-9,223,372,036,854,775,808</td>
  <td>9,223,372,036,854,775,807</td>
</tr>
<tr>
  <td>uint64</td>
  <td>64</td>
  <td>0</td>
  <td>18,446,744,073,709,551,615</td>
</tr>
<tr>
  <td>float32</td>
  <td>32</td>
  <td>â‰ˆ -3.4e38</td>
  <td>â‰ˆ +3.4e38</td>
</tr>
<tr>
  <td>float64</td>
  <td>64</td>
  <td>â‰ˆ -1.8e308</td>
  <td>â‰ˆ +1.8e308</td>
</tr>
<tr>
  <td>bool</td>
  <td>1</td>
  <td>false</td>
  <td>true</td>
</tr>
</tbody>
</table>


<h2>ğŸ“Œ Ã nghÄ©a há»‡ thá»‘ng</h2>

<p>Viá»‡c náº¯m rÃµ cÃ¡c kiá»ƒu dá»¯ liá»‡u khÃ´ng chá»‰ giÃºp báº¡n trÃ¡nh lá»—i type mismatch, mÃ  cÃ²n:
- Tá»‘i Æ°u hiá»‡u suáº¥t xá»­ lÃ½ vÃ  quáº£n lÃ½ bá»™ nhá»›
- TrÃ¡nh bug liÃªn quan Ä‘áº¿n Unicode/string slicing
- Viáº¿t API rÃµ rÃ ng, khÃ´ng ambiguous vá»›i kiá»ƒu dá»¯ liá»‡u cá»¥ thá»ƒ (<code>[]byte</code>, <code>string</code>, <code>rune</code>)
- PhÃ¢n biá»‡t khi truyá»n dá»¯ liá»‡u qua hÃ m: array (copy toÃ n bá»™) vs slice (chia sáº» vÃ¹ng nhá»›)</p>


<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Sá»± khÃ¡c nhau giá»¯a <code>array</code> vÃ  <code>slice</code> trong Go lÃ  gÃ¬?
    <pre><code><strong>array</strong>: cÃ³ Ä‘á»™ dÃ i cá»‘ Ä‘á»‹nh, lÃ  giÃ¡ trá»‹ (value type), khi truyá»n vÃ o hÃ m sáº½ Ä‘Æ°á»£c copy.
<strong>slice</strong>: lÃ  cáº¥u trÃºc Ä‘á»™ng gá»“m con trá», Ä‘á»™ dÃ i vÃ  capacity â€“ khi truyá»n vÃ o lÃ  tham chiáº¿u Ä‘áº¿n máº£ng gá»‘c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>rune</code> vÃ  <code>byte</code> khÃ¡c nhau nhÆ° tháº¿ nÃ o?
    <pre><code><strong>byte</strong> lÃ  alias cá»§a uint8, dÃ¹ng cho dá»¯ liá»‡u nhá»‹ phÃ¢n/ASCII.
<strong>rune</strong> lÃ  alias cá»§a int32, Ä‘áº¡i diá»‡n kÃ½ tá»± Unicode â€“ dÃ¹ng cho xá»­ lÃ½ tiáº¿ng Viá»‡t, emoji.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>const</code> khÃ¡c gÃ¬ vá»›i <code>var</code>?
    <pre><code><strong>const</strong>: háº±ng sá»‘, Ä‘Æ°á»£c tÃ­nh á»Ÿ compile-time, khÃ´ng chiáº¿m bá»™ nhá»› runtime.
<strong>var</strong>: lÃ  biáº¿n â€“ cÃ³ thá»ƒ thay Ä‘á»•i trong runtime.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng <code>float64</code> Ä‘á»ƒ lÆ°u tiá»n khÃ´ng?
    <pre><code>KhÃ´ng nÃªn â€“ vÃ¬ float dá»… gÃ¢y lá»—i lÃ m trÃ²n. HÃ£y dÃ¹ng kiá»ƒu sá»‘ nguyÃªn hoáº·c thÆ° viá»‡n nhÆ° <code>shopspring/decimal</code>.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng <code>:=</code> vÃ  khi nÃ o dÃ¹ng <code>var</code>?
    <pre><code><strong>:=</strong>: dÃ¹ng nhanh trong hÃ m, khi khÃ´ng cáº§n khai bÃ¡o rÃµ kiá»ƒu.
<strong>var</strong>: nÃªn dÃ¹ng á»Ÿ ngoÃ i hÃ m, export, hoáº·c khi cáº§n kiá»ƒu cá»¥ thá»ƒ / zero value chÃ­nh xÃ¡c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>string</code> trong Go cÃ³ mutable khÃ´ng?
    <pre><code>KhÃ´ng. String trong Go lÃ  immutable â€“ má»i thay Ä‘á»•i táº¡o chuá»—i má»›i â†’ áº£nh hÆ°á»Ÿng hiá»‡u suáº¥t náº¿u xá»­ lÃ½ nhiá»u.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> VÃ¬ sao <code>slice</code> Ä‘Æ°á»£c dÃ¹ng nhiá»u thay vÃ¬ array?
    <pre><code>Slice linh hoáº¡t, nháº¹, truyá»n qua hÃ m khÃ´ng copy dá»¯ liá»‡u â€“ Ä‘á»“ng thá»i cÃ³ thá»ƒ má»Ÿ rá»™ng, cáº¯t, clone dá»… dÃ ng.</code></pre>
  </li>
</ul>





  
<hr />
<h1 id="2-cáº¥u-trÃºc-Ä‘iá»u-kiá»‡n-vÃ -vÃ²ng-láº·p">2. Cáº¥u trÃºc Ä‘iá»u kiá»‡n vÃ  vÃ²ng láº·p</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<p>Golang cung cáº¥p ba cáº¥u trÃºc Ä‘iá»u khiá»ƒn cÆ¡ báº£n:</p>
<ul>
  <li><strong>if / else if / else</strong>: kiá»ƒm tra Ä‘iá»u kiá»‡n logic</li>
  <li><strong>switch</strong>: thay tháº¿ cho nhiá»u if lá»“ng nhau, há»— trá»£ fallthrough</li>
  <li><strong>for</strong>: vÃ²ng láº·p duy nháº¥t trong Go, dÃ¹ng Ä‘Æ°á»£c cho loop, while, foreach</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li><code>if</code> trong Go khÃ´ng cáº§n dáº¥u ngoáº·c trÃ²n quanh Ä‘iá»u kiá»‡n (nhÆ° trong C).</li>
  <li><code>switch</code> trong Go khÃ´ng cáº§n <code>break</code>; nÃ³ tá»± Ä‘á»™ng khÃ´ng fallthrough, trá»« khi Ä‘Æ°á»£c khai bÃ¡o rÃµ rÃ ng.</li>
  <li><code>for</code> cÃ³ thá»ƒ hoáº¡t Ä‘á»™ng nhÆ°:
    <ul>
      <li>vÃ²ng láº·p chuáº©n: <code>for i := 0; i &lt; n; i++</code></li>
      <li>vÃ²ng láº·p while: <code>for cond</code></li>
      <li>vÃ²ng láº·p vÃ´ háº¡n: <code>for &#123;&#125;</code></li>
      <li>range loop: <code>for i, v := range collection</code></li>
    </ul>
  </li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ code: if, switch, for</h2>

<pre><code class="go">// Cáº¥u trÃºc Ä‘iá»u kiá»‡n vá»›i if/else
x := 5
if x > 10 {
    fmt.Println("Lá»›n hÆ¡n 10")
} else if x == 5 {
    fmt.Println("Báº±ng 5")
} else {
    fmt.Println("KhÃ¡c")
}

// switch cÆ¡ báº£n khÃ´ng cáº§n break
switch x {
case 1:
    fmt.Println("One")
case 5:
    fmt.Println("Five") // Ä‘Ãºng
default:
    fmt.Println("Other")
}

// for chuáº©n
for i := 0; i < 3; i++ {
    fmt.Println(i)
}

// for nhÆ° while
i := 0
for i < 3 {
    fmt.Println(i)
    i++
}

// for vÃ´ háº¡n
// for {
//     fmt.Println("Cháº¡y mÃ£i mÃ£i")
// }

// range trÃªn slice
nums := []int{1, 2, 3}
for idx, val := range nums {
    fmt.Println("index:", idx, "value:", val)
}
</code></pre>

<h2>ğŸ“Œ Ã nghÄ©a há»‡ thá»‘ng</h2>
<ul>
  <li>Viá»‡c sá»­ dá»¥ng Ä‘Ãºng cáº¥u trÃºc Ä‘iá»u khiá»ƒn giÃºp mÃ£ rÃµ rÃ ng, dá»… Ä‘á»c.</li>
  <li>Go khuyáº¿n khÃ­ch viáº¿t code Ä‘Æ¡n giáº£n: <code>switch</code> thay vÃ¬ nhiá»u <code>if</code> lá»“ng nhau.</li>
  <li><code>range</code> ráº¥t máº¡nh vá»›i slice, map, channel â€” há»— trá»£ clean code khi láº·p.</li>
</ul>
<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Go khÃ´ng cÃ³ <code>while</code> hay <code>do-while</code> vÃ¬ sao?
    <pre><code>Triáº¿t lÃ½ ngÃ´n ngá»¯: Ä‘Æ¡n giáº£n. <code>for</code> Ä‘á»§ dÃ¹ng cho táº¥t cáº£ â€“ giÃºp code ngáº¯n, trÃ¡nh lá»—i logic láº·p.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> DÃ¹ng <code>range</code> vá»›i <code>slice</code> cÃ³ rá»§i ro gÃ¬?
    <pre><code>Pháº§n tá»­ láº¥y ra lÃ  báº£n sao â€“ náº¿u láº¥y Ä‘á»‹a chá»‰ (&v), táº¥t cáº£ trá» cÃ¹ng 1 vÃ¹ng nhá»› â†’ bug khi dÃ¹ng trong loop pointer.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>range map</code> cÃ³ thá»© tá»± khÃ´ng?
    <pre><code>KhÃ´ng. Tá»« Go 1.12+, range map Ä‘Æ°á»£c xÃ¡o trá»™n ngáº«u nhiÃªn Ä‘á»ƒ trÃ¡nh viá»‡c phá»¥ thuá»™c vÃ o thá»© tá»±.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o dÃ¹ng <code>switch</code> thay vÃ¬ <code>if</code>?
    <pre><code>Khi cÃ³ nhiá»u nhÃ¡nh kiá»ƒm tra giÃ¡ trá»‹ cá»¥ thá»ƒ. <code>switch</code> rÃµ rÃ ng, ngáº¯n gá»n, khÃ´ng cáº§n break, há»— trá»£ fallthrough.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡ch viáº¿t vÃ²ng láº·p vÃ´ háº¡n an toÃ n trong Go?
    <pre><code>Viáº¿t <code>for {}</code>, káº¿t há»£p vá»›i <code>select</code> + <code>ctx.Done()</code> Ä‘á»ƒ cho phÃ©p graceful shutdown.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng <code>for i := 0; i &lt; len(slice); i++</code> thay <code>range</code>?
    <pre><code>CÃ³ â€“ náº¿u muá»‘n truy cáº­p vÃ  thay Ä‘á»•i chÃ­nh xÃ¡c pháº§n tá»­ gá»‘c.
<code>range</code> copy giÃ¡ trá»‹ nÃªn khÃ´ng thay Ä‘á»•i Ä‘Æ°á»£c gá»‘c vá»›i kiá»ƒu khÃ´ng pháº£i con trá».</code></pre>
  </li>
</ul>


<hr />
<h1 id="3-hÃ m-closure-vÃ -hÃ m-variadic">3. HÃ m, Closure vÃ  HÃ m Variadic</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>HÃ m (function)</strong> trong Go lÃ  <em>first-class citizen</em>: cÃ³ thá»ƒ gÃ¡n vÃ o biáº¿n, truyá»n lÃ m tham sá»‘, hoáº·c tráº£ vá» tá»« hÃ m.</li>
  <li><strong>Closure</strong>: hÃ m bÃªn trong cÃ³ thá»ƒ "báº¯t" vÃ  ghi nhá»› giÃ¡ trá»‹ tá»« scope bÃªn ngoÃ i.</li>
  <li><strong>Variadic function</strong>: hÃ m nháº­n sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ Ä‘á»™ng, biá»ƒu diá»…n báº±ng <code>...</code> vÃ  hoáº¡t Ä‘á»™ng nhÆ° slice trong runtime.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Closure cÃ³ thá»ƒ lÃ m biáº¿n escape sang heap náº¿u giá»¯ tham chiáº¿u ra ngoÃ i vÃ²ng Ä‘á»i ban Ä‘áº§u.</li>
  <li>Truyá»n hÃ m nhÆ° parameter cho phÃ©p tÃ¡ch biá»‡t logic vÃ  tuÃ¢n thá»§ nguyÃªn táº¯c SOLID.</li>
  <li>Variadic function báº£n cháº¥t lÃ  nháº­n má»™t slice â€” ráº¥t phá»• biáº¿n trong logging, middleware, builder pattern.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ code nÃ¢ng cao</h2>
<pre><code class="go">// HÃ m nhÆ° biáº¿n
hello := func(name string) string {
    return "Hello " + name
}
fmt.Println(hello("Gopher"))

// HÃ m nháº­n hÃ m khÃ¡c lÃ m tham sá»‘
func execute(fn func(string) string) {
    fmt.Println(fn("Golang"))
}
execute(hello) // truyá»n hÃ m

// Closure ghi nhá»› giÃ¡ trá»‹ bÃªn ngoÃ i
func counter() func() int {
    x := 0
    return func() int {
        x++
        return x
    }
}
c := counter()
fmt.Println(c()) // 1
fmt.Println(c()) // 2

// HÃ m tráº£ vá» hÃ m: factory pattern
func prefixer(prefix string) func(string) string {
    return func(s string) string {
        return prefix + s
    }
}
addGo := prefixer("Go-")
fmt.Println(addGo("Lang")) // Go-Lang

// Variadic function
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}
fmt.Println(sum(1, 2, 3)) // 6

// Truyá»n slice vÃ o hÃ m variadic
nums := []int{10, 20, 30}
fmt.Println(sum(nums...)) // cáº§n dáº¥u ...
</code></pre>

<h2>ğŸ“Œ GÃ³c nhÃ¬n há»‡ thá»‘ng & tá»‘i Æ°u</h2>
<ul>
  <li>HÃ m nhÆ° tham sá»‘ lÃ  ná»n táº£ng cá»§a pattern functional (e.g., handler chain, config builder).</li>
  <li>Closure cÃ³ thá»ƒ giÃºp "Ä‘Ã³ng gÃ³i logic + tráº¡ng thÃ¡i" giá»‘ng object â€” nhÆ°ng cáº§n quáº£n lÃ½ heap allocation.</li>
  <li>Go khÃ´ng há»— trá»£ default parameter â€” variadic function káº¿t há»£p vá»›i pattern giÃºp láº¥p chá»— trá»‘ng nÃ y.</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Go cÃ³ há»— trá»£ <code>function as first-class citizen</code> khÃ´ng?
    <pre><code>CÃ³. HÃ m trong Go cÃ³ thá»ƒ gÃ¡n vÃ o biáº¿n, truyá»n vÃ o hÃ m khÃ¡c, tráº£ vá» tá»« hÃ m â†’ há»— trá»£ láº­p trÃ¬nh hÃ m (functional).</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Closure lÃ  gÃ¬? Khi nÃ o biáº¿n trong closure escape lÃªn heap?
    <pre><code>Closure lÃ  hÃ m "nhá»›" Ä‘Æ°á»£c giÃ¡ trá»‹ biáº¿n ngoÃ i scope. Náº¿u closure giá»¯ biáº¿n sau khi hÃ m cha káº¿t thÃºc â†’ biáº¿n Ä‘Ã³ sáº½ escape lÃªn heap.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ khai bÃ¡o hÃ m bÃªn trong hÃ m khÃ´ng? Khi nÃ o nÃªn dÃ¹ng?
    <pre><code>CÃ³. ThÆ°á»ng dÃ¹ng Ä‘á»ƒ Ä‘Ã³ng gÃ³i logic phá»¥ chá»‰ phá»¥c vá»¥ hÃ m chÃ­nh, giÃºp tÃ¡ch biá»‡t vÃ  rÃµ rÃ ng.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Æ¯u nhÆ°á»£c Ä‘iá»ƒm cá»§a <code>variadic function</code> trong Go?
    <pre><code>Æ¯u: truyá»n sá»‘ lÆ°á»£ng Ä‘á»‘i sá»‘ linh hoáº¡t, dÃ¹ng nhÆ° slice.
NhÆ°á»£c: khÃ³ enforce type cho tá»«ng pháº§n tá»­, dá»… gÃ¢y lá»—i khi truyá»n nháº§m kiá»ƒu.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ truyá»n <code>slice</code> vÃ o hÃ m variadic khÃ´ng?
    <pre><code>CÃ³. Pháº£i thÃªm <code>...</code> sau slice Ä‘á»ƒ "giáº£i nÃ©n" cÃ¡c pháº§n tá»­ â†’ <code>sum(nums...)</code></code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> HÃ m tráº£ vá» hÃ m cÃ³ á»©ng dá»¥ng gÃ¬ trong thá»±c táº¿?
    <pre><code>DÃ¹ng Ä‘á»ƒ táº¡o factory, builder, middleware, hoáº·c gáº¯n logic theo context (e.g: prefixer, logWithLevel...)</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh <code>defer</code> vs <code>return</code> trong hÃ m â†’ thá»© tá»± thá»±c thi?
    <pre><code><code>defer</code> luÃ´n cháº¡y sau khi <code>return</code> Ä‘Æ°á»£c chuáº©n bá»‹ nhÆ°ng trÆ°á»›c khi rá»i khá»i hÃ m.
Náº¿u cÃ³ multiple <code>defer</code> â†’ thá»© tá»± cháº¡y LIFO (stack).</code></pre>
  </li>
</ul>


<hr />
<h1 id="4-slice-map-array-vÃ -type-casting">4. Slice, Map, Array vÃ  Type Casting</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m vÃ  khÃ¡c biá»‡t</h2>
<ul>
  <li><strong>Array</strong>: KÃ­ch thÆ°á»›c cá»‘ Ä‘á»‹nh, lÃ  giÃ¡ trá»‹, khi gÃ¡n lÃ  <code>copy</code>.</li>
  <li><strong>Slice</strong>: Trá» vÃ o underlying array, cÃ³ <code>pointer + len + cap</code>, khi gÃ¡n lÃ  <code>reference</code>.</li>
  <li><strong>Map</strong>: Reference type, Ã¡nh xáº¡ key-value.</li>
  <li><strong>Type Casting</strong>: Ã‰p kiá»ƒu tÆ°á»ng minh, khÃ´ng cÃ³ implicit conversion nhÆ° C/C++.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch nÃ¢ng cao</h2>
<ul>
  <li><code>slice1 := slice2</code> â†’ cáº£ 2 cÃ¹ng trá» 1 underlying array.</li>
  <li><code>copy(slice2, slice1)</code> Ä‘á»ƒ clone slice.</li>
  <li><code>map</code> khÃ´ng cáº§n init vá»›i <code>make</code> sáº½ panic khi gÃ¡n.</li>
  <li>KhÃ´ng thá»ƒ Ã©p kiá»ƒu <code>float64 â†’ int</code> ngáº§m â€” cáº§n <code>int(f)</code>.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥</h2>
<pre><code class="go">arr := [3]int{1, 2, 3}
arr2 := arr
arr2[0] = 99 // arr[0] khÃ´ng Ä‘á»•i

slice := []int{1, 2, 3}
s2 := slice
s2[0] = 88 // áº£nh hÆ°á»Ÿng slice gá»‘c

clone := make([]int, len(slice))
copy(clone, slice) // Ä‘Ãºng cÃ¡ch clone slice

m := make(map[string]int)
m["x"] = 100

var f float64 = 3.99
i := int(f) // Ã©p kiá»ƒu rÃµ rÃ ng
</code></pre>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Sá»± khÃ¡c biá»‡t giá»¯a <code>slice</code> vÃ  <code>array</code> lÃ  gÃ¬?
    <pre><code><strong>Slice</strong>: lÃ  reference type, gá»“m pointer + len + cap,
trá» vÃ o underlying array, thay Ä‘á»•i pháº§n tá»­ sáº½ áº£nh hÆ°á»Ÿng dá»¯ liá»‡u gá»‘c.

<strong>Array</strong>: lÃ  value type, khi gÃ¡n hoáº·c truyá»n vÃ o hÃ m sáº½ bá»‹ copy toÃ n bá»™.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Táº¡i sao <code>map</code> cáº§n dÃ¹ng <code>make()</code> trÆ°á»›c khi gÃ¡n?
    <pre><code>VÃ¬ <code>map</code> lÃ  reference type chÆ°a Ä‘Æ°á»£c khá»Ÿi táº¡o,
náº¿u chÆ°a dÃ¹ng <code>make()</code> thÃ¬ viá»‡c gÃ¡n pháº§n tá»­ sáº½ gÃ¢y panic.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> GÃ¡n <code>slice1 := slice2</code> cÃ³ pháº£i copy dá»¯ liá»‡u khÃ´ng?
    <pre><code>KhÃ´ng â€“ chá»‰ copy struct slice (pointer + len + cap).

Cáº£ hai biáº¿n váº«n trá» Ä‘áº¿n cÃ¹ng 1 underlying array â†’ thay Ä‘á»•i dá»¯ liá»‡u sáº½ áº£nh hÆ°á»Ÿng láº«n nhau.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao Ä‘á»ƒ clone slice mÃ  khÃ´ng áº£nh hÆ°á»Ÿng slice gá»‘c?
    <pre><code>DÃ¹ng <code>copy()</code>:
clone := make([]int, len(src))
copy(clone, src)</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ Ã©p kiá»ƒu ngáº§m trong Go khÃ´ng?
    <pre><code>KhÃ´ng â€“ Go yÃªu cáº§u explicit casting.

Pháº£i Ã©p kiá»ƒu rÃµ rÃ ng: <code>int(f)</code>, <code>float64(i)</code>...</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Map cÃ³ Ä‘Æ°á»£c dÃ¹ng trong nhiá»u goroutine khÃ´ng?
    <pre><code>KhÃ´ng â€“ map khÃ´ng thread-safe.

DÃ¹ng map trong nhiá»u goroutine cáº§n báº£o vá»‡ báº±ng <code>sync.Mutex</code>
hoáº·c thay tháº¿ báº±ng <code>sync.Map</code>.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> GÃ¡n <code>map1 := map2</code> thÃ¬ cÃ³ Ä‘á»™c láº­p khÃ´ng?
    <pre><code>KhÃ´ng â€“ cáº£ hai cÃ¹ng trá» Ä‘áº¿n cÃ¹ng vÃ¹ng nhá»› underlying.

Thay Ä‘á»•i trÃªn má»™t map sáº½ áº£nh hÆ°á»Ÿng map cÃ²n láº¡i.</code></pre>
  </li>
</ul>


<hr />
<h1 id="5-struct-method-vÃ -embedded-struct">5. Struct, Method vÃ  Embedded Struct</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Struct</strong>: gom cÃ¡c field thÃ nh cáº¥u trÃºc dá»¯ liá»‡u.</li>
  <li><strong>Method</strong>: hÃ m gáº¯n vá»›i kiá»ƒu (cÃ³ thá»ƒ lÃ  pointer hoáº·c value).</li>
  <li><strong>Embedded Struct</strong>: cho phÃ©p káº¿ thá»«a hÃ nh vi.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li><code>Value receiver</code>: dÃ¹ng khi khÃ´ng cáº§n thay Ä‘á»•i data, copy.</li>
  <li><code>Pointer receiver</code>: dÃ¹ng Ä‘á»ƒ thay Ä‘á»•i trá»±c tiáº¿p hoáº·c tiáº¿t kiá»‡m copy.</li>
  <li>Sáº¯p xáº¿p field áº£nh hÆ°á»Ÿng padding/memory layout.</li>
</ul>

<pre><code class="go">type User struct {
    ID   int64
    Name string
    Age  int8
    Flag bool
}

// memory align tá»‘t hÆ¡n náº¿u sáº¯p: int64, string, bool, int8

func (u User) Greet() string {
    return "Hi " + u.Name
}
func (u *User) SetAge(age int8) {
    u.Age = age
}

type Admin struct {
    User
    Role string
}
</code></pre>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> KhÃ¡c biá»‡t giá»¯a value receiver vÃ  pointer receiver?
    <pre><code><strong>Value receiver</strong>: nháº­n báº£n sao â†’ khÃ´ng thay Ä‘á»•i giÃ¡ trá»‹ gá»‘c.

<strong>Pointer receiver</strong>: thao tÃ¡c trá»±c tiáº¿p trÃªn vÃ¹ng nhá»› gá»‘c â†’ thay Ä‘á»•i Ä‘Æ°á»£c struct.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn mix cáº£ pointer vÃ  value receiver trong cÃ¹ng struct?
    <pre><code>KhÃ´ng nÃªn â€“ dÃ¹ Go cho phÃ©p, nhÆ°ng dá»… gÃ¢y rá»‘i logic.

NÃªn thá»‘ng nháº¥t: náº¿u cÃ³ method dÃ¹ng pointer â†’ toÃ n bá»™ struct nÃªn dÃ¹ng pointer receiver.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Embedded struct khÃ¡c gÃ¬ inheritance trong OOP?
    <pre><code>Embedded struct lÃ  composition â€“ khÃ´ng pháº£i káº¿ thá»«a thá»±c sá»±.

KhÃ´ng cÃ³ override, khÃ´ng gá»i Ä‘Æ°á»£c <code>super()</code>, nhÆ°ng cho phÃ©p reuse field vÃ  method.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ override method tá»« embedded struct khÃ´ng?
    <pre><code>KhÃ´ng. Náº¿u Ä‘á»‹nh nghÄ©a method trÃ¹ng tÃªn â†’ sáº½ shadow method cá»§a embedded struct.

KhÃ´ng cÃ³ cÆ¡ cháº¿ override thá»±c sá»± nhÆ° trong Java hay C++.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Sáº¯p xáº¿p field trong struct áº£nh hÆ°á»Ÿng gÃ¬?
    <pre><code>áº¢nh hÆ°á»Ÿng Ä‘áº¿n memory padding.

Náº¿u sáº¯p khÃ´ng há»£p lÃ½ â†’ bá»‹ thá»«a padding â†’ struct tá»‘n bá»™ nhá»› hÆ¡n.

NÃªn sáº¯p theo thá»© tá»± giáº£m dáº§n kÃ­ch thÆ°á»›c: int64 â†’ int32 â†’ bool â†’ int8...</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ gÃ¡n method cho kiá»ƒu alias khÃ´ng?
    <pre><code>Chá»‰ gÃ¡n Ä‘Æ°á»£c method cho custom type, khÃ´ng pháº£i alias trá»±c tiáº¿p cá»§a built-in.

VÃ­ dá»¥: <code>type MyInt int</code> â†’ Ä‘Æ°á»£c. NhÆ°ng <code>type MyInt = int</code> â†’ khÃ´ng Ä‘Æ°á»£c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ dÃ¹ng struct anonymous trong Go khÃ´ng?
    <pre><code>CÃ³ â€“ dÃ¹ng trong pháº¡m vi hÃ m nhÆ°:

tmp := struct {
  Name string
  Age  int
}{Name: "A", Age: 20}</code></pre>
  </li>
</ul>

<hr />
<h1 id="6-interface-vÃ -type-assertion">6. Interface vÃ  Type Assertion</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m chuyÃªn sÃ¢u</h2>
<ul>
  <li>Interface gá»“m 2 pháº§n: <code>type</code> + <code>value</code>.</li>
  <li>Empty interface <code>interface{{}}</code>: cháº¥p nháº­n má»i kiá»ƒu, dÃ¹ng trong JSON, log...</li>
  <li>Interface lÆ°u <strong>báº£n sao</strong> giÃ¡ trá»‹ (khÃ´ng trá» trá»±c tiáº¿p unless pointer).</li>
</ul>

<h2>ğŸ’¡ PhÃ¢n tÃ­ch</h2>
<ul>
  <li><code>type assertion</code> Ã©p vá» kiá»ƒu cá»¥ thá»ƒ <code>val.(string)</code>.</li>
  <li><code>type switch</code> dÃ¹ng Ä‘á»ƒ xá»­ lÃ½ Ä‘a kiá»ƒu khi biáº¿t lÃ  interface.</li>
</ul>

<pre><code class="go">type Printer interface {
    Print()
}

type File struct{ Path string }

func (f File) Print() {
    fmt.Println("File:", f.Path)
}

func inspect(i interface{}) {
    switch v := i.(type) {
    case string:
        fmt.Println("string:", v)
    case int:
        fmt.Println("int:", v)
    default:
        fmt.Println("unknown")
    }
}
</code></pre>
<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Interface trong Go lÆ°u trá»¯ nhá»¯ng gÃ¬?
    <pre><code>Interface lÆ°u 2 pháº§n:
- type (loáº¡i thá»±c táº¿)
- value (giÃ¡ trá»‹ thá»±c táº¿)

ÄÃ¢y lÃ  lÃ½ do interface cÃ³ thá»ƒ giá»¯ má»i giÃ¡ trá»‹ â€“ ká»ƒ cáº£ pointer hay nil.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Sá»± khÃ¡c biá»‡t giá»¯a <code>interface{} == nil</code> vÃ  <code>val == nil</code> lÃ  gÃ¬?
    <pre><code><code>interface{} == nil</code> chá»‰ true náº¿u cáº£ type vÃ  value Ä‘á»u nil.

NhÆ°ng náº¿u interface chá»©a type non-nil (vd: *MyStruct) nhÆ°ng value lÃ  nil,
â†’ váº«n khÃ¡c nil â†’ dá»… gÃ¢y bug.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng <code>interface{}</code> trong há»‡ thá»‘ng?
    <pre><code>Chá»‰ dÃ¹ng khi cáº§n generic hÃ³a: log, JSON marshal, middleware...

KhÃ´ng nÃªn dÃ¹ng á»Ÿ business logic vÃ¬ máº¥t type safety, dá»… gÃ¢y lá»—i runtime.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>type assertion</code> cÃ³ an toÃ n khÃ´ng? So vá»›i <code>type switch</code>?
    <pre><code><code>val.(T)</code> sáº½ panic náº¿u sai kiá»ƒu.

DÃ¹ng <code>val, ok := val.(T)</code> Ä‘á»ƒ trÃ¡nh panic.

<code>type switch</code> an toÃ n hÆ¡n khi kiá»ƒm tra nhiá»u kiá»ƒu â€“ nÃªn Æ°u tiÃªn trong handler.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Interface cÃ³ thá»ƒ implement method pointer vÃ  value khÃ¡c nhau khÃ´ng?
    <pre><code>CÃ³. Náº¿u method cÃ³ pointer receiver â†’ chá»‰ pointer má»›i implement Ä‘Æ°á»£c.

Náº¿u method cÃ³ value receiver â†’ cáº£ value vÃ  pointer Ä‘á»u dÃ¹ng Ä‘Æ°á»£c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Interface cÃ³ tá»‘n bá»™ nhá»› hÆ¡n struct khÃ´ng?
    <pre><code>CÃ³ â€“ vÃ¬ interface lÆ°u thÃªm metadata (type + value).

NgoÃ i ra, náº¿u interface chá»©a giÃ¡ trá»‹ escape heap â†’ tÄƒng Ã¡p lá»±c GC.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao kiá»ƒm tra runtime 1 biáº¿n cÃ³ implement interface hay khÃ´ng?
    <pre><code>DÃ¹ng <code>_, ok := val.(TargetInterface)</code> Ä‘á»ƒ kiá»ƒm tra nhanh.

Náº¿u cáº§n kiá»ƒm tra sÃ¢u hÆ¡n â†’ dÃ¹ng <code>reflect.TypeOf(val).Implements()</code>.</code></pre>
  </li>
</ul>


<hr />
<h1 id="7-module-package-vÃ -go-mod">7. Module, Package vÃ  go mod</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m</h2>
<ul>
  <li><strong>Package</strong>: nhÃ³m logic nhá», má»—i thÆ° má»¥c cÃ³ file <code>package x</code>.</li>
  <li><strong>Module</strong>: táº­p há»£p package, báº¯t Ä‘áº§u tá»« thÆ° má»¥c cÃ³ file <code>go.mod</code>.</li>
</ul>

<h2>ğŸ“Œ CÃ¡c lá»‡nh quan trá»ng</h2>
<ul>
  <li><code>go mod init module_name</code>: khá»Ÿi táº¡o module</li>
  <li><code>go mod tidy</code>: dá»n dependency, xÃ³a unused</li>
  <li><code>go get</code>: thÃªm thÆ° viá»‡n</li>
  <li><code>go mod edit</code>: sá»­a go.mod thá»§ cÃ´ng</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥</h2>
<pre><code>// go.mod
module github.com/example/myapp

go 1.21

require (
    github.com/sirupsen/logrus v1.9.0
)

// thÆ° má»¥c project
myapp/
â”œâ”€â”€ go.mod
â”œâ”€â”€ main.go
â”œâ”€â”€ util/
â”‚   â””â”€â”€ math.go  (package util)
</code></pre>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Sá»± khÃ¡c nhau giá»¯a <code>package</code> vÃ  <code>module</code> trong Go lÃ  gÃ¬?
    <pre><code><strong>Package</strong>: lÃ  Ä‘Æ¡n vá»‹ tá»• chá»©c code nhá» nháº¥t â€“ má»—i thÆ° má»¥c lÃ  má»™t package.

<strong>Module</strong>: lÃ  táº­p há»£p nhiá»u package, Ä‘Æ°á»£c quáº£n lÃ½ qua <code>go.mod</code> â€“ cho phÃ©p khai bÃ¡o version, dependency.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Má»™t project Go cÃ³ thá»ƒ chá»©a nhiá»u module Ä‘Æ°á»£c khÃ´ng?
    <pre><code>CÃ³ â€“ nhÆ°ng khÃ´ng nÃªn trá»« khi báº¡n cáº§n tÃ¡ch version Ä‘á»™c láº­p.

ThÆ°á»ng má»—i repo chá»‰ nÃªn cÃ³ 1 module Ä‘á»ƒ Ä‘Æ¡n giáº£n hoÃ¡ quáº£n lÃ½ dependency vÃ  CI/CD.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>go mod tidy</code> khÃ¡c gÃ¬ <code>go get</code>?
    <pre><code><code>go mod tidy</code>: tá»± Ä‘á»™ng dá»n dáº¹p dependency khÃ´ng dÃ¹ng, thÃªm cÃ¡i cÃ²n thiáº¿u.

<code>go get</code>: thÃªm hoáº·c cáº­p nháº­t module theo version cá»¥ thá»ƒ (Go < 1.17).</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao Ä‘á»ƒ import local package trong cÃ¹ng module?
    <pre><code>Import theo tÃªn logic trong <code>go.mod</code>:

VÃ­ dá»¥: náº¿u go.mod lÃ  <code>module github.com/abc/app</code>,
thÃ¬ file á»Ÿ thÆ° má»¥c <code>utils/log</code> sáº½ Ä‘Æ°á»£c import lÃ :
<code>import "github.com/abc/app/utils/log"</code></code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Äiá»u gÃ¬ xáº£y ra khi báº¡n Ä‘á»•i tÃªn module trong <code>go.mod</code>?
    <pre><code>Táº¥t cáº£ cÃ¡c import path theo module Ä‘Ã³ cáº§n Ä‘Æ°á»£c cáº­p nháº­t tÆ°Æ¡ng á»©ng.

Náº¿u khÃ´ng sáº½ gÃ¢y lá»—i compile hoáº·c mismatch module path.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ dÃ¹ng 2 version khÃ¡c nhau cá»§a cÃ¹ng 1 module trong go mod khÃ´ng?
    <pre><code>KhÃ´ng â€“ Go khÃ´ng há»— trá»£ multiple version cho cÃ¹ng má»™t module trong cÃ¹ng thá»i Ä‘iá»ƒm build.

Go sáº½ chá»n version cao nháº¥t thoáº£ dependency graph.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>replace</code> directive trong <code>go.mod</code> dÃ¹ng Ä‘á»ƒ lÃ m gÃ¬?
    <pre><code>DÃ¹ng Ä‘á»ƒ thay Ä‘á»•i source module khi build.

VÃ­ dá»¥: dÃ¹ng local path hoáº·c fork thay vÃ¬ module chÃ­nh thá»©c:
<code>replace github.com/lib/original => ../lib/fork</code></code></pre>
  </li>
</ul>



<hr />
<h1 id="8-goroutine-vÃ -channel">8. Goroutine vÃ  Channel</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Goroutine</strong> lÃ  Ä‘Æ¡n vá»‹ thá»±c thi nháº¹ cá»§a Go, hoáº¡t Ä‘á»™ng song song (concurrent) dá»±a trÃªn cÆ¡ cháº¿ <code>M:N scheduling</code>.</li>
  <li><strong>Channel</strong> lÃ  cáº¥u trÃºc truyá»n thÃ´ng Ä‘á»“ng bá»™ giá»¯a cÃ¡c goroutine, giÃºp trao Ä‘á»•i dá»¯ liá»‡u an toÃ n.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Goroutine ráº¥t nháº¹ (~2KB stack), Ä‘Æ°á»£c Go runtime quáº£n lÃ½, cÃ³ thá»ƒ scale hÃ ng nghÃ¬n.</li>
  <li>Go sá»­ dá»¥ng M:N scheduler: nhiá»u goroutine cháº¡y trÃªn nhiá»u OS thread thÃ´ng qua logical processor (GOMAXPROCS).</li>
  <li><code>channel</code> cÃ³ 2 loáº¡i: buffered vÃ  unbuffered â€” áº£nh hÆ°á»Ÿng trá»±c tiáº¿p Ä‘áº¿n hÃ nh vi block.</li>
  <li><strong>select</strong> cho phÃ©p chá» nhiá»u channel cÃ¹ng lÃºc.</li>
  <li><code>close(chan)</code> bÃ¡o hiá»‡u channel Ä‘Ã£ Ä‘Ã³ng, khÃ´ng gá»­i thÃªm Ä‘Æ°á»£c.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("worker %d processing job %d\n", id, j)
        time.Sleep(time.Second)
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 5)
    results := make(chan int, 5)

    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)

    for r := 1; r <= 5; r++ {
        fmt.Println("result:", <-results)
    }
}
</code></pre>

<h2>ğŸ“Œ TÆ° duy há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Fan-out:</strong> nhiá»u goroutine cÃ¹ng xá»­ lÃ½ chung 1 channel Ä‘áº§u vÃ o (nhÆ° worker pool).</li>
  <li><strong>Fan-in:</strong> nhiá»u nguá»“n channel gá»™p láº¡i vá» má»™t channel Ä‘áº§u ra.</li>
  <li>TrÃ¡nh deadlock báº±ng viá»‡c luÃ´n <strong>Ä‘Ã³ng channel</strong> náº¿u khÃ´ng dÃ¹ng ná»¯a, vÃ  kiá»ƒm soÃ¡t ká»¹ unbuffered channel.</li>
  <li>DÃ¹ng <code>select {}</code> káº¿t há»£p vá»›i <code>context</code> Ä‘á»ƒ xá»­ lÃ½ timeout, cancel.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">// Goroutine Ä‘Æ¡n giáº£n
go func() {
    fmt.Println("Cháº¡y song song")
}()

// Channel Ä‘á»“ng bá»™ (unbuffered)
ch := make(chan int)
go func() {
    ch <- 10 // gá»­i dá»¯ liá»‡u
}()
val := <-ch // nháº­n dá»¯ liá»‡u
fmt.Println("Nháº­n Ä‘Æ°á»£c:", val)

// Buffered channel
cb := make(chan string, 2)
cb <- "hello"
cb <- "world"
fmt.Println(<-cb)
fmt.Println(<-cb)

// Select trÃªn nhiá»u channel
c1 := make(chan string)
c2 := make(chan string)

go func() { c1 <- "one" }()
go func() { c2 <- "two" }()

select {
case msg1 := <-c1:
    fmt.Println("tá»« c1:", msg1)
case msg2 := <-c2:
    fmt.Println("tá»« c2:", msg2)
}

// Channel Ä‘Ã³ng
done := make(chan struct{})
close(done)
_, ok := <-done
fmt.Println("Channel Ä‘Ã£ Ä‘Ã³ng:", !ok)
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li>Sá»­ dá»¥ng goroutine Ä‘á»ƒ xÃ¢y dá»±ng mÃ´ hÃ¬nh <strong>worker pool</strong>, <strong>fan-out</strong>, <strong>pipeline processing</strong>.</li>
  <li>Channel giÃºp loáº¡i bá» lock trong nhiá»u tÃ¬nh huá»‘ng, nhÆ°ng cÅ©ng dá»… gÃ¢y deadlock náº¿u khÃ´ng hiá»ƒu rÃµ blocking behavior.</li>
  <li>KhÃ´ng bao giá» Ä‘Æ°á»£c <code>close()</code> channel á»Ÿ phÃ­a nháº­n.</li>
  <li>Nil channel sáº½ block vÄ©nh viá»…n â€“ cáº§n trÃ¡nh trong production logic.</li>
</ul>

<h2>ğŸ§  NÃ¢ng cao: main cÅ©ng lÃ  má»™t Goroutine</h2>
<ul>
  <li>HÃ m <code>main()</code> trong Go thá»±c cháº¥t cháº¡y trong má»™t goroutine Ä‘áº§u tiÃªn Ä‘Æ°á»£c táº¡o bá»Ÿi runtime.</li>
  <li>Khi <code>main()</code> káº¿t thÃºc, toÃ n bá»™ chÆ°Æ¡ng trÃ¬nh sáº½ <strong>exit ngay láº­p tá»©c</strong>, ká»ƒ cáº£ cÃ¡c goroutine khÃ¡c chÆ°a hoÃ n táº¥t.</li>
  <li>VÃ¬ váº­y: náº¿u báº¡n khá»Ÿi táº¡o goroutine trong <code>main()</code> mÃ  khÃ´ng dÃ¹ng <code>WaitGroup</code>, <code>channel</code>, hoáº·c <code>sleep</code>, chÆ°Æ¡ng trÃ¬nh cÃ³ thá»ƒ káº¿t thÃºc khi goroutine chÆ°a cháº¡y xong.</li>
</ul>

<h2>ğŸ§  Khá»Ÿi táº¡o vÃ  thá»© tá»± thá»±c thi: func init, import</h2>
<ul>
  <li>Go tá»± Ä‘á»™ng cháº¡y táº¥t cáº£ <code>func init()</code> cá»§a tá»«ng file trÆ°á»›c khi <code>main()</code> cháº¡y.</li>
  <li>Trong má»—i package:
    <ul>
      <li>Biáº¿n toÃ n cá»¥c Ä‘Æ°á»£c khá»Ÿi táº¡o trÆ°á»›c</li>
      <li>Sau Ä‘Ã³ cháº¡y <code>init()</code> theo thá»© tá»± khai bÃ¡o</li>
    </ul>
  </li>
  <li>Thá»© tá»± import vÃ  khá»Ÿi táº¡o package lÃ  <strong>Ä‘á»‡ quy theo dependency</strong>: Go Ä‘áº£m báº£o cÃ¡c package phá»¥ thuá»™c Ä‘Æ°á»£c init trÆ°á»›c khi package cha cháº¡y init.</li>
</ul>

<pre><code class="go">package main

import "fmt"

var G = initVar()

func initVar() int {
    fmt.Println("initVar gá»i trÆ°á»›c main")
    return 100
}

func init() {
    fmt.Println("init cháº¡y trÆ°á»›c main")
}

func main() {
    fmt.Println("main báº¯t Ä‘áº§u")
}
</code></pre>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o goroutine bá»‹ leak? LÃ m sao phÃ¡t hiá»‡n?
    <pre><code>Goroutine bá»‹ leak khi:
- NÃ³ block mÃ£i mÃ£i (thÆ°á»ng do chá» channel khÃ´ng ai gá»­i),
- Hoáº·c context Ä‘Ã£ bá»‹ huá»· nhÆ°ng goroutine khÃ´ng kiá»ƒm tra <code>ctx.Done()</code>.

PhÃ¡t hiá»‡n báº±ng: <code>runtime.NumGoroutine()</code>, <code>pprof</code>, hoáº·c log traceID khÃ´ng thoÃ¡t.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh <code>buffered</code> vs <code>unbuffered channel</code>. DÃ¹ng sai gÃ¢y gÃ¬?
    <pre><code><strong>Unbuffered</strong>: sender vÃ  receiver pháº£i gáº·p nhau má»›i unblock â†’ dá»… deadlock náº¿u lá»‡ch.

<strong>Buffered</strong>: sender cÃ³ thá»ƒ gá»­i trÆ°á»›c, nhÆ°ng váº«n block náº¿u Ä‘áº§y â†’ dÃ¹ng sai váº«n cÃ³ thá»ƒ block!

Cáº§n hiá»ƒu ká»¹ luá»“ng Ä‘i vÃ  thá»i Ä‘iá»ƒm <code>close()</code> channel.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u Ä‘á»c tá»« má»™t channel Ä‘Ã£ bá»‹ close?
    <pre><code>Go khÃ´ng panic â€“ giÃ¡ trá»‹ zero sáº½ Ä‘Æ°á»£c tráº£ vá», vÃ  biáº¿n <code>ok</code> sáº½ lÃ  false.

<code>val, ok := <-ch</code> â†’ ok = false náº¿u channel Ä‘Ã£ close.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Táº¡i sao khÃ´ng nÃªn close channel á»Ÿ bÃªn nháº­n?
    <pre><code>VÃ¬ channel chá»‰ nÃªn Ä‘Æ°á»£c <strong>close tá»« phÃ­a gá»­i</strong>.

Close tá»« phÃ­a nháº­n dá»… gÃ¢y panic náº¿u bÃªn gá»­i váº«n Ä‘ang hoáº¡t Ä‘á»™ng.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng channel thay Mutex khÃ´ng?
    <pre><code>CÃ³ thá»ƒ â€“ nhÆ°ng chá»‰ khi mÃ´ hÃ¬nh lÃ  producer-consumer rÃµ rÃ ng.

Náº¿u logic lÃ  update dá»¯ liá»‡u shared ngáº«u nhiÃªn â†’ dÃ¹ng Mutex an toÃ n hÆ¡n.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Race condition khi dÃ¹ng channel cÃ³ thá»ƒ xáº£y ra khÃ´ng?
    <pre><code>CÃ³ â€“ vÃ­ dá»¥:
- Ghi channel tá»« nhiá»u goroutine cÃ¹ng lÃºc
- Äá»c/ghi cÃ¹ng lÃºc khi khÃ´ng rÃµ control
- ÄÃ³ng channel nhiá»u nÆ¡i

Channel lÃ  cÃ´ng cá»¥ Ä‘á»“ng bá»™, nhÆ°ng <strong>khÃ´ng loáº¡i bá» háº¿t race náº¿u sai mÃ´ hÃ¬nh.</strong></code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Goroutine thá»±c cháº¥t cháº¡y trÃªn gÃ¬? GMP model lÃ  gÃ¬?
    <pre><code>Goroutine khÃ´ng pháº£i thread â€“ nÃ³ cháº¡y trÃªn GMP model:

- G: goroutine (tÃ¡c vá»¥ logic)
- M: OS thread
- P: processor (bá»™ lÃªn lá»‹ch)

Go runtime Ã¡nh xáº¡ G â†’ M thÃ´ng qua P, giÃºp hÃ ng ngÃ n goroutine chia Ä‘á»u thread hiá»‡u quáº£.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Náº¿u <code>main()</code> káº¿t thÃºc trÆ°á»›c khi goroutine hoÃ n thÃ nh thÃ¬ sao?
    <pre><code>ToÃ n bá»™ chÆ°Æ¡ng trÃ¬nh sáº½ <strong>exit ngay láº­p tá»©c</strong> â€“ khÃ´ng chá» goroutine cháº¡y xong.

Giáº£i phÃ¡p: dÃ¹ng <code>sync.WaitGroup</code>, <code>chan</code>, hoáº·c <code>context</code> Ä‘á»ƒ Ä‘áº£m báº£o chá».</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Select trÃªn nhiá»u channel cÃ³ Æ°u Ä‘iá»ƒm gÃ¬?
    <pre><code>GiÃºp chá»n channel sáºµn sÃ ng â€“ trÃ¡nh block Ä‘Æ¡n luá»“ng.

CÃ³ thá»ƒ dÃ¹ng <code>select + default</code> Ä‘á»ƒ lÃ m non-blocking receive/send.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ gá»­i vÃ o <code>nil channel</code> khÃ´ng?
    <pre><code>KhÃ´ng â€“ sáº½ block mÃ£i mÃ£i.

Nil channel dÃ¹ng Ä‘á»ƒ vÃ´ hiá»‡u hÃ³a select-case theo logic runtime, nhÆ°ng pháº£i kiá»ƒm soÃ¡t cá»±c ká»¹.</code></pre>
  </li>
</ul>

<li>
  <strong>CÃ¢u há»i:</strong> CÃ¡c loáº¡i channel trong Go lÃ  gÃ¬? DÃ¹ng khi nÃ o?
  <pre><code>CÃ³ 3 loáº¡i channel:

ğŸ”¹ <strong>Unbuffered channel</strong>: Ä‘á»“ng bá»™ â€“ gá»­i vÃ  nháº­n pháº£i xáº£y ra Ä‘á»“ng thá»i.
â†’ DÃ¹ng khi cáº§n block cho Ä‘áº¿n khi cÃ³ goroutine Ä‘á»‘i á»©ng â†’ Ä‘áº£m báº£o Ä‘á»“ng bá»™ cháº·t.

ğŸ”¹ <strong>Buffered channel</strong>: khÃ´ng block ngay â€“ cho phÃ©p gá»­i trÆ°á»›c, nháº­n sau.
â†’ DÃ¹ng cho worker pool, pipeline, hoáº·c khi tá»‘c Ä‘á»™ gá»­i/nháº­n lá»‡ch nhau.

ğŸ”¹ <strong>Nil channel</strong>: khÃ´ng gá»­i/nháº­n Ä‘Æ°á»£c gÃ¬ â€“ luÃ´n block.
â†’ DÃ¹ng Ä‘á»ƒ vÃ´ hiá»‡u hoÃ¡ logic trong select-case (nhÆ° enable/disable dynamic).</code></pre>
</li>

<li>
  <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng buffered channel thay vÃ¬ unbuffered?
  <pre><code>Khi muá»‘n tÄƒng throughput vÃ  khÃ´ng cáº§n Ä‘á»“ng bá»™ tá»«ng lá»‡nh gá»­i/nháº­n.

VÃ­ dá»¥: xá»­ lÃ½ log, job queue, worker pool â€“ buffered giÃºp trÃ¡nh block náº¿u consumer cháº­m.</code></pre>
</li>

<li>
  <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng channel Ä‘á»ƒ thay tháº¿ cho má»i loáº¡i Ä‘á»“ng bá»™ khÃ´ng?
  <pre><code>KhÃ´ng. Channel phÃ¹ há»£p vá»›i mÃ´ hÃ¬nh <strong>truyá»n dá»¯ liá»‡u</strong> (communication by sharing).

Náº¿u chá»‰ cáº§n <strong>Ä‘á»“ng bá»™ hoÃ¡ truy cáº­p shared state</strong> â†’ dÃ¹ng <code>sync.Mutex</code> sáº½ Ä‘Æ¡n giáº£n vÃ  hiá»‡u quáº£ hÆ¡n.</code></pre>
</li>


<hr />
<h1 id="9-Ä‘á»“ng-bá»™-hoÃ¡-vá»›i-mutex-rwmutex-waitgroup">9. Äá»“ng bá»™ hoÃ¡ vá»›i Mutex, RWMutex, WaitGroup</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Mutex (Mutual Exclusion)</strong>: dÃ¹ng Ä‘á»ƒ báº£o vá»‡ vÃ¹ng tÃ i nguyÃªn chá»‰ cho phÃ©p 1 goroutine truy cáº­p táº¡i 1 thá»i Ä‘iá»ƒm.</li>
  <li><strong>RWMutex</strong>: cho phÃ©p nhiá»u goroutine Ä‘á»c Ä‘á»“ng thá»i (Read Lock), nhÆ°ng chá»‰ 1 ghi (Write Lock).</li>
  <li><strong>WaitGroup</strong>: dÃ¹ng Ä‘á»ƒ chá» táº¥t cáº£ goroutine hoÃ n táº¥t cÃ´ng viá»‡c trÆ°á»›c khi tiáº¿p tá»¥c.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Mutex hoáº¡t Ä‘á»™ng giá»‘ng nhÆ° critical section â€“ khÃ´ng dÃ¹ng Ä‘Ãºng cÃ³ thá»ƒ gÃ¢y <strong>deadlock</strong>.</li>
  <li>RWMutex dÃ¹ng tá»‘t khi tá»‰ lá»‡ Ä‘á»c cao hÆ¡n ghi, giÃºp tÄƒng concurrency.</li>
  <li>WaitGroup giÃºp báº¡n trÃ¡nh gá»i <code>time.Sleep</code> trong cÃ¡c tÃ¡c vá»¥ song song.</li>
  <li><strong>LuÃ´n</strong> unlock sau lock â€“ dÃ¹ng <code>defer</code> Ä‘á»ƒ an toÃ n.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">import (
    "fmt"
    "sync"
)

var mu sync.Mutex
var count int

func increment() {
    mu.Lock()
    defer mu.Unlock()
    count++
}

// RWMutex cho Ä‘á»c nhiá»u - ghi 1
var rw sync.RWMutex
var data = make(map[string]string)

func readData(key string) string {
    rw.RLock()
    defer rw.RUnlock()
    return data[key]
}

func writeData(key, val string) {
    rw.Lock()
    defer rw.Unlock()
    data[key] = val
}

// WaitGroup vÃ­ dá»¥
var wg sync.WaitGroup

func worker(id int) {
    defer wg.Done()
    fmt.Printf("Worker %d xong viá»‡c\n", id)
}

func main() {
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i)
    }
    wg.Wait() // chá» táº¥t cáº£ worker káº¿t thÃºc
    fmt.Println("Táº¥t cáº£ goroutine Ä‘Ã£ hoÃ n táº¥t")
}
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Mutex</strong>: dÃ¹ng Ä‘á»ƒ Ä‘á»“ng bá»™ hÃ³a cÃ¡c biáº¿n toÃ n cá»¥c khi nhiá»u goroutine Ä‘á»c/ghi cÃ¹ng lÃºc.</li>
  <li><strong>RWMutex</strong>: tá»‘i Æ°u hoÃ¡ hiá»‡u suáº¥t khi sá»‘ lÆ°á»£ng Ä‘á»c nhiá»u gáº¥p nhiá»u láº§n ghi.</li>
  <li><strong>WaitGroup</strong>: thay tháº¿ cho sleep/wait thá»§ cÃ´ng, cá»±c ká»³ hiá»‡u quáº£ trong batch job, worker pool, async task.</li>
  <li><strong>Tips:</strong> LuÃ´n unlock báº±ng <code>defer</code>, trÃ¡nh quÃªn vÃ  gÃ¢y block toÃ n chÆ°Æ¡ng trÃ¬nh.</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Mutex trong Go hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o? CÃ³ thá»ƒ gÃ¢y deadlock khÃ´ng?
    <pre><code>Mutex lÃ  primitive Ä‘áº£m báº£o chá»‰ má»™t goroutine Ä‘Æ°á»£c truy cáº­p vÃ¹ng dá»¯ liá»‡u táº¡i má»™t thá»i Ä‘iá»ƒm.

CÃ³ â€“ náº¿u lock khÃ´ng Ä‘Æ°á»£c unlock, hoáº·c lock nhiá»u chiá»u (A â†’ B vÃ  B â†’ A) â†’ sáº½ gÃ¢y deadlock.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> KhÃ¡c biá»‡t giá»¯a <code>sync.Mutex</code> vÃ  <code>sync.RWMutex</code>?
    <pre><code><strong>Mutex</strong>: chá»‰ 1 goroutine Ä‘Æ°á»£c lock â†’ táº¥t cáº£ block.

<strong>RWMutex</strong>:
- Nhiá»u goroutine Ä‘Æ°á»£c <code>RLock</code> cÃ¹ng lÃºc (read concurrency).
- Chá»‰ 1 goroutine Ä‘Æ°á»£c <code>Lock</code> (write) â€“ block toÃ n bá»™ Ä‘á»c & ghi khÃ¡c.

â†’ RWMutex hiá»‡u quáº£ khi tá»‰ lá»‡ Ä‘á»c >> ghi.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn lá»“ng nhiá»u mutex khÃ´ng? LÃ m sao trÃ¡nh deadlock?
    <pre><code>KhÃ´ng nÃªn â€“ nhÆ°ng náº¿u cáº§n, pháº£i Ä‘áº£m báº£o <strong>thá»© tá»± lock Ä‘á»“ng nháº¥t</strong> trÃªn toÃ n há»‡ thá»‘ng.

VÃ­ dá»¥:
- Thread A lock(m1) â†’ lock(m2)
- Thread B cÅ©ng pháº£i theo thá»© tá»± Ä‘Ã³ â€“ náº¿u Ä‘áº£o chiá»u sáº½ deadlock.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o dÃ¹ng WaitGroup? So vá»›i channel thÃ¬ sao?
    <pre><code><strong>WaitGroup</strong>: dÃ¹ng Ä‘á»ƒ Ä‘á»£i táº¥t cáº£ goroutine hoÃ n táº¥t.

â†’ Dá»… dÃ¹ng trong job batching, Ä‘á»“ng bá»™ nhiá»u tÃ¡c vá»¥ song song.

<strong>Channel</strong>: linh hoáº¡t hÆ¡n â€“ truyá»n dá»¯ liá»‡u, cÃ³ thá»ƒ káº¿t há»£p vá»›i select/context.
WaitGroup khÃ´ng truyá»n dá»¯ liá»‡u, chá»‰ dÃ¹ng Ä‘á»ƒ <strong>Ä‘á»£i</strong>.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Gá»i <code>wg.Done()</code> nhiá»u hÆ¡n hoáº·c Ã­t hÆ¡n <code>wg.Add()</code> cÃ³ sao khÃ´ng?
    <pre><code>CÃ³ â€“ náº¿u Done > Add â†’ panic.

Náº¿u thiáº¿u Done â†’ Wait sáº½ block mÃ£i mÃ£i.

Pháº£i Ä‘áº£m báº£o má»—i goroutine gá»i Done Ä‘Ãºng 1 láº§n â†’ thÆ°á»ng dÃ¹ng defer wg.Done().</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao Ä‘á»ƒ kiá»ƒm soÃ¡t race khi cáº­p nháº­t counter toÃ n cá»¥c?
    <pre><code>DÃ¹ng:
- <code>sync.Mutex</code> hoáº·c <code>sync/atomic</code> Ä‘á»ƒ báº£o vá»‡ biáº¿n toÃ n cá»¥c.
- Hoáº·c gom counter per-goroutine rá»“i tá»•ng há»£p sau â†’ trÃ¡nh contention.

KhÃ´ng dÃ¹ng biáº¿n toÃ n cá»¥c trá»±c tiáº¿p náº¿u nhiá»u goroutine cÃ¹ng ghi.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ cáº§n unlock náº¿u panic xáº£y ra sau Lock() khÃ´ng?
    <pre><code>CÃ³ â€“ náº¿u khÃ´ng unlock, cÃ¡c goroutine sau sáº½ bá»‹ block mÃ£i mÃ£i.

LuÃ´n <strong>dÃ¹ng <code>defer mu.Unlock()</code></strong> ngay sau khi lock Ä‘á»ƒ trÃ¡nh quÃªn â€“ best practice báº¯t buá»™c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Mutex cÃ³ áº£nh hÆ°á»Ÿng gÃ¬ tá»›i performance? Tá»‘i Æ°u tháº¿ nÃ o?
    <pre><code>Mutex gÃ¢y block â†’ náº¿u contention cao sáº½ giáº£m throughput.

Tá»‘i Æ°u:
- Chá»‰ lock vÃ¹ng critical â€“ trÃ¡nh lock bao toÃ n hÃ m.
- DÃ¹ng RWMutex náº¿u chá»§ yáº¿u lÃ  Ä‘á»c.
- DÃ¹ng channel hoáº·c sharding náº¿u muá»‘n scale-out.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh <code>sync.Mutex</code> vá»›i <code>sync/atomic</code> â€“ khi nÃ o dÃ¹ng gÃ¬?
    <pre><code><strong>sync/atomic</strong>: cá»±c nhanh, khÃ´ng block â†’ dÃ¹ng khi thao tÃ¡c Ä‘Æ¡n giáº£n (int, flag).

<strong>Mutex</strong>: dÃ¹ng cho nhiá»u biáº¿n, logic phá»©c táº¡p hoáº·c cáº§n lock nhÃ³m thao tÃ¡c.

Atomic khÃ´ng thay tháº¿ mutex trong má»i tÃ¬nh huá»‘ng â€“ dá»… viáº¿t sai náº¿u khÃ´ng cáº©n tháº­n.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡ch test deadlock hoáº·c race trong code Ä‘á»“ng bá»™?
    <pre><code>âœ”ï¸ DÃ¹ng <code>go run -race</code> â†’ phÃ¡t hiá»‡n data race.

âœ”ï¸ DÃ¹ng <code>pprof</code> Ä‘á»ƒ xem goroutine blocking.

âœ”ï¸ Viáº¿t test cá»‘ tÃ¬nh táº¡o contention Ä‘á»ƒ verify logic Ä‘á»“ng bá»™.</code></pre>
  </li>
</ul>



<hr />
<h1 id="10-context-vÃ -lifecycle-control">10. Context vÃ  Lifecycle Control</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Context</strong> lÃ  chuáº©n cá»§a Go Ä‘á»ƒ truyá»n timeout, deadline, cancel signal vÃ  dá»¯ liá»‡u nháº¹ giá»¯a cÃ¡c goroutine.</li>
  <li>NÃ³ giÃºp quáº£n lÃ½ <strong>vÃ²ng Ä‘á»i</strong> cá»§a tÃ¡c vá»¥ hoáº·c request xuyÃªn suá»‘t há»‡ thá»‘ng.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li>Context nÃªn Ä‘Æ°á»£c truyá»n dÆ°á»›i dáº¡ng parameter Ä‘áº§u tiÃªn: <code>func(ctx context.Context, ...)</code></li>
  <li>CÃ¡c loáº¡i context:
    <ul>
      <li><code>context.Background()</code>: gá»‘c, khÃ´ng bao giá» bá»‹ cancel</li>
      <li><code>context.TODO()</code>: placeholder khi chÆ°a rÃµ context thá»±c sá»±</li>
      <li><code>context.WithCancel</code>, <code>WithTimeout</code>, <code>WithDeadline</code>: táº¡o context cÃ³ kháº£ nÄƒng dá»«ng</li>
    </ul>
  </li>
  <li>Context tá»± Ä‘á»™ng cancel khi deadline timeout hoáº·c cha bá»‹ cancel</li>
  <li>LÃ½ tÆ°á»Ÿng dÃ¹ng trong: HTTP request, job, stream, signal handling, database...</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ thá»±c táº¿</h2>
<pre><code class="go">import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, name string) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Stopped:", name)
            return
        default:
            fmt.Println("Working:", name)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    go worker(ctx, "A")
    go worker(ctx, "B")

    <-ctx.Done()
    fmt.Println("Main: Timeout reached")
}
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li>Context Ä‘Æ°á»£c dÃ¹ng rá»™ng rÃ£i trong <strong>HTTP server</strong>, <strong>database/sql</strong>, <strong>gRPC</strong>, <strong>Kafka</strong>, etc.</li>
  <li>Truyá»n <code>context.Context</code> Ä‘Ãºng chuáº©n giÃºp dá»… debug, trace, stop task theo yÃªu cáº§u</li>
  <li>Context há»— trá»£ <strong>cancel propagation</strong> â†’ goroutine con tá»± Ä‘á»™ng dá»«ng khi cha timeout</li>
  <li><strong>LÆ°u Ã½:</strong> KhÃ´ng dÃ¹ng context Ä‘á»ƒ lÆ°u dá»¯ liá»‡u lá»›n hoáº·c logic â€” chá»‰ dÃ¹ng Ä‘á»ƒ truyá»n metadata nháº¹.</li>
</ul>
<h2>ğŸ“Š Flow: Truyá»n context tá»« Envoy xuá»‘ng cÃ¡c táº§ng trong há»‡ thá»‘ng</h2>

<p>Trong há»‡ thá»‘ng microservice dÃ¹ng Envoy hoáº·c gRPC gateway, context thÆ°á»ng Ä‘Æ°á»£c truyá»n xuyÃªn suá»‘t tá»« request gá»‘c tá»›i tá»«ng táº§ng function vÃ  database.</p>

<pre><code>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Envoy Proxy  â”‚
â”‚ - Truyá»n header: x-request-id, deadline, trace-id
â”‚ - Forward HTTP/gRPC request
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Gateway API  â”‚
â”‚ - Táº¡o context gá»‘c: context.WithTimeout(...)
â”‚ - ÄÃ­nh trace-id vÃ o context
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application Handler        â”‚
â”‚ - ctx Ä‘Æ°á»£c truyá»n vÃ o hÃ m â”‚
â”‚   func(ctx context.Context)â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Layer / Usecase    â”‚
â”‚ - ctx tiáº¿p tá»¥c Ä‘Æ°á»£c truyá»nâ”‚
â”‚ - Add logging/tracing tag â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Database / Repository Layerâ”‚
â”‚ - DÃ¹ng ctx trong query:    â”‚
â”‚   db.QueryContext(ctx, ...)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<h2>ğŸ“Œ Ã nghÄ©a thiáº¿t káº¿</h2>
<ul>
  <li><strong>Truyá»n context xuyÃªn suá»‘t</strong> giÃºp enforce timeout, cancel toÃ n bá»™ call chain khi request timeout tá»« Ä‘áº§u.</li>
  <li><code>ctx</code> chá»©a metadata nhÆ° trace-id, user-id â†’ dÃ¹ng cho log/tracing/monitoring.</li>
  <li><code>db.QueryContext</code> giÃºp tá»± Ä‘á»™ng abort query khi context bá»‹ cancel (timeout hoáº·c shutdown).</li>
  <li>Viá»‡c propagate Ä‘Ãºng context giÃºp báº¡n build há»‡ thá»‘ng resilient, observable vÃ  debuggable.</li>
</ul>


<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Context trong Go Ä‘Æ°á»£c thiáº¿t káº¿ Ä‘á»ƒ giáº£i quyáº¿t váº¥n Ä‘á» gÃ¬?
    <pre><code>Quáº£n lÃ½ vÃ²ng Ä‘á»i cá»§a tÃ¡c vá»¥ â€“ truyá»n timeout, deadline, cancel signal xuyÃªn suá»‘t há»‡ thá»‘ng (tá»« HTTP â†’ DB â†’ goroutine...).

GiÃºp dá»«ng task Ä‘Ãºng lÃºc, trÃ¡nh leak tÃ i nguyÃªn vÃ  há»— trá»£ trace/log.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Sá»± khÃ¡c nhau giá»¯a <code>context.Background()</code> vÃ  <code>context.TODO()</code>?
    <pre><code><code>Background()</code>: gá»‘c, nÃªn dÃ¹ng cho main, init, hoáº·c test â€“ khÃ´ng bao giá» bá»‹ cancel.

<code>TODO()</code>: placeholder â€“ dÃ¹ng táº¡m khi chÆ°a xÃ¡c Ä‘á»‹nh Ä‘Æ°á»£c context cha.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh <code>WithCancel</code>, <code>WithTimeout</code>, vÃ  <code>WithDeadline</code>
    <pre><code>- <code>WithCancel()</code>: táº¡o context cÃ³ thá»ƒ huá»· tay báº±ng hÃ m <code>cancel()</code>
- <code>WithTimeout()</code>: huá»· sau khoáº£ng thá»i gian xÃ¡c Ä‘á»‹nh
- <code>WithDeadline()</code>: huá»· táº¡i thá»i Ä‘iá»ƒm cá»‘ Ä‘á»‹nh (absolute time)

Táº¥t cáº£ Ä‘á»u káº¿ thá»«a tá»« context cha â†’ huá»· truyá»n theo cha.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o context bá»‹ cancel?
    <pre><code>1. Khi <code>cancel()</code> Ä‘Æ°á»£c gá»i thá»§ cÃ´ng
2. Khi timeout háº¿t háº¡n hoáº·c tá»›i deadline
3. Khi context cha bá»‹ cancel â†’ lan xuá»‘ng context con</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Dá»¯ liá»‡u truyá»n qua context nÃªn chá»©a gÃ¬?
    <pre><code>Chá»‰ truyá»n metadata nháº¹: request ID, user ID, trace ID, langâ€¦

KhÃ´ng truyá»n dá»¯ liá»‡u lá»›n, pointer phá»©c táº¡p hoáº·c logic xá»­ lÃ½ â†’ context lÃ  control signal, khÃ´ng pháº£i data bus.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u khÃ´ng gá»i <code>cancel()</code>?
    <pre><code>Leak tÃ i nguyÃªn â€“ context khÃ´ng bá»‹ huá»·, goroutine phá»¥ thuá»™c vÃ o nÃ³ sáº½ khÃ´ng dá»«ng.

â†’ luÃ´n dÃ¹ng <code>defer cancel()</code> sau <code>context.With*</code> Ä‘á»ƒ Ä‘áº£m báº£o cleanup.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Context giÃºp xá»­ lÃ½ graceful shutdown nhÆ° tháº¿ nÃ o?
    <pre><code>1. Báº¯t tÃ­n hiá»‡u OS (SIGINT/SIGTERM)
2. Gá»i <code>cancel()</code> hoáº·c huá»· context gá»‘c
3. CÃ¡c goroutine Ä‘ang cháº¡y kiá»ƒm tra <code>ctx.Done()</code> vÃ  thoÃ¡t
4. Äá»£i báº±ng WaitGroup â†’ Ä‘áº£m báº£o Ä‘Ã³ng hoÃ n toÃ n trÆ°á»›c khi exit</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn truyá»n context qua global biáº¿n?
    <pre><code>KhÃ´ng â€“ context nÃªn Ä‘Æ°á»£c truyá»n qua function parameter Ä‘á»ƒ rÃµ rÃ ng vÃ  trÃ¡nh shared mutable state.

â†’ GiÃºp dá»… trace, test, vÃ  trÃ¡nh bug khi cháº¡y Ä‘á»“ng thá»i.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Gá»i DB/API mÃ  khÃ´ng truyá»n context cÃ³ háº­u quáº£ gÃ¬?
    <pre><code>KhÃ´ng thá»ƒ dá»«ng Ä‘Ãºng lÃºc náº¿u request bá»‹ huá»· (timeout/cancel) â†’ gÃ¢y leak connection, timeout trá»…, táº¯c pool.

â†’ luÃ´n dÃ¹ng <code>db.QueryContext(ctx, ...)</code>, <code>http.NewRequestWithContext</code>.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ bao giá» nÃªn <code>cancel()</code> context nhiá»u láº§n khÃ´ng?
    <pre><code>KhÃ´ng â€“ chá»‰ cancel má»™t láº§n duy nháº¥t. Cancel nhiá»u khÃ´ng lá»—i nhÆ°ng thá»«a logic â†’ nÃªn tÃ¡ch rÃµ chá»§ sá»Ÿ há»¯u context.</code></pre>
  </li>
</ul>


<hr />
<h1 id="11-error-handling-vÃ -panicrecover">11. Error Handling vÃ  Panic/Recover</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Error</strong>: lÃ  giÃ¡ trá»‹ tráº£ vá» Ä‘áº§u tiÃªn cho má»i hÃ m cÃ³ thá»ƒ tháº¥t báº¡i â€“ dáº¡ng <code>error</code> interface.</li>
  <li><strong>Panic</strong>: ngáº¯t luá»“ng xá»­ lÃ½ hiá»‡n táº¡i ngay láº­p tá»©c â€“ chá»‰ nÃªn dÃ¹ng cho lá»—i láº­p trÃ¬nh nghiÃªm trá»ng.</li>
  <li><strong>Recover</strong>: giÃºp "báº¯t" panic trong <code>defer</code>, phá»¥c há»“i Ä‘iá»u khiá»ƒn chÆ°Æ¡ng trÃ¬nh vÃ  trÃ¡nh crash toÃ n bá»™ service.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u</h2>
<ul>
  <li><code>error</code> nÃªn Ä‘Æ°á»£c wrap láº¡i Ä‘á»ƒ giá»¯ ngá»¯ cáº£nh: dÃ¹ng <code>fmt.Errorf("thao tÃ¡c tháº¥t báº¡i: %w", err)</code>.</li>
  <li>DÃ¹ng <code>errors.Is</code>, <code>errors.As</code>, <code>errors.Unwrap</code> Ä‘á»ƒ phÃ¢n tÃ­ch chain lá»—i khi cáº§n.</li>
  <li><code>recover()</code> chá»‰ hoáº¡t Ä‘á»™ng bÃªn trong <code>defer</code>. BÃªn ngoÃ i sáº½ khÃ´ng ngÄƒn panic.</li>
  <li>Go runtime khi panic:
    <ul>
      <li>Gá»i toÃ n bá»™ defer stack</li>
      <li>Náº¿u cÃ³ recover â†’ láº¥y láº¡i Ä‘iá»u khiá»ƒn</li>
      <li>Náº¿u khÃ´ng â†’ in stacktrace vÃ  <strong>exit</strong></li>
    </ul>
  </li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥: error wrapping + panic/recover</h2>
<pre><code class="go">func doSomething() error {
    err := errors.New("káº¿t ná»‘i tháº¥t báº¡i")
    return fmt.Errorf("lá»—i khi gá»i backend: %w", err)
}

func safeRun() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("ÄÃ£ recover tá»« panic:", r)
        }
    }()
    panic("há»‡ thá»‘ng lá»—i nghiÃªm trá»ng")
}
</code></pre>
<h2>ğŸ§  Graceful Shutdown hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?</h2>
<ul>
  <li>Khi báº¡n nháº¥n <code>Ctrl+C</code> hoáº·c há»‡ thá»‘ng gá»­i tÃ­n hiá»‡u <code>SIGINT</code>, <code>SIGTERM</code> (tá»« orchestrator nhÆ° Kubernetes), Go program cÃ³ thá»ƒ <strong>báº¯t tÃ­n hiá»‡u nÃ y</strong> qua <code>os/signal</code>.</li>
  <li>Khi báº¯t Ä‘Æ°á»£c tÃ­n hiá»‡u, báº¡n gá»i <code>cancel()</code> tá»« <code>context.WithCancel</code> Ä‘á»ƒ truyá»n tÃ­n hiá»‡u dá»«ng xuá»‘ng táº¥t cáº£ cÃ¡c táº§ng bÃªn dÆ°á»›i.</li>
  <li>Má»—i goroutine Ä‘ang cháº¡y cáº§n láº¯ng nghe <code>ctx.Done()</code> Ä‘á»ƒ biáº¿t khi nÃ o cáº§n dá»«ng.</li>
  <li>Báº¡n cÃ³ thá»ƒ dÃ¹ng <code>sync.WaitGroup</code> Ä‘á»ƒ Ä‘áº£m báº£o táº¥t cáº£ goroutine xá»­ lÃ½ xong trÆ°á»›c khi main káº¿t thÃºc.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥: shutdown Ä‘á»£i worker xá»­ lÃ½ xong</h2>
<pre><code class="go">func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    sig := make(chan os.Signal, 1)
    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

    go func() {
        <-sig
        fmt.Println("Nháº­n tÃ­n hiá»‡u táº¯t, huá»· context...")
        cancel()
    }()

    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()
        runJob(ctx)
    }()

    wg.Wait() // Ä‘á»£i toÃ n bá»™ goroutine hoÃ n táº¥t
    fmt.Println("Shutdown hoÃ n táº¥t")
}

func runJob(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Dá»«ng xá»­ lÃ½ cÃ´ng viá»‡c")
            return
        default:
            fmt.Println("Äang xá»­ lÃ½ cÃ´ng viá»‡c...")
            time.Sleep(1 * time.Second)
        }
    }
}
</code></pre>

<h2>ğŸ“Œ TÃ³m táº¯t lá»£i Ã­ch Graceful Shutdown</h2>
<ul>
  <li>Cho phÃ©p há»‡ thá»‘ng <strong>hoÃ n táº¥t cÃ´ng viá»‡c dang dá»Ÿ</strong> trÆ°á»›c khi thoÃ¡t.</li>
  <li>Giáº£i phÃ³ng tÃ i nguyÃªn Ä‘Ãºng cÃ¡ch (database, network, file, goroutine).</li>
  <li>KhÃ´ng bá»‹ máº¥t dá»¯ liá»‡u hoáº·c ngáº¯t káº¿t ná»‘i giá»¯a chá»«ng.</li>
  <li>Chuáº©n ká»¹ thuáº­t báº¯t buá»™c vá»›i <strong>microservice, HTTP/gRPC API, cronjob</strong> production.</li>
</ul>


<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Error wrapping</strong>: duy trÃ¬ stack trace, logic táº§ng cao dá»… debug.</li>
  <li><strong>Recover</strong>: chá»‘ng crash há»‡ thá»‘ng â€” Ä‘áº·c biá»‡t á»Ÿ cÃ¡c goroutine, worker hoáº·c middleware.</li>
  <li><strong>Graceful shutdown</strong>: báº¯t buá»™c á»Ÿ service production â€” trÃ¡nh máº¥t dá»¯ liá»‡u, close connection Ä‘Ãºng cÃ¡ch.</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> VÃ¬ sao Go khÃ´ng dÃ¹ng try-catch nhÆ° cÃ¡c ngÃ´n ngá»¯ khÃ¡c?
    <pre><code>Triáº¿t lÃ½ cá»§a Go: lá»—i lÃ  dá»¯ liá»‡u â€“ cáº§n xá»­ lÃ½ tÆ°á»ng minh báº±ng return.

â†’ GiÃºp logic rÃµ rÃ ng, kiá»ƒm soÃ¡t luá»“ng tá»‘t hÆ¡n, trÃ¡nh swallow lá»—i nhÆ° try-catch.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o dÃ¹ng <code>panic</code>? Khi nÃ o khÃ´ng nÃªn?
    <pre><code>DÃ¹ng panic cho lá»—i <strong>khÃ´ng thá»ƒ hoáº·c khÃ´ng nÃªn recover</strong>:
- Vi pháº¡m báº¥t biáº¿n (bug láº­p trÃ¬nh)
- Lá»—i cáº¥u hÃ¬nh nghiÃªm trá»ng (khÃ´ng tÃ¬m tháº¥y file env, DB init fail...)

KhÃ´ng dÃ¹ng panic trong luá»“ng xá»­ lÃ½ business logic â†’ pháº£i return error.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>recover()</code> dÃ¹ng nhÆ° tháº¿ nÃ o? CÃ³ báº¯t Ä‘Æ°á»£c panic ngoÃ i <code>defer</code> khÃ´ng?
    <pre><code><code>recover()</code> chá»‰ hoáº¡t Ä‘á»™ng bÃªn trong <code>defer</code>.

â†’ Náº¿u gá»i ngoÃ i defer hoáº·c sau khi panic thoÃ¡t hÃ m â†’ khÃ´ng cÃ³ tÃ¡c dá»¥ng.

NÃªn dÃ¹ng Ä‘á»ƒ ngÄƒn há»‡ thá»‘ng crash vÃ  ghi log â†’ nhÆ°ng trÃ¡nh dÃ¹ng Ä‘á»ƒ "báº¯t lá»—i nhÆ° catch".</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Táº¡i sao cáº§n <code>error wrapping</code>? DÃ¹ng tháº¿ nÃ o?
    <pre><code>GiÃºp giá»¯ gá»‘c lá»—i khi truyá»n qua nhiá»u táº§ng â†’ dá»… trace vÃ  debug.

DÃ¹ng: <code>fmt.Errorf("lá»—i logic A: %w", err)</code>
â†’ Táº§ng cao cÃ³ thá»ƒ dÃ¹ng <code>errors.Is</code> hoáº·c <code>errors.As</code> Ä‘á»ƒ phÃ¢n tÃ­ch nguyÃªn nhÃ¢n gá»‘c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh <code>errors.Is()</code> vs <code>errors.As()</code>
    <pre><code>- <code>Is()</code>: so sÃ¡nh lá»—i cÃ³ giá»‘ng 1 lá»—i cá»¥ thá»ƒ khÃ´ng.
- <code>As()</code>: check vÃ  Ã©p kiá»ƒu lá»—i vá» 1 struct cá»¥ thá»ƒ (e.g., *os.PathError).

DÃ¹ng Ä‘á»ƒ xá»­ lÃ½ khÃ¡c nhau theo loáº¡i lá»—i (IO, timeout, validation...).</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Stacktrace trong Go cÃ³ sáºµn khÃ´ng? LÃ m sao láº¥y?
    <pre><code>Máº·c Ä‘á»‹nh khÃ´ng â€“ <code>error</code> khÃ´ng cÃ³ stacktrace.

DÃ¹ng thÃªm lib nhÆ°:
- <code>pkg/errors</code> (cÅ©)
- <code>github.com/pkg/errors</code>
- <code>uber/zap</code> hoáº·c <code>log/slog</code> â†’ tÃ­ch há»£p stack náº¿u panic

Hoáº·c: <code>debug.PrintStack()</code> trong defer/recover.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Náº¿u defer gá»i panic â†’ cÃ³ cháº¡y recover khÃ´ng?
    <pre><code>KhÃ´ng. recover chá»‰ báº¯t panic sinh ra trÆ°á»›c nÃ³.

â†’ Náº¿u panic xáº£y ra trong chÃ­nh defer â†’ sáº½ khÃ´ng recover Ä‘Æ°á»£c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao log error mÃ  khÃ´ng máº¥t stacktrace?
    <pre><code>DÃ¹ng <code>fmt.Errorf(... %w, ...)</code> Ä‘á»ƒ wrap.

Log kÃ¨m stack:
- DÃ¹ng lib há»— trá»£ (<code>zap</code>, <code>slog</code>, <code>errors.WithStack</code>)
- Ghi thÃªm stack vÃ o log trong <code>recover()</code> khi panic.

â†’ TrÃ¡nh log báº±ng fmt.Println â€“ máº¥t toÃ n bá»™ context.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Lá»—i tá»« táº§ng trong truyá»n lÃªn API tráº£ vá» client nÃªn format tháº¿ nÃ o?
    <pre><code>DÃ¹ng:
- <strong>Wrap lá»—i</strong> á»Ÿ táº§ng trong â†’ Ä‘á»ƒ log chi tiáº¿t
- <strong>Map lá»—i</strong> ra mÃ£ code + message thÃ¢n thiá»‡n á»Ÿ táº§ng handler (e.g: 400 Bad Request)

KhÃ´ng tráº£ raw lá»—i ká»¹ thuáº­t ra client.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng sentinel error? Khi nÃ o nÃªn dÃ¹ng error struct?
    <pre><code><strong>Sentinel</strong> (biáº¿n error cá»¥ thá»ƒ): dÃ¹ng khi cáº§n so sÃ¡nh rÃµ rÃ ng (e.g., <code>ErrNotFound</code>).

<strong>Error struct</strong>: dÃ¹ng khi cáº§n Ä‘Ã­nh kÃ¨m context (field, cause, domain, retryableâ€¦)

â†’ Káº¿t há»£p vá»›i <code>errors.As()</code> Ä‘á»ƒ phÃ¢n loáº¡i xá»­ lÃ½.</code></pre>
  </li>
</ul>


<hr />
<h1 id="12-logging-nÃ¢ng-cao-vá»›i-logrus-zap-zerolog">12. Logging nÃ¢ng cao vá»›i logrus, zap, zerolog</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li>Logging lÃ  thÃ nh pháº§n cá»‘t lÃµi trong má»i service Ä‘á»ƒ <strong>trace, debug, audit</strong> vÃ  <strong>monitor</strong>.</li>
  <li>Go há»— trá»£ logging qua nhiá»u thÆ° viá»‡n ná»•i báº­t:
    <ul>
      <li><strong>logrus</strong>: phá»• biáº¿n, Ä‘Æ¡n giáº£n, dá»… dÃ¹ng.</li>
      <li><strong>zap</strong>: hiá»‡u nÄƒng cao, JSON structured log, production ready.</li>
      <li><strong>zerolog</strong>: tá»‘c Ä‘á»™ cao, encode trá»±c tiáº¿p vÃ o writer.</li>
    </ul>
  </li>
</ul>

<h2>ğŸ” So sÃ¡nh 3 thÆ° viá»‡n phá»• biáº¿n</h2>
<table>
<thead>
<tr><th>ThÆ° viá»‡n</th><th>Æ¯u Ä‘iá»ƒm</th><th>NhÆ°á»£c Ä‘iá»ƒm</th></tr>
</thead>
<tbody>
<tr>
  <td>logrus</td>
  <td>Dá»… dÃ¹ng, phá»• biáº¿n</td>
  <td>Hiá»‡u nÄƒng tháº¥p hÆ¡n (dÃ¹ng reflection)</td>
</tr>
<tr>
  <td>zap</td>
  <td>Structured, nhanh, JSON tá»‘t</td>
  <td>API hÆ¡i verbose</td>
</tr>
<tr>
  <td>zerolog</td>
  <td>Ráº¥t nhanh, binary-safe</td>
  <td>API khÃ¡c biá»‡t, khÃ³ debug náº¿u quen logrus</td>
</tr>
</tbody>
</table>

<h2>ğŸ’¡ VÃ­ dá»¥ sá»­ dá»¥ng logrus</h2>
<pre><code class="go">import log "github.com/sirupsen/logrus"

func main() {
    log.SetFormatter(&log.JSONFormatter{})
    log.SetLevel(log.InfoLevel)

    log.WithFields(log.Fields{
        "user_id":  123,
        "action":   "login",
    }).Info("User logged in")
}
</code></pre>

<h2>ğŸ’¡ VÃ­ dá»¥ zap production logger</h2>
<pre><code class="go">import (
    "go.uber.org/zap"
)

func main() {
    logger, _ := zap.NewProduction()
    defer logger.Sync()

    logger.Info("Xá»­ lÃ½ xong",
        zap.String("user", "abc"),
        zap.Int("duration_ms", 124),
    )
}
</code></pre>

<h2>ğŸ“Œ Best Practice logging</h2>
<ul>
  <li><strong>KhÃ´ng</strong> dÃ¹ng <code>fmt.Println</code> cho production log.</li>
  <li>Sá»­ dá»¥ng logging <strong>structured (JSON)</strong> Ä‘á»ƒ mÃ¡y cÃ³ thá»ƒ parse Ä‘Æ°á»£c.</li>
  <li>Log theo <strong>ngá»¯ cáº£nh</strong>: user, request-id, trace-id (log-enrichment theo context).</li>
  <li>TÃ¡ch <strong>stdout</strong> (info, debug) vÃ  <strong>stderr</strong> (error) náº¿u cháº¡y trong container/Kubernetes.</li>
  <li>Káº¿t há»£p vá»›i tools nhÆ° <code>ELK stack</code>, <code>Grafana Loki</code> Ä‘á»ƒ visualize vÃ  alert.</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> VÃ¬ sao nÃªn dÃ¹ng structured logging thay vÃ¬ <code>fmt.Println</code>?
    <pre><code>Structured logging (dáº¡ng JSON/key-value) cho phÃ©p:
âœ” Dá»… parse & search (qua Elastic, Lokiâ€¦)
âœ” TÃ­ch há»£p alert & trace theo field (e.g. trace_id, user_id)
âœ” Giáº£m lá»—i do thiáº¿u thÃ´ng tin hoáº·c format sai

<code>fmt.Println</code> chá»‰ log string â†’ khÃ´ng phÃ¹ há»£p prod.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh logrus, zap, zerolog â€“ nÃªn dÃ¹ng gÃ¬ trong há»‡ thá»‘ng lá»›n?
    <pre><code>- <strong>logrus</strong>: dá»… dÃ¹ng, phá»• biáº¿n nhÆ°ng cháº­m (dÃ¹ng reflection)
- <strong>zap</strong>: production-ready, high-perf, cÃ³ stack trace, JSON log
- <strong>zerolog</strong>: nhanh nháº¥t, low alloc â€“ nhÆ°ng API khÃ¡c láº¡

Gá»£i Ã½: zap/zerolog cho backend nhiá»u traffic, logrus cho tool/dev.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Log nÃªn chá»©a nhá»¯ng thÃ´ng tin gÃ¬ trong há»‡ thá»‘ng microservice?
    <pre><code>âœ” <strong>Trace ID</strong>, <strong>User ID</strong>, <strong>Request ID</strong>
âœ” TÃªn service + method
âœ” Latency, status code, retry count
âœ” Error + stack trace (náº¿u cÃ³)
âœ” Source IP hoáº·c auth context</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Táº¡i sao cáº§n tÃ¡ch stderr vÃ  stdout khi log trong container?
    <pre><code>âœ” stdout â†’ info/debug log
âœ” stderr â†’ error log (phÃ¢n tÃ­ch alert)

GiÃºp orchestrator (e.g. Kubernetes, Docker) route log Ä‘Ãºng stream â†’ dá»… filter + alerting.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> TÃ­ch há»£p trace-id vÃ o log nhÆ° tháº¿ nÃ o?
    <pre><code>- Gáº¯n <code>trace_id</code> vÃ o context.Context (HTTP hoáº·c gRPC header)
- Log nÃ o cÅ©ng extract tá»« context ra rá»“i inject vÃ o logger
â†’ Äáº£m báº£o trace xuyÃªn suá»‘t toÃ n há»‡ thá»‘ng</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn log toÃ n bá»™ request/response khÃ´ng?
    <pre><code>KhÃ´ng â€“ chá»‰ log khi debug vÃ  <strong>pháº£i mask dá»¯ liá»‡u nháº¡y cáº£m</strong>:
âœ” Token, password
âœ” Sá»‘ tÃ i khoáº£n, email

â†’ DÃ¹ng log level vÃ  scrubber (filter middleware) Ä‘á»ƒ kiá»ƒm soÃ¡t.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao log lá»—i mÃ  váº«n giá»¯ stacktrace?
    <pre><code>- DÃ¹ng <code>zap.Error(err)</code> hoáº·c wrap lá»—i chá»©a stack trace
- Trong panic â†’ log táº¡i <code>recover()</code> kÃ¨m <code>debug.Stack()</code>

â†’ TrÃ¡nh máº¥t context khi log lá»—i táº§ng sÃ¢u.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn log á»Ÿ tá»«ng táº§ng service khÃ´ng? VÃ¬ sao?
    <pre><code>CÃ³ â€“ nhÆ°ng theo chuáº©n:
âœ” Business layer â†’ log input/output logic chÃ­nh
âœ” Infra layer â†’ log error káº¿t ná»‘i, retry
âœ” Middleware â†’ log trace-id, latency, panic recover

â†’ GiÃºp trace theo chiá»u dá»c, khÃ´ng log láº·p.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn log trong goroutine? LÃ m sao giá»¯ Ä‘Æ°á»£c trace-id?
    <pre><code>CÃ³ â€“ nhÆ°ng cáº§n <strong>truyá»n context</strong> vÃ o goroutine Ä‘á»ƒ láº¥y trace-id.

Náº¿u táº¡o goroutine mÃ  khÃ´ng truyá»n Ä‘Ãºng context â†’ log sáº½ thiáº¿u metadata â†’ khÃ³ trace.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡ch Ä‘o hiá»‡u nÄƒng logging trong há»‡ thá»‘ng?
    <pre><code>- DÃ¹ng <code>pprof</code> Ä‘á»ƒ phÃ¢n tÃ­ch chi phÃ­ log
- So sÃ¡nh alloc / GC log giá»¯a logrus/zap/zerolog
- Benchmark log N dÃ²ng/s â€“ xÃ¡c Ä‘á»‹nh bottleneck náº¿u log quÃ¡ nhiá»u</code></pre>
  </li>
</ul>



<hr />
<h1 id="13-testing-benchmark-table-driven-test">13. Testing, Benchmark, Table-Driven Test</h1>

<h2>ğŸ§  Tá»•ng quan testing trong Go</h2>
<ul>
  <li>Go cung cáº¥p testing built-in qua package <code>testing</code>.</li>
  <li>Test file cÃ³ háº­u tá»‘ <code>_test.go</code>, tÃªn hÃ m báº¯t Ä‘áº§u báº±ng <code>Test*</code>.</li>
  <li>Benchmark test dÃ¹ng Ä‘á»ƒ Ä‘o hiá»‡u nÄƒng (<code>Benchmark*</code>).</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥ Ä‘Æ¡n giáº£n</h2>
<pre><code class="go">func Add(a, b int) int {
    return a + b
}

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("expected 5, got %d", result)
    }
}
</code></pre>

<h2>ğŸ§ª Table-Driven Test (pattern chuáº©n)</h2>
<pre><code class="go">func TestAddTable(t *testing.T) {
    cases := []struct {
        name     string
        a, b, out int
    }{
        {"2+3", 2, 3, 5},
        {"-1+1", -1, 1, 0},
    }

    for _, c := range cases {
        t.Run(c.name, func(t *testing.T) {
            res := Add(c.a, c.b)
            if res != c.out {
                t.Errorf("got %d, want %d", res, c.out)
            }
        })
    }
}
</code></pre>

<h2>âš™ Benchmark</h2>
<pre><code class="go">func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = Add(1, 2)
    }
}
</code></pre>

<h2>ğŸ“Œ Tips</h2>
<ul>
  <li>DÃ¹ng <code>go test -v ./...</code> Ä‘á»ƒ test toÃ n bá»™ module.</li>
  <li>DÃ¹ng <code>-bench</code> Ä‘á»ƒ benchmark, <code>-cover</code> Ä‘á»ƒ Ä‘o coverage.</li>
  <li>DÃ¹ng <code>assert</code> libs nhÆ° <code>stretchr/testify</code> khi test lá»›n.</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng Table-Driven Test trong Go?
    <pre><code>Khi test nhiá»u case giá»‘ng nhau nhÆ°ng khÃ¡c input/output:
âœ” Dá»… maintain
âœ” CÃ³ thá»ƒ Ä‘áº·t tÃªn test tá»«ng case (dÃ¹ng <code>t.Run()</code>)
âœ” TrÃ¡nh láº·p code â†’ rÃµ rÃ ng hÆ¡n trong CI/CD</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Benchmark trong Go hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?
    <pre><code>Go sáº½ cháº¡y benchmark láº·p Ä‘i láº·p láº¡i (b.N láº§n) Ä‘á»ƒ láº¥y sá»‘ Ä‘o trung bÃ¬nh:
âœ” Äo CPU time (ns/op)
âœ” Äo sá»‘ láº§n cáº¥p phÃ¡t bá»™ nhá»› (alloc/op)
âœ” CÃ³ thá»ƒ dÃ¹ng <code>b.ReportAllocs()</code> Ä‘á»ƒ hiá»‡n thÃ´ng tin chi tiáº¿t

â†’ DÃ¹ng cho kiá»ƒm thá»­ hiá»‡u nÄƒng function, JSON, DBâ€¦</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Sá»± khÃ¡c biá»‡t giá»¯a <code>t.Fatal()</code> vÃ  <code>t.Error()</code>?
    <pre><code>- <code>t.Fatal()</code>: dá»«ng test hiá»‡n táº¡i â†’ dÃ¹ng khi lá»—i nghiÃªm trá»ng, khÃ´ng thá»ƒ tiáº¿p tá»¥c.
- <code>t.Error()</code>: log lá»—i vÃ  cháº¡y tiáº¿p â†’ phÃ¹ há»£p trong loop hoáº·c nhiá»u check.

â†’ GiÃºp tá»‘i Æ°u feedback trong test report.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao test code cÃ³ goroutine hoáº·c concurrent logic?
    <pre><code>- DÃ¹ng <code>sync.WaitGroup</code> Ä‘á»ƒ chá» táº¥t cáº£ goroutine xong
- DÃ¹ng channel Ä‘á»ƒ collect káº¿t quáº£
- TrÃ¡nh race báº±ng <code>-race</code> flag khi cháº¡y test

â†’ KhÃ´ng dÃ¹ng <code>time.Sleep</code> â€“ khÃ´ng á»•n Ä‘á»‹nh vÃ  cháº­m.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao test function cÃ³ dÃ¹ng context?
    <pre><code>- Táº¡o <code>context.Background()</code> hoáº·c <code>context.WithTimeout</code>
- Gáº¯n <code>trace-id</code> náº¿u cáº§n verify log
- Äáº£m báº£o test khÃ´ng leak goroutine báº±ng <code>ctx.Done()</code> trong worker

â†’ Quan trá»ng trong microservice vÃ  gRPC test.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn mock trong test Go khÃ´ng? Náº¿u cÃ³ thÃ¬ khi nÃ o?
    <pre><code>CÃ³ â€“ nÃªn mock khi:
âœ” Gá»i ra DB, network, Kafka
âœ” KhÃ´ng muá»‘n test logic bÃªn thá»© ba

â†’ DÃ¹ng interface + inject mock, hoáº·c tool nhÆ° <code>gomock</code>, <code>testify/mock</code>.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao test function cÃ³ panic?
    <pre><code>Wrap test trong <code>defer func() { recover() }</code> hoáº·c test log panic:
âœ” Äáº£m báº£o recover hoáº¡t Ä‘á»™ng
âœ” CÃ³ thá»ƒ kiá»ƒm tra ná»™i dung panic

â†’ KhÃ´ng nÃªn Ä‘á»ƒ panic tháº­t xáº£y ra trong test â†’ lÃ m há»ng CI.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡c cÃ´ng cá»¥ nÃ o há»— trá»£ test coverage tá»‘t cho Go?
    <pre><code>- <code>go test -cover</code> â†’ tá»•ng quan
- <code>go tool cover -html=...</code> â†’ hiá»ƒn thá»‹ chi tiáº¿t tá»«ng dÃ²ng
- TÃ­ch há»£p vÃ o CI nhÆ° GitHub Actions, GitLab, Jenkins Ä‘á»ƒ check % tá»‘i thiá»ƒu</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Test nÃ o khÃ´ng nÃªn cháº¡y trong CI/CD?
    <pre><code>- Test cáº§n external dependency: database, Kafkaâ€¦ (náº¿u khÃ´ng mock)
- Test cÃ³ sleep/delay dÃ i
- Benchmark (trá»« khi Ä‘o riÃªng)

â†’ DÃ¹ng tag <code>// +build</code> Ä‘á»ƒ tÃ¡ch test cháº¡y riÃªng hoáº·c manual.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ test private function trong Go khÃ´ng?
    <pre><code>CÃ³ â€“ Ä‘áº·t test trong cÃ¹ng package.

Go khÃ´ng cÃ³ visibility strict nhÆ° Java/C# â†’ test private function báº±ng cÃ¡ch Ä‘áº·t _test.go cÃ¹ng thÆ° má»¥c.</code></pre>
  </li>
</ul>


<hr />
<h1 id="14-debugging-race-condition-deadlock">14. Debugging, Race Condition, Deadlock</h1>

<h2>ğŸ§  KhÃ¡i niá»‡m tá»•ng quÃ¡t</h2>
<ul>
  <li><strong>Race condition</strong>: khi nhiá»u goroutine truy cáº­p/ghi vÃ o vÃ¹ng nhá»› mÃ  khÃ´ng Ä‘á»“ng bá»™ â†’ dá»¯ liá»‡u khÃ´ng nháº¥t quÃ¡n, hÃ nh vi ngáº«u nhiÃªn.</li>
  <li><strong>Deadlock</strong>: khi táº¥t cáº£ goroutine Ä‘á»u block â†’ chÆ°Æ¡ng trÃ¬nh Ä‘á»©ng im vÄ©nh viá»…n.</li>
</ul>

<h2>ğŸ” PhÃ¢n tÃ­ch chuyÃªn sÃ¢u: CÃ¡c lá»—i race phá»• biáº¿n</h2>

<ul>
  <li><strong>1. Ghi/Ä‘á»c vÃ o shared variable mÃ  khÃ´ng cÃ³ lock</strong></li>
  <li><strong>2. Channel write khÃ´ng cÃ³ goroutine nháº­n â†’ block â†’ deadlock</strong></li>
  <li><strong>3. Truy cáº­p slice/map cÃ¹ng lÃºc â†’ race hoáº·c panic</strong></li>
  <li><strong>4. Database tx/context bá»‹ ghi Ä‘Ã¨ qua goroutine</strong></li>
  <li><strong>5. Truy cáº­p pointer khÃ´ng Ä‘á»“ng bá»™</strong></li>
</ul>

<h2>ğŸ’£ VÃ­ dá»¥ lá»—i Race Condition thá»±c táº¿</h2>

<pre><code class="go">// Ghi vÃ o biáº¿n x tá»« nhiá»u goroutine (race)
var x int
for i := 0; i < 100; i++ {
    go func() {
        x++
    }()
}
</code></pre>

<pre><code class="go">// Race khi truy cáº­p slice cÃ¹ng lÃºc
var nums = []int{}
for i := 0; i < 10; i++ {
    go func(val int) {
        nums = append(nums, val) // race!
    }(i)
}
</code></pre>

<pre><code class="go">// Race khi dÃ¹ng cÃ¹ng transaction
func main() {
    tx, _ := db.BeginTx(ctx, nil)

    go func() {
        tx.Exec("UPDATE users SET ...") // lá»—i náº¿u context bá»‹ cancel hoáº·c tx dÃ¹ng sai thread
    }()
}
</code></pre>

<h2>ğŸ§± Deadlock thÆ°á»ng gáº·p</h2>
<pre><code class="go">// Channel khÃ´ng cÃ³ ngÆ°á»i nháº­n â†’ block mÃ£i mÃ£i
ch := make(chan int)
ch <- 1 // block
</code></pre>

<pre><code class="go">// Goroutine chá» nhau theo vÃ²ng trÃ²n
mu1, mu2 := sync.Mutex{}, sync.Mutex{}

go func() {
    mu1.Lock(); defer mu1.Unlock()
    mu2.Lock(); defer mu2.Unlock()
}()

go func() {
    mu2.Lock(); defer mu2.Unlock()
    mu1.Lock(); defer mu1.Unlock()
}()
</code></pre>

<h2>ğŸ” PhÃ¢n tÃ­ch nguyÃªn nhÃ¢n & fix</h2>
<ul>
  <li><code>append()</code> trÃªn slice khÃ´ng Ä‘á»“ng bá»™ cáº§n dÃ¹ng <code>sync.Mutex</code> hoáº·c <code>channel</code> lÃ m queue</li>
  <li>KhÃ´ng chia sáº» <code>tx</code> hoáº·c <code>context</code> giá»¯a goroutine khi xá»­ lÃ½ DB</li>
  <li>KhÃ´ng dÃ¹ng map hoáº·c slice khÃ´ng Ä‘á»“ng bá»™ trong handler gá»‘c</li>
  <li>LuÃ´n close channel á»Ÿ phÃ­a gá»­i; trÃ¡nh close 2 láº§n</li>
</ul>

<h2>ğŸ§ª CÃ¡ch phÃ¡t hiá»‡n bug race/deadlock</h2>
<ul>
  <li>DÃ¹ng <code>go run -race</code> hoáº·c <code>go test -race</code> â†’ hiá»ƒn thá»‹ dÃ²ng code xáº£y ra race</li>
  <li>DÃ¹ng <code>pprof</code> â†’ theo dÃµi goroutine blocking</li>
  <li>DÃ¹ng <code>runtime.NumGoroutine()</code> Ä‘á»ƒ kiá»ƒm soÃ¡t leak</li>
</ul>

<h2>ğŸ“Œ Gá»£i Ã½ ká»¹ thuáº­t há»‡ thá»‘ng</h2>
<ul>
  <li>LuÃ´n xÃ¡c Ä‘á»‹nh biáº¿n shared cáº§n báº£o vá»‡ báº±ng lock hoáº·c truyá»n dá»¯ liá»‡u qua channel</li>
  <li>Truyá»n dá»¯ liá»‡u â†’ dÃ¹ng channel; chia sáº» tráº¡ng thÃ¡i â†’ dÃ¹ng mutex</li>
  <li>TrÃ¡nh close channel tá»« nhiá»u nÆ¡i</li>
  <li>Viáº¿t log theo traceID Ä‘á»ƒ dá»… theo dáº¥u goroutine trong production</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Race condition lÃ  gÃ¬? Khi nÃ o xáº£y ra trong Go?
    <pre><code>Xáº£y ra khi 2+ goroutine truy cáº­p/ghi cÃ¹ng biáº¿n mÃ  khÃ´ng Ä‘á»“ng bá»™ hÃ³a.

â†’ Dáº«n Ä‘áº¿n hÃ nh vi ngáº«u nhiÃªn, dá»¯ liá»‡u sai, crash khÃ³ trace.

VÃ­ dá»¥: update biáº¿n global, slice, map cÃ¹ng lÃºc mÃ  khÃ´ng dÃ¹ng mutex hoáº·c channel.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao detect race condition?
    <pre><code>Cháº¡y Go vá»›i flag: <code>go run -race</code> hoáº·c <code>go test -race</code>.

â†’ In ra vá»‹ trÃ­ Ä‘á»c/ghi trÃ¹ng nhau giá»¯a goroutine â†’ dá»… trace.

Chá»‰ phÃ¡t hiá»‡n Ä‘Æ°á»£c <strong>race thá»±c sá»± xáº£y ra</strong> trong lÃºc cháº¡y â€“ cáº§n Ä‘á»§ load.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Deadlock lÃ  gÃ¬? CÃ³ thá»ƒ xáº£y ra khi nÃ o trong Go?
    <pre><code>Khi táº¥t cáº£ goroutine Ä‘á»u block vÃ  khÃ´ng cÃ²n ai tiáº¿n lÃªn â†’ chÆ°Æ¡ng trÃ¬nh â€œtreoâ€.

ThÆ°á»ng do:
âœ” Gá»­i vÃ o channel mÃ  khÃ´ng ai nháº­n
âœ” Goroutine chá» nhau (mutex vÃ²ng)
âœ” Close channel khÃ´ng Ä‘Ãºng luá»“ng</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Nhá»¯ng kiá»ƒu resource nÃ o dá»… gÃ¢y race trong Go?
    <pre><code>âœ” Map hoáº·c slice (khÃ´ng Ä‘á»“ng bá»™)
âœ” Pointer dÃ¹ng chung
âœ” Counter, biáº¿n tráº¡ng thÃ¡i toÃ n cá»¥c
âœ” context hoáº·c tx cá»§a DB bá»‹ share giá»¯a goroutine</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao xá»­ lÃ½ dá»¯ liá»‡u shared giá»¯a goroutine an toÃ n?
    <pre><code>âœ” DÃ¹ng <code>sync.Mutex</code> hoáº·c <code>sync.RWMutex</code>
âœ” DÃ¹ng channel Ä‘á»ƒ truyá»n dá»¯ liá»‡u thay vÃ¬ chia sáº»
âœ” Náº¿u lÃ  cáº¥u trÃºc lá»›n â€“ clone hoáº·c copy trÆ°á»›c khi dÃ¹ng</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng map trong goroutine? LÃ m sao cho thread-safe?
    <pre><code>Máº·c Ä‘á»‹nh <code>map</code> khÃ´ng thread-safe.

â†’ DÃ¹ng <code>sync.Map</code> hoáº·c lock thá»§ cÃ´ng (mutex) khi cáº§n concurrent read/write.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡ch trÃ¡nh deadlock khi dÃ¹ng mutex?
    <pre><code>âœ” LuÃ´n <code>defer mu.Unlock()</code> ngay sau lock
âœ” TrÃ¡nh lock lá»“ng nhau hoáº·c nhiá»u mutex cÃ¹ng lÃºc
âœ” Náº¿u báº¯t buá»™c dÃ¹ng 2+ mutex â†’ Ä‘á»‹nh nghÄ©a rÃµ thá»© tá»± lock (lock hierarchy)</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao debug goroutine bá»‹ leak hoáº·c stuck?
    <pre><code>âœ” DÃ¹ng <code>pprof</code> + <code>runtime.NumGoroutine()</code> â†’ kiá»ƒm tra sá»‘ lÆ°á»£ng goroutine sá»‘ng
âœ” Gá»­i SIGQUIT â†’ láº¥y full stack trace cá»§a táº¥t cáº£ goroutine
âœ” Log theo trace-id vÃ  tráº¡ng thÃ¡i channel Ä‘á»ƒ trace dÃ²ng cháº£y</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng channel vs mutex?
    <pre><code><strong>Channel</strong>: dÃ¹ng khi truyá»n dá»¯ liá»‡u qua láº¡i giá»¯a goroutine (message passing).
<strong>Mutex</strong>: dÃ¹ng khi nhiá»u goroutine cáº§n cÃ¹ng Ä‘á»c/ghi biáº¿n chung.

Rule:
âœ” Náº¿u chia sáº» â†’ mutex
âœ” Náº¿u trao Ä‘á»•i â†’ channel</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Gá»£i Ã½ ká»¹ thuáº­t nÃ o giÃºp trÃ¡nh bug race trong há»‡ thá»‘ng lá»›n?
    <pre><code>âœ” Wrap shared resource trong struct + lock rÃµ rÃ ng
âœ” Háº¡n cháº¿ dÃ¹ng biáº¿n global
âœ” Viáº¿t test cÃ³ <code>-race</code> + cháº¡y stress test
âœ” Ghi log theo trace-id
âœ” DÃ¹ng context Ä‘á»ƒ lifecycle control (timeout/cancel Ä‘Ãºng cÃ¡ch)</code></pre>
  </li>
</ul>


<hr />
<h1 id="15-memory-management--escape-analysis">15. Memory Management & Escape Analysis</h1>

<h2>ğŸ§  Tá»•ng quan vá» quáº£n lÃ½ bá»™ nhá»› trong Go</h2>
<ul>
  <li>Go sá»­ dá»¥ng <strong>managed memory model</strong> â€“ báº¡n khÃ´ng cáº§n malloc/free thá»§ cÃ´ng.</li>
  <li>Go runtime quyáº¿t Ä‘á»‹nh biáº¿n Ä‘Æ°á»£c cáº¥p phÃ¡t trÃªn stack hay heap.</li>
  <li><strong>Escape Analysis</strong>: quÃ¡ trÃ¬nh xÃ¡c Ä‘á»‹nh biáº¿n cÃ³ â€œthoÃ¡tâ€ khá»i scope hiá»‡n táº¡i khÃ´ng â†’ náº¿u cÃ³ â†’ Ä‘Æ°a lÃªn heap.</li>
</ul>

<h2>ğŸ” Stack vs Heap</h2>
<ul>
  <li><strong>Stack</strong>: nhanh, vÃ¹ng nhá»› táº¡m thá»i, tá»± Ä‘á»™ng reclaim.</li>
  <li><strong>Heap</strong>: cáº¥p phÃ¡t Ä‘á»™ng, cáº§n GC quÃ©t Ä‘á»ƒ reclaim, cháº­m hÆ¡n.</li>
  <li>Escape sang heap = tÄƒng Ã¡p lá»±c GC, giáº£m hiá»‡u nÄƒng.</li>
</ul>

<h2>ğŸ’¡ VÃ­ dá»¥: khi nÃ o biáº¿n escape</h2>
<pre><code class="go">// KhÃ´ng escape - náº±m trÃªn stack
func stackAlloc() int {
    x := 42
    return x
}

// Escape - tráº£ vá» pointer â†’ lÃªn heap
func heapAlloc() *int {
    x := 42
    return &x
}
</code></pre>

<h2>ğŸ§ª Xem káº¿t quáº£ Escape Analysis</h2>
<pre><code class="bash">go build -gcflags="-m" ./main.go
</code></pre>
<p>Káº¿t quáº£:</p>
<pre><code># command-line-arguments
./main.go:10:6: moved to heap: x
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ tá»‘i Æ°u</h2>
<ul>
  <li>TrÃ¡nh tráº£ vá» pointer Ä‘áº¿n local var náº¿u khÃ´ng cáº§n thiáº¿t.</li>
  <li>TrÃ¡nh giá»¯ reference Ä‘áº¿n biáº¿n lá»›n trong closure náº¿u closure sá»‘ng lÃ¢u.</li>
  <li>Chia nhá» function Ä‘á»ƒ giÃºp compiler nháº­n ra vÃ¹ng khÃ´ng cáº§n escape.</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Stack vÃ  Heap khÃ¡c nhau nhÆ° tháº¿ nÃ o trong Go?
    <pre><code><strong>Stack</strong>:
âœ” Nhanh, nhá» (~KB)
âœ” Auto reclaim khi hÃ m káº¿t thÃºc
âœ” DÃ¹ng cho biáº¿n local khÃ´ng escape

<strong>Heap</strong>:
âœ” Lá»›n, cháº­m hÆ¡n
âœ” Cáº§n GC Ä‘á»ƒ giáº£i phÃ³ng
âœ” DÃ¹ng cho biáº¿n escape ra ngoÃ i scope</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Escape Analysis lÃ  gÃ¬? CÃ³ tÃ¡c dá»¥ng gÃ¬?
    <pre><code>Process compiler kiá»ƒm tra biáº¿n cÃ³ â€œthoÃ¡tâ€ khá»i scope khÃ´ng.

âœ” Náº¿u khÃ´ng escape â†’ cáº¥p phÃ¡t trÃªn stack (nhanh hÆ¡n)
âœ” Náº¿u escape â†’ lÃªn heap â†’ GC xá»­ lÃ½

â†’ GiÃºp tá»‘i Æ°u memory vÃ  giáº£m Ã¡p lá»±c GC.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao kiá»ƒm tra biáº¿n cÃ³ bá»‹ escape khÃ´ng?
    <pre><code>Cháº¡y:
<code>go build -gcflags="-m"</code>

â†’ Compiler sáº½ in log:
<code>moved to heap</code> â†’ biáº¿n bá»‹ escape
â†’ CÃ³ thá»ƒ refactor láº¡i code Ä‘á»ƒ trÃ¡nh.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Nhá»¯ng tÃ¬nh huá»‘ng phá»• biáº¿n khiáº¿n biáº¿n escape?
    <pre><code>âœ” Tráº£ vá» pointer Ä‘áº¿n local var
âœ” Closure giá»¯ biáº¿n ngoÃ i scope
âœ” Interface gÃ¡n tá»« biáº¿n concrete
âœ” Sá»­ dá»¥ng reflect, fmt.Sprintf() vá»›i tham chiáº¿u</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn return pointer cá»§a struct khÃ´ng?
    <pre><code>NÃªn náº¿u:
âœ” Struct lá»›n â†’ trÃ¡nh copy
âœ” Sá»‘ng lÃ¢u hoáº·c cáº§n mutate sau khi return

NhÆ°ng pháº£i cÃ¢n nháº¯c escape lÃªn heap vÃ  GC cost.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao trÃ¡nh escape khÃ´ng cáº§n thiáº¿t?
    <pre><code>âœ” DÃ¹ng value thay vÃ¬ pointer náº¿u khÃ´ng mutate
âœ” TrÃ¡nh closure giá»¯ biáº¿n lá»›n
âœ” TrÃ¡nh tráº£ pointer ra ngoÃ i náº¿u khÃ´ng cáº§n
âœ” Sá»­ dá»¥ng func nhá» giÃºp compiler phÃ¢n tÃ­ch tá»‘t hÆ¡n</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Go cÃ³ thá»ƒ inline function khÃ´ng? TÃ¡c Ä‘á»™ng Ä‘áº¿n memory?
    <pre><code>CÃ³. Inline giÃºp giáº£m call overhead vÃ  giÃºp compiler phÃ¢n tÃ­ch escape tá»‘t hÆ¡n.

â†’ Function nhá», khÃ´ng gá»i nhiá»u hÃ m khÃ¡c dá»… Ä‘Æ°á»£c inline.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Cáº¥p phÃ¡t Ä‘á»™ng nhiá»u cÃ³ áº£nh hÆ°á»Ÿng gÃ¬ Ä‘áº¿n GC?
    <pre><code>âœ” TÄƒng heap size â†’ GC cháº¡y nhiá»u hÆ¡n
âœ” Dá»… táº¡o object sá»‘ng lÃ¢u â†’ cost lá»›n hÆ¡n khi mark/sweep
â†’ NÃªn reuse object (e.g. sync.Pool) khi cáº§n.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao kiá»ƒm tra code cÃ³ táº¡o nhiá»u GC pressure?
    <pre><code>âœ” DÃ¹ng <code>pprof</code> â†’ profile alloc
âœ” DÃ¹ng <code>go test -bench -benchmem</code> Ä‘á»ƒ Ä‘o alloc/op
âœ” Kiá»ƒm tra lÆ°á»£ng heap tÄƒng vÃ  thá»i gian GC qua log / Prometheus</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng <code>sync.Pool</code>? Khi nÃ o dÃ¹ng?
    <pre><code>CÃ³ â€“ dÃ¹ng Ä‘á»ƒ reuse object táº¡m thá»i (e.g. buffer, struct lá»›n) giÃºp:
âœ” Giáº£m GC pressure
âœ” TÄƒng performance

KhÃ´ng dÃ¹ng cho object sá»‘ng lÃ¢u hoáº·c mang state quan trá»ng.</code></pre>
  </li>
</ul>



<hr />
<h1 id="16-garbage-collection-vÃ -runtime-scheduler">16. Garbage Collection vÃ  Runtime Scheduler</h1>

<h2>ğŸ§  Tá»•ng quan GC vÃ  Scheduler</h2>
<ul>
  <li><strong>Garbage Collection (GC)</strong>: há»‡ thá»‘ng tá»± Ä‘á»™ng giáº£i phÃ³ng bá»™ nhá»› khÃ´ng cÃ²n dÃ¹ng ná»¯a trÃªn heap.</li>
  <li><strong>Go Scheduler</strong>: cÆ¡ cháº¿ quáº£n lÃ½ goroutine â†’ Ã¡nh xáº¡ M:N (many goroutine â†’ many OS threads).</li>
</ul>

<h2>ğŸ§  GC: cÆ¡ cháº¿, Ä‘áº·c Ä‘iá»ƒm</h2>
<ul>
  <li>Go sá»­ dá»¥ng GC kiá»ƒu <strong>tracing + concurrent + generational</strong>.</li>
  <li>GC khÃ´ng dá»«ng toÃ n bá»™ chÆ°Æ¡ng trÃ¬nh (stop-the-world ráº¥t ngáº¯n).</li>
  <li>KÃ­ch hoáº¡t khi heap lá»›n, runtime trigger, hoáº·c gá»i <code>runtime.GC()</code>.</li>
</ul>

<h2>ğŸ’¡ Scheduler vÃ  GOMAXPROCS</h2>
<ul>
  <li>Scheduler gá»“m:
    <ul>
      <li><strong>G</strong>: Goroutine</li>
      <li><strong>M</strong>: OS Thread</li>
      <li><strong>P</strong>: Processor â€“ phÃ¢n phá»‘i G lÃªn M</li>
    </ul>
  </li>
  <li><code>GOMAXPROCS</code>: giá»›i háº¡n sá»‘ core Go Ä‘Æ°á»£c dÃ¹ng Ä‘á»“ng thá»i.</li>
</ul>

<h2>ğŸ“Œ Tá»‘i Æ°u</h2>
<ul>
  <li>Dá»n reference khÃ´ng dÃ¹ng Ä‘á»ƒ GC thu há»“i nhanh hÆ¡n.</li>
  <li>Háº¡n cháº¿ object lá»›n sá»‘ng lÃ¢u â†’ giáº£m Ã¡p lá»±c GC.</li>
  <li>DÃ¹ng <code>sync.Pool</code> Ä‘á»ƒ reuse object.</li>
</ul>
<h2>ğŸ§  GC hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o (Deep Working)</h2>

<ul>
  <li>Go GC hoáº¡t Ä‘á»™ng theo chu ká»³, gá»“m 3 phase chÃ­nh:
    <ol>
      <li><strong>STW - Stop the World (Prepare)</strong>: táº¡m dá»«ng toÃ n bá»™ goroutine Ä‘á»ƒ xÃ¡c Ä‘á»‹nh root set.</li>
      <li><strong>Mark phase (concurrent)</strong>: Ä‘Ã¡nh dáº¥u táº¥t cáº£ object cÃ²n Ä‘Æ°á»£c tham chiáº¿u.</li>
      <li><strong>Sweep phase</strong>: thu dá»n object khÃ´ng cÃ²n dÃ¹ng, tráº£ láº¡i heap.</li>
    </ol>
  </li>

  <li>STW diá»…n ra ngáº¯n (~100Âµs), sau Ä‘Ã³ goroutine tiáº¿p tá»¥c cháº¡y song song vá»›i phase mark.</li>
  <li>GC sá»­ dá»¥ng <strong>tri-color marking</strong>: white (chÆ°a quÃ©t), grey (Ä‘ang quÃ©t), black (quÃ©t xong).</li>
  <li>Æ¯u tiÃªn dá»n object nhá», ngáº¯n háº¡n (young gen) â€“ giá»‘ng generational GC trong JVM.</li>
</ul>

<h2>â± Khi nÃ o GC Ä‘Æ°á»£c trigger?</h2>
<ul>
  <li>Heap growth vÆ°á»£t ngÆ°á»¡ng (<code>GOGC</code> % growth)</li>
  <li>Manually gá»i <code>runtime.GC()</code></li>
  <li>TrÃ¬nh runtime tháº¥y tá»· lá»‡ goroutine idle phÃ¹ há»£p</li>
</ul>

<h2>âš™ Tham sá»‘ Ä‘iá»u chá»‰nh GC</h2>
<ul>
  <li><code>GOGC</code>: tá»‰ lá»‡ tÄƒng heap Ä‘á»ƒ kÃ­ch hoáº¡t GC (default 100 â†’ GC cháº¡y khi heap gáº¥p Ä‘Ã´i)</li>
  <li>Set <code>GOGC=off</code> Ä‘á»ƒ disable GC (chá»‰ dÃ¹ng khi debug)</li>
</ul>

<h2>ğŸ“Œ áº¢nh hÆ°á»Ÿng há»‡ thá»‘ng & Tá»‘i Æ°u</h2>
<ul>
  <li>GC cÃ ng cháº¡y thÆ°á»ng xuyÃªn â†’ giáº£m memory usage nhÆ°ng tá»‘n CPU.</li>
  <li>GC cháº¡y Ã­t â†’ tÄƒng latency request do heap phÃ¬nh to.</li>
  <li><strong>Optimize:</strong>
    <ul>
      <li>TrÃ¡nh return pointer â†’ giá»¯ stack allocation</li>
      <li>Dá»n nil object sá»›m (giÃºp mark nhanh)</li>
      <li>DÃ¹ng <code>sync.Pool</code> Ä‘á»ƒ giáº£m new()</li>
    </ul>
  </li>
</ul>



<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Garbage Collector (GC) trong Go hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?
    <pre><code>GC trong Go lÃ  dáº¡ng:
âœ” Tracing â†’ tÃ¬m object Ä‘Æ°á»£c tham chiáº¿u
âœ” Concurrent â†’ cháº¡y song song vá»›i goroutine
âœ” Generational â†’ Æ°u tiÃªn dá»n object má»›i

Chu ká»³ gá»“m:
1. STW (Stop The World): xÃ¡c Ä‘á»‹nh root
2. Mark (concurrent): Ä‘Ã¡nh dáº¥u object cÃ²n sá»‘ng
3. Sweep: thu há»“i vÃ¹ng nhá»› khÃ´ng cÃ²n dÃ¹ng</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> GOGC lÃ  gÃ¬? áº¢nh hÆ°á»Ÿng nhÆ° tháº¿ nÃ o Ä‘áº¿n GC?
    <pre><code><code>GOGC</code> lÃ  tá»‰ lá»‡ tÄƒng heap Ä‘á»ƒ kÃ­ch hoáº¡t GC (default = 100):
âœ” GOGC=100 â†’ khi heap tÄƒng 100% â†’ GC cháº¡y
âœ” GOGC tháº¥p â†’ GC cháº¡y thÆ°á»ng xuyÃªn hÆ¡n (CPU tá»‘n), heap nhá»
âœ” GOGC cao â†’ Ã­t GC, heap lá»›n hÆ¡n (RAM nhiá»u)

â†’ Tuá»³ chá»n theo profile CPU/RAM há»‡ thá»‘ng.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o GC Ä‘Æ°á»£c trigger?
    <pre><code>âœ” Heap vÆ°á»£t ngÆ°á»¡ng tÄƒng cá»§a GOGC
âœ” Manual gá»i <code>runtime.GC()</code>
âœ” Go runtime cáº£m nháº­n load phÃ¹ há»£p
âœ” Khi khÃ´ng cÃ²n goroutine active (idle state)</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng <code>runtime.GC()</code> khÃ´ng?
    <pre><code>Chá»‰ dÃ¹ng khi tháº­t sá»± cáº§n:
âœ” Benchmark test Ä‘á»ƒ Ä‘o clean memory
âœ” Khi biáº¿t rÃµ thá»i Ä‘iá»ƒm muá»‘n quÃ©t sáº¡ch trÆ°á»›c khi process lá»›n

KhÃ´ng dÃ¹ng trong code production thÆ°á»ng xuyÃªn â†’ áº£nh hÆ°á»Ÿng performance.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Nhá»¯ng ká»¹ thuáº­t tá»‘i Æ°u giÃºp giáº£m Ã¡p lá»±c GC?
    <pre><code>âœ” TrÃ¡nh cáº¥p phÃ¡t Ä‘á»™ng khÃ´ng cáº§n thiáº¿t
âœ” DÃ¹ng <code>sync.Pool</code> Ä‘á»ƒ reuse object
âœ” XoÃ¡ reference object sá»›m (gÃ¡n nil)
âœ” TrÃ¡nh giá»¯ object lÃ¢u trong closure hoáº·c global</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Runtime scheduler cá»§a Go lÃ  gÃ¬? LÃ m viá»‡c ra sao?
    <pre><code>LÃ  há»‡ thá»‘ng M:N scheduler:
âœ” G: Goroutine
âœ” M: OS Thread
âœ” P: Processor (runtime logical processor)

â†’ P lÃªn lá»‹ch G cháº¡y trÃªn M. P nhiá»u = nhiá»u goroutine xá»­ lÃ½ song song.
â†’ GOMAXPROCS Ä‘iá»u chá»‰nh sá»‘ P (sá»‘ core dÃ¹ng).</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> GOMAXPROCS lÃ  gÃ¬? CÃ³ áº£nh hÆ°á»Ÿng gÃ¬?
    <pre><code><code>GOMAXPROCS</code> = sá»‘ core logic Go sá»­ dá»¥ng song song:
âœ” Default = runtime.NumCPU()
âœ” TÄƒng/lÃ m giáº£m concurrency xá»­ lÃ½
âœ” CÃ³ thá»ƒ Ä‘iá»u chá»‰nh Ä‘á»ƒ kiá»ƒm soÃ¡t load CPU

â†’ DÃ¹ng <code>runtime.GOMAXPROCS(N)</code> Ä‘á»ƒ thiáº¿t láº­p.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Go quáº£n lÃ½ goroutine nhÆ° tháº¿ nÃ o?
    <pre><code>âœ” Goroutine ráº¥t nháº¹ (~2KB stack)
âœ” Khi block I/O â†’ runtime chuyá»ƒn goroutine khÃ¡c lÃªn thread
âœ” Stack tá»± Ä‘á»™ng grow/shrink â†’ trÃ¡nh lá»—i stack overflow
âœ” Scheduler chuyá»ƒn goroutine liÃªn tá»¥c (preemptive)</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> GC cÃ³ áº£nh hÆ°á»Ÿng Ä‘áº¿n latency khÃ´ng? LÃ m sao háº¡n cháº¿?
    <pre><code>CÃ³. DÃ¹ GC concurrent, nhÆ°ng váº«n cÃ³ STW (ngáº¯n).

â†’ Náº¿u object lá»›n hoáº·c quÃ¡ nhiá»u â†’ mark cháº­m, sweep tá»‘n time â†’ tÄƒng latency.
âœ” DÃ¹ng buffer object
âœ” Giáº£m alloc per request
âœ” Xem log GC hoáº·c Prometheus GC time</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Dáº¥u hiá»‡u nÃ o cho tháº¥y há»‡ thá»‘ng bá»‹ GC pressure?
    <pre><code>âœ” TÄƒng Ä‘á»™t biáº¿n GC pause time
âœ” Sá»‘ láº§n GC nhiá»u báº¥t thÆ°á»ng
âœ” CPU cao nhÆ°ng throughput tháº¥p
âœ” Memory graph "sawtooth" dÃ y Ä‘áº·c

â†’ PhÃ¢n tÃ­ch báº±ng pprof hoáº·c Prometheus + grafana</code></pre>
  </li>
</ul>


<hr />
<h1 id="17-build-system-vÃ -cross-compilation">17. Build System vÃ  Cross Compilation</h1>

<h2>ğŸ§  Tá»•ng quan há»‡ thá»‘ng build trong Go</h2>
<ul>
  <li>Go dÃ¹ng command line tool `go build` Ä‘á»ƒ biÃªn dá»‹ch source code thÃ nh binary standalone.</li>
  <li>KhÃ´ng cáº§n makefile, khÃ´ng cáº§n linker script â€“ táº¥t cáº£ Ä‘Æ°á»£c tÃ­ch há»£p sáºµn trong Go toolchain.</li>
</ul>

<h2>ğŸ” CÆ¡ cháº¿ hoáº¡t Ä‘á»™ng build</h2>
<ul>
  <li><code>go build</code> thá»±c hiá»‡n:
    <ol>
      <li>PhÃ¢n tÃ­ch dependency tá»« <code>import</code></li>
      <li>Resolve module qua <code>go.mod</code></li>
      <li>Compile tá»«ng package â†’ assemble â†’ link thÃ nh binary</li>
    </ol>
  </li>
  <li>Build output lÃ  binary tá»± Ä‘á»§ (no external runtime needed)</li>
</ul>

<h2>ğŸŒ Cross Compilation</h2>
<ul>
  <li>Go há»— trá»£ cross-build máº·c Ä‘á»‹nh â€“ chá»‰ cáº§n set biáº¿n mÃ´i trÆ°á»ng:</li>
</ul>
<pre><code class="bash">GOOS=linux GOARCH=amd64 go build -o app-linux
GOOS=windows GOARCH=386 go build -o app.exe
</code></pre>

<h2>ğŸ“Œ áº¢nh hÆ°á»Ÿng há»‡ thá»‘ng & Tá»‘i Æ°u</h2>
<ul>
  <li>Go build nhanh, khÃ´ng cáº§n toolchain ngoÃ i â†’ phÃ¹ há»£p CI/CD realtime.</li>
  <li>Binary Go tá»± Ä‘á»§ â†’ deploy cá»±c ká»³ dá»… dÃ ng.</li>
  <li>Dá»n dependency báº±ng <code>go mod tidy</code> Ä‘á»ƒ build sáº¡ch vÃ  nháº¹ hÆ¡n.</li>
</ul>


<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Go biÃªn dá»‹ch code nhÆ° tháº¿ nÃ o? CÃ³ qua linker khÃ´ng?
    <pre><code>CÃ³. <code>go build</code> thá»±c hiá»‡n:
1. PhÃ¢n tÃ­ch dependency tá»« <code>import</code>
2. Compile tá»«ng package riÃªng biá»‡t
3. DÃ¹ng linker tÃ­ch há»£p Ä‘á»ƒ build ra binary

â†’ Binary lÃ  static, standalone â€“ khÃ´ng cáº§n external runtime.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Sá»± khÃ¡c biá»‡t giá»¯a <code>go run</code> vÃ  <code>go build</code> lÃ  gÃ¬?
    <pre><code><code>go run</code>: build táº¡m vÃ  cháº¡y (file binary á»Ÿ /tmp)
<code>go build</code>: build binary vÄ©nh viá»…n â†’ deploy, debug, profile

â†’ <code>go run</code> phÃ¹ há»£p test nhanh, <code>go build</code> dÃ¹ng cho release.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao Ä‘á»ƒ build cho há»‡ Ä‘iá»u hÃ nh khÃ¡c?
    <pre><code>Set biáº¿n mÃ´i trÆ°á»ng:
<code>GOOS</code>: OS (linux, windows, darwin)
<code>GOARCH</code>: CPU arch (amd64, arm64, 386,...)

VÃ­ dá»¥:
<code>GOOS=linux GOARCH=amd64 go build -o app</code></code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ build Go binary khÃ´ng cÃ³ symbol/debug info?
    <pre><code>CÃ³. DÃ¹ng flags:
<code>go build -ldflags="-s -w"</code>

âœ” <code>-s</code>: bá» symbol table
âœ” <code>-w</code>: bá» DWARF (debug info)

â†’ Binary nhá» hÆ¡n â†’ tá»‘t cho release.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ cáº§n Makefile khi build Go project khÃ´ng?
    <pre><code>KhÃ´ng báº¯t buá»™c. Go Ä‘Ã£ cÃ³ toolchain tÃ­ch há»£p:
âœ” Dependency resolved qua <code>go.mod</code>
âœ” Lá»‡nh build/test/format/lint Ä‘á»u CLI native

â†’ NhÆ°ng Makefile váº«n há»¯u Ã­ch khi cáº§n orchestration nhiá»u bÆ°á»›c hoáº·c multi target.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao kiá»ƒm tra version Go cá»§a 1 project?
    <pre><code>Kiá»ƒm tra file <code>go.mod</code> â†’ dÃ²ng <code>go 1.21</code>
â†’ ÄÃ¢y lÃ  minimal version required (used for stdlib + syntax).</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Build Go image nhá» trong Docker nhÆ° tháº¿ nÃ o?
    <pre><code>DÃ¹ng multi-stage build:
1. Base: build binary
2. Final: copy binary vÃ o image nháº¹ (e.g. <code>alpine</code>)

â†’ VÃ­ dá»¥:
FROM golang:1.21 AS builder  
WORKDIR /app  
COPY . .  
RUN go build -o main  

FROM alpine  
COPY --from=builder /app/main /main  
ENTRYPOINT ["/main"]
</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ build plugin Ä‘á»™ng (shared object) trong Go khÃ´ng?
    <pre><code>CÃ³ â€“ dÃ¹ng:
<code>go build -buildmode=plugin</code>

â†’ NhÆ°ng chá»‰ há»— trá»£ Linux, khÃ³ debug vÃ  cÃ³ nhiá»u háº¡n cháº¿ â†’ khÃ´ng phá»• biáº¿n production.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao verify má»™t binary build cÃ³ Ä‘á»§ symbol/debug cho pprof?
    <pre><code>Cháº¡y:
<code>go tool nm ./your_binary</code> â†’ kiá»ƒm tra symbol table

Náº¿u bá»‹ strip (-ldflags="-s -w") â†’ khÃ´ng dÃ¹ng Ä‘Æ°á»£c pprof/tracing tá»‘t.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Nhá»¯ng tip Ä‘á»ƒ tá»‘i Æ°u tá»‘c Ä‘á»™ build Go project lá»›n?
    <pre><code>âœ” DÃ¹ng module riÃªng cho tá»«ng repo (module split)
âœ” TrÃ¡nh import vÃ²ng
âœ” Dá»n go.mod</code> báº±ng <code>go mod tidy</code>
âœ” Cache build trong CI/CD (e.g. GitHub Actions, GitLab)
âœ” TrÃ¡nh dÃ¹ng CGO náº¿u khÃ´ng cáº§n</code></pre>
  </li>
</ul>



<hr />
<h1 id="18-generics-type-parameter-vÃ -constraint">18. Generics: Type Parameter vÃ  Constraint</h1>

<h2>ğŸ§  Tá»•ng quan vá» Generics trong Go</h2>
<ul>
  <li>Go há»— trá»£ generics tá»« báº£n <strong>1.18+</strong> thÃ´ng qua <strong>type parameter</strong>.</li>
  <li>Generics giÃºp báº¡n viáº¿t function, struct, method cÃ³ kháº£ nÄƒng tÃ¡i sá»­ dá»¥ng, nhÆ°ng váº«n giá»¯ <strong>type-safety</strong>.</li>
  <li>KhÃ´ng cÃ²n cáº§n Ã©p kiá»ƒu báº±ng interface trá»‘ng hay code láº·p cho tá»«ng kiá»ƒu.</li>
</ul>

<h2>ğŸ” Tá»•ng há»£p cÃ¡c loáº¡i Ã¡p dá»¥ng generics</h2>
<table>
<thead>
<tr><th>Loáº¡i</th><th>Ãp dá»¥ng</th><th>VÃ­ dá»¥</th></tr>
</thead>
<tbody>
<tr>
  <td><strong>Function</strong></td>
  <td>HÃ m dÃ¹ng chung cho nhiá»u kiá»ƒu</td>
  <td><code>func Equal[T comparable](a, b T)</code></td>
</tr>
<tr>
  <td><strong>Struct</strong></td>
  <td>Generic container, cache, stack...</td>
  <td><code>type Stack[T any]</code></td>
</tr>
<tr>
  <td><strong>Map</strong></td>
  <td>KhÃ´ng generic trá»±c tiáº¿p<br>nhÆ°ng cÃ³ thá»ƒ wrap qua struct</td>
  <td><code>type Store[K comparable, V any]</code></td>
</tr>
<tr>
  <td><strong>Slice</strong></td>
  <td>DÃ¹ng tá»‘t vá»›i hÃ m <code>Filter</code>, <code>Map</code>, <code>Reduce</code></td>
  <td><code>func Filter[T any](in []T, fn func(T) bool)</code></td>
</tr>
<tr>
  <td><strong>Interface</strong></td>
  <td>Gáº¯n constraint Ä‘á»ƒ enforce behavior</td>
  <td><code>type Adder[T any] interface { Add(T) T }</code></td>
</tr>
<tr>
  <td><strong>Function type</strong></td>
  <td>Generics Ã¡p dá»¥ng cho callback/higher order</td>
  <td><code>func Map[T any, R any](in []T, f func(T) R)</code></td>
</tr>
</tbody>
</table>

<h2>ğŸ“¦ VÃ­ dá»¥ tá»•ng há»£p Ã¡p dá»¥ng thá»±c táº¿</h2>

<pre><code class="go">// Generic function
func Max[T constraints.Ordered](a, b T) T {
    if a > b { return a }
    return b
}

// Generic struct
type Cache[K comparable, V any] struct {
    store map[K]V
}

// Generic slice operator
func Filter[T any](in []T, predicate func(T) bool) []T {
    var out []T
    for _, v := range in {
        if predicate(v) {
            out = append(out, v)
        }
    }
    return out
}
</code></pre>

<h2>ğŸ§  Vá» constraints</h2>
<ul>
  <li><code>any</code>: Ä‘áº¡i diá»‡n cho táº¥t cáº£ cÃ¡c kiá»ƒu</li>
  <li><code>comparable</code>: dÃ¹ng cho key map, so sÃ¡nh <code>==</code>, <code>!=</code></li>
  <li><code>constraints.Ordered</code>: dÃ¹ng cho kiá»ƒu cÃ³ thá»ƒ <code>&lt;, &gt;</code></li>
  <li>CÃ³ thá»ƒ Ä‘á»‹nh nghÄ©a <strong>interface constraint riÃªng</strong> náº¿u muá»‘n enforce method</li>
</ul>

<h2>ğŸ§  Æ¯u Ä‘iá»ƒm vÆ°á»£t trá»™i</h2>
<ul>
  <li>Loáº¡i bá» láº·p code cho má»—i kiá»ƒu</li>
  <li>Äáº£m báº£o type safety mÃ  khÃ´ng cáº§n interface{} + type assertion</li>
  <li>Gáº§n hÆ¡n vá»›i expressive pattern cá»§a functional programming</li>
</ul>

<h2>âš ï¸ Báº¥t lá»£i vÃ  giá»›i háº¡n hiá»‡n táº¡i</h2>
<ul>
  <li>KhÃ´ng cÃ³ runtime type inference hoáº·c reflection trÃªn T</li>
  <li>KhÃ´ng thá»ƒ dÃ¹ng toÃ¡n tá»­ tÃ¹y Ã½ (ngoÃ i constraint)</li>
  <li>Dá»… láº¡m dá»¥ng â†’ code khÃ³ Ä‘á»c, debug kÃ©m</li>
  <li>KhÃ´ng tÆ°Æ¡ng thÃ­ch tá»‘t vá»›i táº¥t cáº£ third-party lib</li>
</ul>

<h2>ğŸ“Œ Gá»£i Ã½ khi dÃ¹ng generics trong há»‡ thá»‘ng</h2>
<ul>
  <li>DÃ¹ng cho lib xá»­ lÃ½ collection: Pagination, Filter, Sorting...</li>
  <li>TrÃ¡nh dÃ¹ng generics trong API layer hoáº·c business logic Ä‘áº·c thÃ¹</li>
  <li>Viáº¿t constraint rÃµ rÃ ng Ä‘á»ƒ code dá»… Ä‘á»c, khÃ´ng Ä‘á»ƒ <code>[T any]</code> quÃ¡ rá»™ng</li>
  <li>DÃ¹ng generics káº¿t há»£p interface Ä‘á»ƒ enforce behavior rÃµ rÃ ng</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Go há»— trá»£ Generics tá»« phiÃªn báº£n nÃ o? VÃ¬ sao trÆ°á»›c Ä‘Ã¢y khÃ´ng cÃ³?
    <pre><code>Tá»« Go 1.18+
TrÆ°á»›c Ä‘Ã¢y Go Æ°u tiÃªn Ä‘Æ¡n giáº£n, explicit type, trÃ¡nh runtime generic â†’ khÃ³ maintain.
Generics thÃªm vÃ o Ä‘á»ƒ tÄƒng reusability nhÆ°ng váº«n giá»¯ compile-time safety.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Generics cÃ³ thá»ƒ Ã¡p dá»¥ng cho nhá»¯ng loáº¡i nÃ o?
    <pre><code>âœ” Function: <code>func[T any](a T) T</code>
âœ” Struct: <code>type Box[T any] struct</code>
âœ” Method receiver
âœ” Interface constraint
KhÃ´ng Ã¡p dá»¥ng cho constant/generic enum.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>comparable</code> vÃ  <code>constraints.Ordered</code> khÃ¡c gÃ¬ nhau?
    <pre><code><strong>comparable</strong>: há»— trá»£ <code>==</code>, <code>!=</code> (dÃ¹ng lÃ m key map, so sÃ¡nh Ä‘Æ¡n giáº£n)

<strong>Ordered</strong>: há»— trá»£ <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> (sáº¯p xáº¿p Ä‘Æ°á»£c)
â†’ Ordered bao gá»“m: int, float, string</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ dÃ¹ng Generics cho interface Ä‘Æ°á»£c khÃ´ng?
    <pre><code>CÃ³ â€“ Ä‘á»‹nh nghÄ©a interface constraint:
<code>type Adder[T any] interface { Add(T) T }</code>

â†’ Ãp dá»¥ng cho struct, func muá»‘n enforce method cá»¥ thá»ƒ.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Æ¯u Ä‘iá»ƒm vÃ  báº¥t lá»£i cá»§a Generics trong Go lÃ  gÃ¬?
    <pre><code><strong>Æ¯u Ä‘iá»ƒm:</strong>
âœ” Reuse code vá»›i type safety
âœ” KhÃ´ng cáº§n dÃ¹ng interface{} + type assertion
âœ” Gáº§n vá»›i functional pattern (map/filter)

<strong>NhÆ°á»£c Ä‘iá»ƒm:</strong>
âœ˜ CÃº phÃ¡p dÃ i, khÃ³ Ä‘á»c khi lá»“ng nhau
âœ˜ IDE/debug support chÆ°a tá»‘t
âœ˜ KhÃ´ng há»— trá»£ táº¥t cáº£ pattern nhÆ° overloading</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Generics compile thÃ nh code nhÆ° tháº¿ nÃ o? CÃ³ bá»‹ táº¡o nhiá»u version khÃ´ng?
    <pre><code>Go sá»­ dá»¥ng <strong>monomorphization partial</strong>:
âœ” Vá»›i type cá»¥ thá»ƒ: táº¡o version riÃªng (nhÆ° template C++)
âœ” Vá»›i interface hoáº·c <code>any</code>: dÃ¹ng 1 version dÃ¹ng interface runtime

â†’ KhÃ´ng táº¡o quÃ¡ nhiá»u binary bloating nhÆ° C++, nhÆ°ng váº«n Ä‘áº£m báº£o type safety.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng Generics, khi nÃ o nÃªn trÃ¡nh?
    <pre><code><strong>DÃ¹ng:</strong>
âœ” Collection utilities: Map, Filter, Stack, Pagination...
âœ” Logic xá»­ lÃ½ data khÃ´ng phá»¥ thuá»™c type
âœ” Middleware reusable

<strong>TrÃ¡nh:</strong>
âœ˜ Business logic Ä‘áº·c thÃ¹
âœ˜ Giao diá»‡n API public â†’ khÃ´ng rÃµ rÃ ng
âœ˜ Khi cáº§n reflection hoáº·c serialization phá»©c táº¡p</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ gá»i method cá»¥ thá»ƒ trÃªn type param khÃ´ng?
    <pre><code>Chá»‰ khi constraint interface khai bÃ¡o method Ä‘Ã³:
<code>type JSONable interface { MarshalJSON() ([]byte, error) }</code>
<code>func ToJSON[T JSONable](v T) []byte</code>

â†’ Náº¿u <code>T any</code>, khÃ´ng thá»ƒ gá»i method vÃ¬ khÃ´ng biáº¿t method tá»“n táº¡i.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Generics cÃ³ thá»ƒ káº¿t há»£p vá»›i <code>sync.Pool</code> hay channel khÃ´ng?
    <pre><code>âœ” CÃ³ thá»ƒ táº¡o <code>GenericPool[T any]</code> bá»c <code>sync.Pool</code> â†’ há»— trá»£ reuse object theo kiá»ƒu cá»¥ thá»ƒ
âœ” Channel hiá»‡n khÃ´ng há»— trá»£ generic type param cho type channel declaration</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ cáº§n viáº¿t test cho tá»«ng type khi dÃ¹ng Generics khÃ´ng?
    <pre><code>KhÃ´ng báº¯t buá»™c, nhÆ°ng <strong>nÃªn test cÃ¡c type phá»• biáº¿n</strong> Ä‘á»ƒ Ä‘áº£m báº£o logic Ä‘Ãºng theo constraint.
â†’ Table-driven test nÃªn dÃ¹ng nhiá»u case type khÃ¡c nhau.</code></pre>
  </li>
</ul>



<hr />
<h1 id="19-api--middleware-rest-grpc-interceptor">19. API & Middleware: REST, gRPC, Interceptor</h1>

<h2>ğŸ§  So sÃ¡nh HTTP vs gRPC</h2>
<table>
<thead>
<tr><th>TiÃªu chÃ­</th><th>HTTP REST</th><th>gRPC</th></tr>
</thead>
<tbody>
<tr><td>Protocol</td><td>HTTP/1.1, JSON</td><td>HTTP/2, Protocol Buffers</td></tr>
<tr><td>Contract</td><td>KhÃ´ng rÃ ng buá»™c (OpenAPI optional)</td><td>Strict contract qua .proto</td></tr>
<tr><td>Serialization</td><td>Text (JSON)</td><td>Binary (Protobuf) â€“ nhanh hÆ¡n</td></tr>
<tr><td>Streaming</td><td>KhÃ³ / chunked encoding</td><td>Built-in (client, server, bidi)</td></tr>
<tr><td>Tooling</td><td>Curl, Postman</td><td>grpcurl, Evans, protobuf compiler</td></tr>
<tr><td>Use case</td><td>Public API, Gateway, dá»… debug</td><td>Service internal, high perf</td></tr>
</tbody>
</table>

<h2>ğŸ§° CÃ¡c thÆ° viá»‡n phá»• biáº¿n</h2>
<ul>
  <li><code>net/http</code>: core lib, á»•n Ä‘á»‹nh, native middleware</li>
  <li><code>gin</code>: nhanh, cÃ³ middleware, bind JSON dá»…</li>
  <li><code>echo</code>: giá»‘ng gin, thÃªm nhiá»u tiá»‡n Ã­ch: group, context-rich</li>
  <li><code>grpc-go</code>: lib chÃ­nh thá»‘ng gRPC tá»« Google</li>
</ul>

<h2>ğŸ“¦ Middleware lÃ  gÃ¬?</h2>
<ul>
  <li>HÃ m bao ngoÃ i handler chÃ­nh â†’ xá»­ lÃ½ logic phá»¥: auth, log, recovery...</li>
  <li>DÃ¹ng chain Ä‘á»ƒ xÃ¢y dá»±ng pipeline xá»­ lÃ½ request.</li>
</ul>

<pre><code class="go">// Middleware trong gin
func AuthMiddleware(c *gin.Context) {
    token := c.GetHeader("Authorization")
    if token == "" {
        c.AbortWithStatus(401)
        return
    }
    c.Next()
}
</code></pre>

<h2>ğŸ”§ gRPC: cáº¥u trÃºc vÃ  generate code</h2>
<pre><code class="proto">syntax = "proto3";

package helloworld;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}
message HelloReply {
  string message = 1;
}
</code></pre>

<pre><code class="bash"># Generate Go code
protoc --go_out=. --go-grpc_out=. example.proto
</code></pre>

<h2>ğŸ’¬ Interceptor (gRPC middleware)</h2>
<ul>
  <li>Interceptor lÃ  middleware cho gRPC â€“ hoáº¡t Ä‘á»™ng trÆ°á»›c/sau RPC logic.</li>
  <li>Ãp dá»¥ng cho: logging, tracing, recovery, auth, inject header...</li>
  <li>Chia 2 loáº¡i: <code>UnaryInterceptor</code> vÃ  <code>StreamInterceptor</code></li>
</ul>

<pre><code class="go">func UnaryLogger(
    ctx context.Context,
    req interface{},
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (resp interface{}, err error) {
    log.Println("RPC:", info.FullMethod)
    return handler(ctx, req)
}
</code></pre>

<h2>ğŸ“¬ Header / Metadata truyá»n trong gRPC</h2>
<pre><code class="go">// Client gá»­i header
md := metadata.Pairs("x-trace-id", "abc123")
ctx := metadata.NewOutgoingContext(context.Background(), md)

// Server Ä‘á»c header
md, ok := metadata.FromIncomingContext(ctx)
traceID := md["x-trace-id"]
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li>REST phÃ¹ há»£p public API, dá»… debug.</li>
  <li>gRPC phÃ¹ há»£p ná»™i bá»™ â†’ high throughput, stream.</li>
  <li>DÃ¹ng interceptor Ä‘á»ƒ khÃ´ng viáº¿t láº¡i logging/auth/tracing á»Ÿ má»i handler.</li>
  <li>Header/metadata giÃºp trace qua nhiá»u service â€“ nháº¥t lÃ  trong há»‡ thá»‘ng microservice.</li>
</ul>
<h2>ğŸ§  CÃ¡c loáº¡i RPC trong gRPC</h2>
<ul>
  <li><strong>Unary RPC</strong>: 1 request â†’ 1 response (giá»‘ng HTTP truyá»n thá»‘ng)</li>
  <li><strong>Server Streaming</strong>: 1 request â†’ nhiá»u response (client Ä‘á»c liÃªn tá»¥c)</li>
  <li><strong>Client Streaming</strong>: nhiá»u request â†’ 1 response (client gá»­i liÃªn tá»¥c rá»“i server tráº£ káº¿t quáº£)</li>
  <li><strong>Bidirectional Streaming</strong>: nhiá»u request â†” nhiá»u response (giá»‘ng WebSocket)</li>
</ul>

<pre><code class="proto">service Chat {
  rpc SendMessage (Message) returns (Ack);               // Unary
  rpc StreamMessages (Room) returns (stream Message);    // Server Stream
  rpc UploadFile (stream Chunk) returns (UploadStatus);  // Client Stream
  rpc ChatStream (stream Message) returns (stream Message); // BiDi Stream
}
</code></pre>

<h2>ğŸ“¦ REST vs gRPC: Body vÃ  Serialization</h2>
<table>
<thead>
<tr><th>Aspect</th><th>REST (JSON)</th><th>gRPC (Protobuf)</th></tr>
</thead>
<tbody>
<tr><td>Request/Response</td><td>Body lÃ  JSON (text)</td><td>Binary protobuf</td></tr>
<tr><td>Size</td><td>Lá»›n hÆ¡n vÃ¬ nhiá»u kÃ½ tá»± vÃ  field name</td><td>Nhá» hÆ¡n nhá» encoding</td></tr>
<tr><td>Speed</td><td>Parse cháº­m hÆ¡n, dá»… debug</td><td>Parse nhanh hÆ¡n, khÃ³ debug báº±ng tay</td></tr>
<tr><td>Streaming</td><td>KhÃ³, cáº§n chunked/long polling</td><td>Built-in stream HTTP/2</td></tr>
</tbody>
</table>

<h2>ğŸ”— Giao tiáº¿p giá»¯a cÃ¡c service (microservice)</h2>
<ul>
  <li>gRPC Ä‘Æ°á»£c tá»‘i Æ°u Ä‘á»ƒ dÃ¹ng giá»¯a cÃ¡c service trong ná»™i bá»™:</li>
  <li>
    Æ¯u Ä‘iá»ƒm:
    <ul>
      <li>Strict schema (protoc)</li>
      <li>Compact binary â†’ tiáº¿t kiá»‡m bÄƒng thÃ´ng</li>
      <li>Bi-directional streaming: realtime vÃ  push data dá»… dÃ ng</li>
      <li>Code generation: client/server auto â†’ trÃ¡nh bug manual</li>
    </ul>
  </li>
  <li>
    CÃ¡c service gRPC cÃ³ thá»ƒ káº¿t ná»‘i nhau qua:
    <ul>
      <li>Static IP hoáº·c service discovery (Consul, Kubernetes DNS)</li>
      <li>gRPC-Gateway Ä‘á»ƒ expose HTTP â†’ gRPC hybrid</li>
      <li>Interconnect thÃ´ng qua Envoy Proxy hoáº·c gRPC LoadBalancer</li>
    </ul>
  </li>
</ul>

<h2>ğŸš€ Tá»‘i Æ°u hÃ³a gRPC trong há»‡ thá»‘ng</h2>
<ul>
  <li>Äá»‹nh nghÄ©a proto rÃµ rÃ ng, dÃ¹ng option Ä‘á»ƒ map HTTP náº¿u cáº§n gateway</li>
  <li>Truyá»n trace-id qua metadata Ä‘á»ƒ theo dÃµi request</li>
  <li>DÃ¹ng interceptor Ä‘á»ƒ chia nhá» concern (log, validate, panic recovery)</li>
  <li>Æ¯u tiÃªn bidirectional stream cho cÃ¡c use case realtime (chat, tracking...)</li>
</ul>
<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>

<h3>ğŸ”¹ REST API</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh <code>net/http</code>, <code>gin</code>, <code>echo</code>?
    <pre><code>net/http: lib gá»‘c, cáº§n tá»± code nhiá»u.
gin: nhanh, há»— trá»£ middleware tá»‘t.
echo: tiá»‡n Ã­ch nhiá»u hÆ¡n gin, rÃµ rÃ ng hÆ¡n.</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m middleware auth hoáº·c log trong REST nhÆ° tháº¿ nÃ o?
    <pre><code>func Middleware(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    log.Println("request", r.URL.Path)
    next.ServeHTTP(w, r)
  })
}</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> Truyá»n trace-id tá»« client Ä‘áº¿n log há»‡ thá»‘ng?
    <pre><code>Header: x-trace-id
â†’ Äá»c tá»« header, inject vÃ o context, ghi log theo context.</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ gRPC (Unary, Stream)</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Æ¯u Ä‘iá»ƒm cá»§a gRPC so vá»›i REST?
    <pre><code>- Sá»­ dá»¥ng Protobuf â†’ nhá», nhanh
- Há»— trá»£ stream (2 chiá»u)
- Contract rÃµ rÃ ng â†’ generate code
- ThÃ­ch há»£p cho internal service</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nhá»¯ng kiá»ƒu RPC nÃ o trong gRPC?
    <pre><code>1. Unary RPC (1-1)
2. Server Stream (1 request â†’ nhiá»u response)
3. Client Stream (nhiá»u request â†’ 1 response)
4. Bidirectional Stream (2 chiá»u song song)</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o dÃ¹ng client stream?
    <pre><code>Upload file, push log batch â†’ client gá»­i nhiá»u pháº§n rá»“i CloseAndRecv()</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡ch truyá»n metadata trong gRPC?
    <pre><code>ctx := metadata.NewOutgoingContext(ctx, metadata.Pairs("x-trace-id", "abc"))
â†’ Server dÃ¹ng metadata.FromIncomingContext(ctx)</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ map gRPC â†’ REST khÃ´ng?
    <pre><code>CÃ³. DÃ¹ng grpc-gateway hoáº·c Envoy gRPC Transcoding:
option (google.api.http) = { post: "/v1/foo", body: "*" }</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Interceptor (gRPC Middleware)</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Interceptor lÃ  gÃ¬? CÃ³ máº¥y loáº¡i?
    <pre><code>UnaryInterceptor â†’ Ã¡p dá»¥ng cho RPC thÆ°á»ng.
StreamInterceptor â†’ Ã¡p dá»¥ng cho RPC stream.
â†’ TÆ°Æ¡ng Ä‘Æ°Æ¡ng middleware trong REST.</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> Viáº¿t interceptor logging Ä‘Æ¡n giáº£n?
    <pre><code>func LogInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
  log.Println("gRPC:", info.FullMethod)
  return handler(ctx, req)
}</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ thá»ƒ chain nhiá»u interceptor khÃ´ng?
    <pre><code>grpc.NewServer(grpc.ChainUnaryInterceptor(Auth, Log, Recover))</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ So sÃ¡nh tá»•ng há»£p</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o chá»n REST, khi nÃ o chá»n gRPC?
    <pre><code>REST: public API, dá»… debug, dá»… tÃ­ch há»£p frontend.
gRPC: ná»™i bá»™ service, cáº§n hiá»‡u nÄƒng cao, há»— trá»£ stream.</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn dÃ¹ng cáº£ REST + gRPC trong há»‡ thá»‘ng?
    <pre><code>CÃ³. DÃ¹ng gRPC ná»™i bá»™, expose HTTP báº±ng grpc-gateway cho external.</code></pre>
  </li>
  <li>
    <strong>CÃ¢u há»i:</strong> gRPC stream cÃ³ bá»‹ race khÃ´ng? CÃ¡ch xá»­ lÃ½?
    <pre><code>Stream lÃ  shared object â†’ khÃ´ng nÃªn gá»i Send/Recv tá»« nhiá»u goroutine cÃ¹ng lÃºc.
â†’ Pháº£i serialize viá»‡c gá»i Send hoáº·c Recv báº±ng channel hoáº·c mutex.</code></pre>
  </li>
</ul>




<hr />
<h1 id="20-error-wrapping-stacktrace-vÃ -structured-logging">20. Error Wrapping, Stacktrace, vÃ  Structured Logging</h1>

<h2>ğŸ§  Tá»•ng quan</h2>
<ul>
  <li>Go xá»­ lÃ½ lá»—i qua giÃ¡ trá»‹ kiá»ƒu <code>error</code> thay vÃ¬ throw/catch.</li>
  <li><strong>Error Wrapping</strong>: giÃºp giá»¯ láº¡i gá»‘c lá»—i khi truyá»n qua nhiá»u lá»›p.</li>
  <li><strong>Stacktrace</strong>: dÃ¹ng Ä‘á»ƒ trace ngÆ°á»£c nguá»“n gá»‘c lá»—i â†’ debug production.</li>
  <li><strong>Structured Logging</strong>: log cÃ³ field rÃµ rÃ ng (JSON/key-value) â†’ dá»… search, index, alert.</li>
</ul>

<h2>ğŸ” Error Wrapping (Go 1.13+)</h2>
<pre><code class="go">if err := doSomething(); err != nil {
    return fmt.Errorf("gá»i xá»­ lÃ½ tháº¥t báº¡i: %w", err)
}

if errors.Is(err, os.ErrNotExist) {
    // lá»—i cá»¥ thá»ƒ
}

var pathErr *os.PathError
if errors.As(err, &pathErr) {
    fmt.Println("Path lá»—i:", pathErr.Path)
}
</code></pre>

<h2>ğŸ“¦ Stacktrace (pkg/errors hoáº·c zap)</h2>
<pre><code class="go">err := errors.Wrap(err, "ngá»¯ cáº£nh thÃªm")
fmt.Printf("%+v\\n", err) // Ä‘áº§y Ä‘á»§ stack trace
</code></pre>

<h2>ğŸ’¡ Structured Logging (logrus, zap, zerolog)</h2>
<pre><code class="go">log.WithFields(log.Fields{
    "user_id": 42,
    "action":  "create_order",
}).Error("Xáº£y ra lá»—i")
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li>Always wrap error táº¡i biÃªn (usecase/service boundary)</li>
  <li>Structured log Ä‘á»ƒ theo dÃµi, alert qua ELK / Grafana</li>
  <li>ÄÃ­nh trace-id vÃ o log â†’ trace toÃ n hÃ nh trÃ¬nh request</li>
  <li>Middleware â†’ log panic, recover, status code, latency</li>
</ul>



<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>

<h3>ğŸ”¹ Error Wrapping & Stacktrace</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Lá»£i Ã­ch cá»§a viá»‡c wrap error trong Go?
    <pre><code>- Giá»¯ ngá»¯ cáº£nh lá»—i khi truyá»n qua cÃ¡c táº§ng.
- Há»— trá»£ trace chÃ­nh xÃ¡c gá»‘c lá»—i khi log/debug.
- DÃ¹ng Ä‘Æ°á»£c vá»›i errors.Is, errors.As Ä‘á»ƒ phÃ¢n tÃ­ch lá»—i sÃ¢u.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Viáº¿t vÃ­ dá»¥ wrap vÃ  unwrap error?
    <pre><code>err := fmt.Errorf("gá»i tháº¥t báº¡i: %w", dbErr)
if errors.Is(err, sql.ErrNoRows) { ... }
if e, ok := err.(*MyCustomError); ok { ... }</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao láº¥y Ä‘Æ°á»£c stack trace khi lá»—i?
    <pre><code>DÃ¹ng pkg/errors:
err := errors.Wrap(err, "ngá»¯ cáº£nh thÃªm")
fmt.Printf("%+v", err)</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Structured Logging</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Structured logging lÃ  gÃ¬? KhÃ¡c gÃ¬ vá»›i print log thÆ°á»ng?
    <pre><code>Structured log = log dáº¡ng JSON hoáº·c key-value.
â†’ Dá»… parse, lá»c theo field (user_id, trace_id...).
â†’ PhÃ¹ há»£p vá»›i ELK, Loki, GCP log viewer...</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> So sÃ¡nh logrus, zap, zerolog?
    <pre><code>- logrus: dá»… dÃ¹ng, phá»• biáº¿n, cháº­m hÆ¡n do reflection.
- zap: ráº¥t nhanh, JSON log, production ready.
- zerolog: cá»±c nhanh, write trá»±c tiáº¿p, API hÆ¡i khÃ¡c.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao enrich log báº±ng trace-id trong context?
    <pre><code>traceID := ctx.Value("trace_id").(string)
log.WithField("trace_id", traceID).Info("processing...")</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn log error raw hay wrap láº¡i?
    <pre><code>â†’ NÃªn wrap trÆ°á»›c rá»“i log:
log.Errorf("gá»i backend: %v", err)
â†’ Dá»… trace lá»—i cá»¥ thá»ƒ, stack Ä‘áº§y Ä‘á»§.</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Best Practice</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn log lá»—i á»Ÿ táº§ng usecase khÃ´ng?
    <pre><code>KhÃ´ng nÃªn. Táº§ng usecase nÃªn tráº£ lá»—i cÃ³ ngá»¯ cáº£nh.
â†’ Logging chá»‰ nÃªn Ä‘áº·t táº¡i boundary: handler, cron, job worker.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> NÃªn dÃ¹ng <code>log.Printf</code> hay structured log trong prod?
    <pre><code>KhÃ´ng nÃªn dÃ¹ng Printf.
â†’ DÃ¹ng structured log Ä‘á»ƒ cÃ³ thá»ƒ trace theo field.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> VÃ¬ sao cáº§n log kÃ¨m trace-id hoáº·c request-id?
    <pre><code>Äá»ƒ theo dÃµi toÃ n bá»™ flow xá»­ lÃ½ cá»§a 1 request xuyÃªn qua nhiá»u service â†’ dá»… debug & quan sÃ¡t production.</code></pre>
  </li>
</ul>




<hr />
<h1 id="21-staticcheck-golangci-lint-go-vet-go-fmt">21. Staticcheck, GolangCI-Lint, go vet, go fmt</h1>

<h2>ğŸ§  Má»¥c tiÃªu</h2>
<ul>
  <li>PhÃ¡t hiá»‡n lá»—i tiá»m áº©n, anti-pattern, bug chÆ°a lá»™ báº±ng runtime.</li>
  <li>Chuáº©n hoÃ¡ style code, Ä‘áº£m báº£o tÃ­nh nháº¥t quÃ¡n trong team.</li>
</ul>

<h2>ğŸ” CÃ´ng cá»¥ phá»• biáº¿n</h2>
<table>
<thead><tr><th>CÃ´ng cá»¥</th><th>Chá»©c nÄƒng</th></tr></thead>
<tbody>
<tr><td><code>go fmt</code></td><td>Format láº¡i code theo chuáº©n Go</td></tr>
<tr><td><code>go vet</code></td><td>Báº¯t lá»—i logic (shadow, sai kiá»ƒu printf...)</td></tr>
<tr><td><code>staticcheck</code></td><td>PhÃ¢n tÃ­ch logic nÃ¢ng cao: unreachable, nil check...</td></tr>
<tr><td><code>golangci-lint</code></td><td>Cháº¡y nhiá»u linter cÃ¹ng lÃºc, tÃ­ch há»£p CI</td></tr>
</tbody>
</table>

<h2>ğŸ’¡ VÃ­ dá»¥ lá»—i</h2>
<pre><code class="go">fmt.Printf("%d", "abc") // sai kiá»ƒu â†’ vet

if x == nil || x == nil { } // check thá»«a â†’ staticcheck

unused := 123 // khÃ´ng dÃ¹ng â†’ unused
</code></pre>

<h2>âš™ Cáº¥u hÃ¬nh GolangCI-Lint</h2>
<pre><code class="yaml">linters:
  enable:
    - govet
    - errcheck
    - staticcheck
    - unused
run:
  timeout: 3m
  tests: true
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ Ã¡p dá»¥ng</h2>
<ul>
  <li>DÃ¹ng <code>go fmt</code> trong pre-commit hoáº·c CI</li>
  <li>TÃ­ch há»£p golangci-lint vÃ o GitHub Actions Ä‘á»ƒ check toÃ n bá»™ project</li>
  <li>DÃ¹ng <code>//nolint</code> Ä‘Ãºng má»¥c tiÃªu â€“ khÃ´ng suppress toÃ n file</li>
</ul>


<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>

<h3>ğŸ”¹ Kiá»ƒm tra & Ä‘á»‹nh dáº¡ng code</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> KhÃ¡c biá»‡t giá»¯a <code>go fmt</code> vÃ  <code>go vet</code>?
    <pre><code>go fmt: Ä‘á»‹nh dáº¡ng láº¡i code theo chuáº©n Go (spacing, bracket...).
go vet: phÃ¡t hiá»‡n lá»—i logic tiá»m áº©n (printf sai format, shadow...).</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> <code>go vet</code> phÃ¡t hiá»‡n Ä‘Æ°á»£c nhá»¯ng lá»—i nÃ o?
    <pre><code>- Gá»i printf sai Ä‘á»‹nh dáº¡ng
- GÃ¡n biáº¿n bá»‹ shadow
- Struct tag lá»—i
- Unreachable code...</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Staticcheck & GolangCI-Lint</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Staticcheck kiá»ƒm tra nhá»¯ng gÃ¬?
    <pre><code>- Dead code (hÃ m khÃ´ng gá»i tá»›i)
- Unused variable
- Check Ä‘iá»u kiá»‡n láº·p vÃ´ nghÄ©a
- Interface bá»‹ dÃ¹ng sai logic...</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> GolangCI-Lint lÃ  gÃ¬? DÃ¹ng tháº¿ nÃ o?
    <pre><code>GolangCI-Lint lÃ  tool tá»•ng há»£p nhiá»u linter (staticcheck, errcheck, govet...).
â†’ DÃ¹ng Ä‘á»ƒ check toÃ n bá»™ project, tÃ­ch há»£p CI/CD.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao disable 1 warning trong 1 dÃ²ng?
    <pre><code>//nolint:errcheck
doSomething() // khÃ´ng báº¯t lá»—i tráº£ vá»</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Lint khÃ´ng fail CI, báº¡n xá»­ lÃ½ tháº¿ nÃ o?
    <pre><code>- Äá»c chi tiáº¿t log: lá»—i format, unused, logic?
- DÃ¹ng goimports/go fmt trÆ°á»›c.
- Náº¿u báº¥t há»£p lÃ½ â†’ disable tá»«ng dÃ²ng báº±ng //nolint.</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Best Practice & CI</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> DÃ²ng lá»‡nh CI phá»• biáº¿n báº¡n dÃ¹ng?
    <pre><code>go fmt ./...
go vet ./...
golangci-lint run
go test -cover ./...
gosec ./... (check security)</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> VÃ¬ sao nÃªn báº¯t buá»™c dÃ¹ng lint trong team?
    <pre><code>Äáº£m báº£o code rÃµ rÃ ng, nháº¥t quÃ¡n.
PhÃ¡t hiá»‡n lá»—i sá»›m â†’ giáº£m bug runtime.
Tiáº¿t kiá»‡m thá»i gian review code.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> CÃ³ nÃªn táº¯t toÃ n bá»™ warning linter?
    <pre><code>KhÃ´ng. Chá»‰ táº¯t tá»«ng dÃ²ng khi cháº¯c cháº¯n khÃ´ng áº£nh hÆ°á»Ÿng logic.
â†’ Náº¿u táº¯t toÃ n bá»™ sáº½ máº¥t Ã½ nghÄ©a static analysis.</code></pre>
  </li>
</ul>


<hr />
<h1 id="22-design-patterns-trong-go">22. Design Patterns trong Go</h1>

<h2>ğŸ§  Tá»•ng quan</h2>
<ul>
  <li>Go khÃ´ng Ã©p dÃ¹ng OOP â€“ nhiá»u pattern cá»• Ä‘iá»ƒn cáº§n viáº¿t láº¡i theo idiomatic Go.</li>
  <li>Go Æ°u tiÃªn composition, interface nháº¹ vÃ  function-first.</li>
</ul>

<h2>ğŸ“¦ CÃ¡c Pattern phá»• biáº¿n trong Go</h2>
<ul>
  <li><strong>Factory</strong>: sinh object theo config</li>
  <li><strong>Singleton</strong>: duy nháº¥t 1 instance global</li>
  <li><strong>Strategy</strong>: inject logic runtime</li>
  <li><strong>Builder</strong>: khá»Ÿi táº¡o cÃ³ cáº¥u hÃ¬nh theo bÆ°á»›c</li>
  <li><strong>Decorator</strong>: thÃªm behavior qua wrapper</li>
  <li><strong>Functional Option</strong>: idiomatic Go cho config linh hoáº¡t</li>
</ul>

<h2>ğŸ— Functional Option â€“ pattern Go Æ°u tiÃªn</h2>
<pre><code class="go">type Option func(*Server)

func WithTLS(enable bool) Option {
    return func(s *Server) {
        s.TLS = enable
    }
}
</code></pre>


<h2>ğŸ— Factory Pattern</h2>
<pre><code class="go">type DB interface { Connect() error }

type MySQL struct{}
func (MySQL) Connect() error { return nil }

func NewDB(engine string) DB {
    switch engine {
    case "mysql":
        return MySQL{}
    default:
        panic("unsupported")
    }
}
</code></pre>

<h2>ğŸ” Singleton Pattern</h2>
<pre><code class="go">var instance *Logger
var once sync.Once

func GetLogger() *Logger {
    once.Do(func() {
        instance = &Logger{}
    })
    return instance
}
</code></pre>

<h2>âš™ Strategy Pattern</h2>
<pre><code class="go">type Compressor interface {
    Compress(data string) string
}

type Gzip struct{}
func (Gzip) Compress(data string) string { return "GZIP:" + data }

func Run(c Compressor, data string) {
    fmt.Println(c.Compress(data))
}
</code></pre>

<h2>ğŸ›  Builder Pattern</h2>
<pre><code class="go">type UserBuilder struct {
    u User
}
func (b *UserBuilder) Name(name string) *UserBuilder {
    b.u.Name = name; return b
}
func (b *UserBuilder) Build() User { return b.u }
</code></pre>

<h2>ğŸ Decorator Pattern</h2>
<pre><code class="go">func LogWrap(fn func(string) string) func(string) string {
    return func(s string) string {
        fmt.Println("Start")
        res := fn(s)
        fmt.Println("Done")
        return res
    }
}
</code></pre>

<h2>ğŸ§© Functional Option Pattern</h2>
<pre><code class="go">type Server struct {
    Port int
}
type Option func(*Server)

func WithPort(p int) Option {
    return func(s *Server) { s.Port = p }
}
</code></pre>


<h2>ğŸ“Œ á»¨ng dá»¥ng há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Factory</strong>: khá»Ÿi táº¡o logger, db, gRPC client</li>
  <li><strong>Strategy</strong>: auth engine, retry logic</li>
  <li><strong>Functional Option</strong>: server config, middleware chain</li>
</ul>


<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>

<h3>ğŸ”¹ Tá»•ng quan Design Pattern</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> VÃ¬ sao trong Go Ã­t dÃ¹ng inheritance? Thay tháº¿ báº±ng gÃ¬?
    <pre><code>Go khÃ´ng há»— trá»£ class-based OOP â†’ khÃ´ng cÃ³ extends.
â†’ Thay báº±ng composition + interface â†’ dá»… kiá»ƒm soÃ¡t, testable, clear.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Pattern nÃ o phá»• biáº¿n trong há»‡ thá»‘ng backend Go?
    <pre><code>- Factory â†’ khá»Ÿi táº¡o instance (db, log, grpc...)
- Singleton â†’ giá»¯ 1 instance dÃ¹ng chung
- Strategy â†’ xá»­ lÃ½ logic runtime (auth, retry...)
- Functional Option â†’ config linh hoáº¡t khi init struct
- Decorator â†’ middleware, logging, wrapping handler</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Factory</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Viáº¿t factory init database theo engine khÃ¡c nhau?
    <pre><code>func NewDB(engine string) DB {
  switch engine {
  case "mysql": return &MySQL{}
  case "pg": return &Postgres{}
  default: panic("unsupported")
}</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Singleton</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Triá»ƒn khai Singleton an toÃ n trong goroutine?
    <pre><code>var once sync.Once
var instance *Logger

func GetLogger() *Logger {
  once.Do(func() {
    instance = &Logger{}
  })
  return instance
}</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Strategy</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Pattern Strategy Ä‘Æ°á»£c Ã¡p dá»¥ng nhÆ° nÃ o trong auth middleware?
    <pre><code>type AuthStrategy interface {
  Authenticate(token string) bool
}

func DoAuth(s AuthStrategy, token string) {
  if !s.Authenticate(token) {
    panic("unauthorized")
  }
}</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Functional Option</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Æ¯u Ä‘iá»ƒm cá»§a Functional Option trong khá»Ÿi táº¡o object?
    <pre><code>- TrÃ¡nh constructor quÃ¡ dÃ i
- Há»— trá»£ optional config dá»… dÃ ng
- KhÃ´ng cáº§n nhiá»u hÃ m NewXxx overload</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Viáº¿t vÃ­ dá»¥ Functional Option setup Server?
    <pre><code>type Option func(*Server)

func WithPort(p int) Option {
  return func(s *Server) { s.Port = p }
}

func NewServer(opts ...Option) *Server {
  s := &Server{}
  for _, o := range opts {
    o(s)
  }
  return s
}</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Decorator</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Decorator Ä‘Æ°á»£c dÃ¹ng nhiá»u nháº¥t á»Ÿ Ä‘Ã¢u trong Go?
    <pre><code>- HTTP/gRPC middleware
- Logging/Recovery Wrapper
- Retry logic quanh hÃ m gá»i API</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Viáº¿t decorator Ä‘Æ¡n giáº£n log thá»i gian cháº¡y?
    <pre><code>func Timing(fn func()) func() {
  return func() {
    start := time.Now()
    fn()
    fmt.Println("took:", time.Since(start))
  }
}</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Best Practice</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Pattern nÃ o dá»… bá»‹ láº¡m dá»¥ng vÃ  khÃ³ debug?
    <pre><code>Functional Option náº¿u khÃ´ng log rÃµ â†’ cáº¥u hÃ¬nh bá»‹ override ngáº§m.
Singleton â†’ dá»… gÃ¢y hidden state, khÃ³ test náº¿u khÃ´ng mockable.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng Factory thay vÃ¬ inject struct trá»±c tiáº¿p?
    <pre><code>- Khi cáº§n quyáº¿t Ä‘á»‹nh runtime (giao thá»©c, database, strategy...).
- Khi init phá»©c táº¡p â†’ tÃ¡ch Factory ra dá»… test vÃ  maintain.</code></pre>
  </li>
</ul>



<hr />
<h1 id="23-system-design-worker-pool-fan-inout-pipeline">23. System Design: Worker Pool, Fan-in/out, Pipeline</h1>

<h2>ğŸ§  Tá»•ng quan</h2>
<ul>
  <li>Go há»— trá»£ xá»­ lÃ½ song song qua goroutine vÃ  channel â†’ dá»… Ã¡p dá»¥ng cÃ¡c mÃ´ hÃ¬nh nhÆ° pipeline, fan-out, worker pool.</li>
</ul>

<h2>ğŸ” Fan-out Pattern</h2>
<pre><code class="go">jobs := make(chan int, 100)
for w := 1; w <= 3; w++ {
    go func(id int) {
        for j := range jobs {
            fmt.Println("Worker", id, "xá»­ lÃ½ job", j)
        }
    }(w)
}
for j := 1; j <= 5; j++ {
    jobs <- j
}
close(jobs)
</code></pre>

<h2>ğŸ”€ Fan-in Pattern</h2>
<pre><code class="go">func merge(cs ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    for _, c := range cs {
        wg.Add(1)
        go func(ch <-chan int) {
            defer wg.Done()
            for v := range ch {
                out <- v
            }
        }(c)
    }
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}
</code></pre>

<h2>ğŸ›  Worker Pool</h2>
<pre><code class="go">jobs := make(chan int, 10)
results := make(chan int, 10)

worker := func(jobs <-chan int, results chan<- int) {
    for j := range jobs {
        results <- j * 2
    }
}
for i := 0; i < 3; i++ {
    go worker(jobs, results)
}
for j := 1; j <= 5; j++ {
    jobs <- j
}
close(jobs)
for i := 0; i < 5; i++ {
    fmt.Println(<-results)
}
</code></pre>

<h2>ğŸ”— Pipeline Pattern</h2>
<pre><code class="go">func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}
</code></pre>

<h2>ğŸ“Œ á»¨ng dá»¥ng thá»±c táº¿</h2>
<ul>
  <li><strong>Fan-out</strong>: xá»­ lÃ½ song song nhiá»u file/API/data chunk</li>
  <li><strong>Fan-in</strong>: gom data tá»« nhiá»u nguá»“n vá» 1 xá»­ lÃ½</li>
  <li><strong>Worker Pool</strong>: giá»›i háº¡n tÃ i nguyÃªn há»‡ thá»‘ng</li>
  <li><strong>Pipeline</strong>: ETL, stream xá»­ lÃ½ log, event</li>
</ul>


<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>

<h3>ğŸ”¹ Tá»•ng quan mÃ´ hÃ¬nh xá»­ lÃ½ song song</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Fan-out vÃ  Fan-in khÃ¡c nhau tháº¿ nÃ o?
    <pre><code>Fan-out: nhiá»u goroutine cÃ¹ng xá»­ lÃ½ chung 1 nguá»“n (channel in).
Fan-in: nhiá»u nguá»“n dá»¯ liá»‡u há»£p nháº¥t láº¡i 1 channel out.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Khi nÃ o nÃªn dÃ¹ng Worker Pool?
    <pre><code>- Khi muá»‘n giá»›i háº¡n sá»‘ goroutine xá»­ lÃ½ cÃ¹ng lÃºc (giáº£m memory, trÃ¡nh overload).
- Khi task nhiá»u nhÆ°ng Ä‘á»™ dÃ i xá»­ lÃ½ khÃ´ng Ä‘á»u.</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Worker Pool</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡ch triá»ƒn khai worker pool an toÃ n?
    <pre><code>- Táº¡o 1 channel chá»©a job.
- Táº¡o N worker goroutine nháº­n job qua channel.
- Gá»­i job vÃ o channel vÃ  close sau khi xong.
- Worker ghi káº¿t quáº£ ra channel káº¿t quáº£.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao trÃ¡nh leak goroutine trong worker pool?
    <pre><code>- Äáº£m báº£o táº¥t cáº£ worker Ä‘á»c tá»« channel Ä‘áº¿n khi Ä‘Ã³ng.
- Sá»­ dá»¥ng WaitGroup Ä‘á»ƒ Ä‘á»£i toÃ n bá»™ worker káº¿t thÃºc.
- KhÃ´ng dÃ¹ng channel khÃ´ng buffer náº¿u sender/receiver lá»‡ch pha.</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Fan-in</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ¡ch gá»™p nhiá»u channel vá» 1 channel?
    <pre><code>func merge(chs ...<-chan int) <-chan int {
  out := make(chan int)
  var wg sync.WaitGroup
  for _, c := range chs {
    wg.Add(1)
    go func(c <-chan int) {
      defer wg.Done()
      for v := range c {
        out <- v
      }
    }(c)
  }
  go func() {
    wg.Wait()
    close(out)
  }()
  return out
}</code></pre>
  </li>
</ul>

<h3>ğŸ”¸ Pipeline</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> MÃ´ hÃ¬nh pipeline dÃ¹ng cho má»¥c Ä‘Ã­ch gÃ¬?
    <pre><code>- TÃ¡ch xá»­ lÃ½ thÃ nh nhiá»u bÆ°á»›c rÃµ rÃ ng (stage).
- Dá»… káº¿t há»£p xá»­ lÃ½ tuáº§n tá»± vÃ  song song (stream data).
- á»¨ng dá»¥ng trong ETL, xá»­ lÃ½ file, log stream, etc.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> TÃ­nh cháº¥t cá»§a pipeline tá»‘t?
    <pre><code>- KhÃ´ng share state giá»¯a stage.
- Má»—i stage nÃªn lÃ  pure function hoáº·c goroutine riÃªng.
- CÃ³ cÆ¡ cháº¿ close channel cuá»‘i Ä‘á»ƒ trÃ¡nh leak.</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Performance & Tá»‘i Æ°u</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> NÃªn dÃ¹ng channel nÃ o? Buffered hay unbuffered?
    <pre><code>- Buffered: tá»‘t khi producer nhanh hÆ¡n consumer â†’ giáº£m block.
- Unbuffered: tá»‘t khi cáº§n Ä‘á»“ng bá»™ hÃ³a cháº·t (1 gá»­i â€“ 1 nháº­n).</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Race condition cÃ³ thá»ƒ xáº£y ra trong cÃ¡c mÃ´ hÃ¬nh nÃ y khÃ´ng?
    <pre><code>CÃ³. Náº¿u nhiá»u goroutine cÃ¹ng ghi slice/map hoáº·c dÃ¹ng biáº¿n chung mÃ  khÃ´ng cÃ³ lock.
â†’ DÃ¹ng sync.Mutex hoáº·c channel Ä‘á»ƒ Ä‘á»“ng bá»™.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Æ¯u Ä‘iá»ƒm khi combine Fan-out â†’ Pipeline â†’ Fan-in?
    <pre><code>- Tá»‘i Ä‘a hoÃ¡ concurrency
- TÃ¡ch biá»‡t rÃµ tá»«ng giai Ä‘oáº¡n
- Dá»… scale tá»«ng bÆ°á»›c Ä‘á»™c láº­p</code></pre>
  </li>
</ul>

<h3>ğŸ”¹ Use case thá»±c táº¿</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Gá»£i Ã½ á»©ng dá»¥ng Fan-out trong backend system?
    <pre><code>- Äá»c file lá»›n vÃ  chia task xá»­ lÃ½ theo dÃ²ng.
- Gá»­i API song song Ä‘áº¿n nhiá»u service.
- Worker xá»­ lÃ½ job queue tá»« Kafka, Redis.</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Gá»£i Ã½ á»©ng dá»¥ng Pipeline trong Go project thá»±c táº¿?
    <pre><code>- Stream log â†’ parse â†’ enrich â†’ send Ä‘áº¿n Kafka.
- Load CSV â†’ validate â†’ transform â†’ lÆ°u DB.
- Nháº­n request â†’ verify â†’ enrich user â†’ forward Ä‘áº¿n backend khÃ¡c.</code></pre>
  </li>
</ul>


<hr />
<h1 id="24-secure-coding-vÃ -cicd-workflow">24. Secure Coding vÃ  CI/CD Workflow</h1>

<h2>ğŸ§  Má»¥c tiÃªu báº£o máº­t</h2>
<ul>
  <li>Báº£o vá»‡ dá»¯ liá»‡u ngÆ°á»i dÃ¹ng vÃ  há»‡ thá»‘ng backend khá»i lá»—i báº£o máº­t, lá»™ thÃ´ng tin, config sai.</li>
</ul>

<h2>ğŸ” Best Practices</h2>
<ul>
  <li>Validate má»i input Ä‘áº§u vÃ o</li>
  <li>KhÃ´ng log token, password, internal error chi tiáº¿t</li>
  <li>DÃ¹ng <code>context.WithTimeout</code> vá»›i DB/API</li>
  <li>KhÃ´ng hardcode secret â€“ dÃ¹ng ENV hoáº·c secret vault</li>
</ul>

<h2>ğŸ›¡ï¸ Static Security Scan</h2>
<pre><code class="bash">gosec ./...    # phÃ¡t hiá»‡n eval, crypto yáº¿u, bind-all, hardcoded token...
</code></pre>

<h2>ğŸš€ CI/CD Workflow Best Practices</h2>
<ul>
  <li>TÃ­ch há»£p go fmt, lint, test, security scan</li>
  <li>KhÃ´ng log secret ra GitHub Actions</li>
  <li>DÃ¹ng docker multi-stage â†’ image gá»n</li>
</ul>

<h2>ğŸ“¦ CI Example (GitHub Actions)</h2>
<pre><code class="yaml">- run: go test -cover ./...
- run: golangci-lint run
- run: gosec ./...
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li>LuÃ´n cÃ³ timeout, trÃ¡nh DDoS báº±ng chá» vÃ´ háº¡n</li>
  <li>Scan code báº£o máº­t má»—i merge request</li>
  <li>Structured logging Ä‘á»ƒ trace behavior nguy hiá»ƒm</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n (Core + Senior)</h2>

<h3>ğŸ” Secure Coding</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> Nhá»¯ng lá»—i báº£o máº­t phá»• biáº¿n trong Go lÃ  gÃ¬?
    <pre><code>- KhÃ´ng kiá»ƒm tra input â†’ XSS, SQLi
- Lá»™ thÃ´ng tin nháº¡y cáº£m trong log (token, password)
- DÃ¹ng crypto yáº¿u (MD5, SHA1)
- Hardcode secret / API key trong source</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao Ä‘á»ƒ báº£o vá»‡ API khá»i DDoS hoáº·c abuse?
    <pre><code>- ThÃªm timeout context vÃ o má»—i request
- Sá»­ dá»¥ng rate limit (Envoy, middleware)
- ThÃªm auth/token, quota</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Báº¡n báº£o vá»‡ secret (token, config) trong codebase nhÆ° tháº¿ nÃ o?
    <pre><code>- KhÃ´ng bao giá» commit file .env / config thá»±c
- DÃ¹ng biáº¿n mÃ´i trÆ°á»ng hoáº·c secret manager (Vault, AWS Secret)
- Vá»›i CI/CD: inject secret qua mÃ´i trÆ°á»ng runtime</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> VÃ¬ sao logging sai cÃ¡ch cÃ³ thá»ƒ gÃ¢y rá»§i ro báº£o máº­t?
    <pre><code>- Ghi ná»™i dung nháº¡y cáº£m nhÆ° token/password â†’ bá»‹ leak náº¿u cÃ³ lá»—i hoáº·c attack
- Ghi lá»—i ná»™i bá»™ quÃ¡ chi tiáº¿t â†’ lá»™ stacktrace, cáº¥u trÃºc há»‡ thá»‘ng</code></pre>
  </li>
</ul>

<h3>ğŸ§ª Static Security Scan</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> CÃ´ng cá»¥ nÃ o dÃ¹ng Ä‘á»ƒ scan báº£o máº­t cho project Go?
    <pre><code>â†’ Gosec: quÃ©t lá»— há»•ng nhÆ° hardcoded credentials, bind-all, eval code, TLS weak</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> VÃ­ dá»¥ lá»‡nh scan báº£o máº­t code Go?
    <pre><code>gosec ./...   # quÃ©t táº¥t cáº£ file .go trong module hiá»‡n táº¡i</code></pre>
  </li>
</ul>

<h3>ğŸš€ CI/CD Workflow</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> CI/CD cho Go thÆ°á»ng gá»“m nhá»¯ng bÆ°á»›c nÃ o?
    <pre><code>- go fmt + vet + lint
- go test + coverage
- gosec security scan
- build binary (go build)
- docker build & push image
- deploy (K8s, ECS, Lambda...)</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao Ä‘áº£m báº£o CI/CD khÃ´ng leak thÃ´ng tin?
    <pre><code>- KhÃ´ng log secret, token (dÃ¹ng redacted output)
- KhÃ´ng echo toÃ n bá»™ env
- KhÃ´ng lÆ°u file .env vÃ o image</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> Báº¡n Ä‘Ã£ gáº·p lá»—i nÃ o nghiÃªm trá»ng trong CI/CD chÆ°a?
    <pre><code>- Build khÃ´ng kiá»ƒm tra coverage â†’ bug lá»t qua
- Push image chá»©a credential hardcode
- Secret bá»‹ leak qua log GitHub Actions</code></pre>
  </li>
</ul>

<h3>ğŸ“¦ Best Practice cho Go trong CI/CD</h3>
<ul>
  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao cáº¥u hÃ¬nh GitHub Actions Ä‘á»ƒ test + lint + báº£o máº­t?
    <pre><code>jobs:
  test:
    steps:
      - run: go fmt ./...
      - run: go vet ./...
      - run: golangci-lint run
      - run: go test -cover ./...
      - run: gosec ./...</code></pre>
  </li>

  <li>
    <strong>CÃ¢u há»i:</strong> LÃ m sao Ä‘á»ƒ Go binary build an toÃ n vÃ  nhá»?
    <pre><code>- Sá»­ dá»¥ng go build static binary
- Multi-stage Dockerfile
- Set CGO_ENABLED=0 Ä‘á»ƒ build image scratch</code></pre>
  </li>
</ul>


<hr />
<h1 id="25-distributed-systems-redis-kafka-envoyproxy">25. Distributed Systems: Redis, Kafka, EnvoyProxy</h1>

<h2>ğŸ§  Kiáº¿n trÃºc phÃ¢n tÃ¡n â€“ Redis / Kafka / Envoy</h2>
<ul>
  <li><strong>Redis</strong>: cache, pub/sub, distributed lock</li>
  <li><strong>Kafka</strong>: event queue, pub/sub async microservice</li>
  <li><strong>Envoy</strong>: service proxy, gRPC gateway, observability layer</li>
</ul>

<h2>ğŸš€ Redis</h2>
<pre><code>&lt;!-- Redis Caching Flow --&gt;
Client â†’ API â†’ Redis Cache?
           â†“ miss
         â†’ DB â†’ Cache â†’ Redis
         â† Result
</code></pre>

<pre><code class="go">rdb := redis.NewClient(&redis.Options{Addr: "localhost:6379"})
val, err := rdb.Get(ctx, "user:1").Result()
if err == redis.Nil {
    // cache miss â†’ DB
}
</code></pre>

<h2>ğŸ“¨ Kafka</h2>
<pre><code>&lt;!-- Kafka Event Flow --&gt;
Producer â†’ Kafka topic: order.created
                       â†“
            Consumer A â†’ Email
            Consumer B â†’ Billing
</code></pre>

<pre><code class="go">r := kafka.NewReader(kafka.ReaderConfig{Topic: "order.created"})
for {
    m, _ := r.ReadMessage(ctx)
    fmt.Println(string(m.Value))
}
</code></pre>

<h2>ğŸŒ Envoy</h2>
<pre><code>&lt;!-- Envoy Service Flow --&gt;
Client â†’ Envoy Proxy â†’ gRPC Service
            â†‘ log, TLS, retry, metrics
</code></pre>

<pre><code class="yaml"># envoy.yaml
grpc_services:
  - google.api.http:
      post: "/v1/send"
      body: "*"
    selector: messaging.SendMessage
</code></pre>

<h2>ğŸ“Œ Gá»£i Ã½ há»‡ thá»‘ng</h2>
<ul>
  <li><strong>Redis</strong>: tÄƒng throughput, TTL, lock job</li>
  <li><strong>Kafka</strong>: tÃ¡ch sync â†’ async, log store, broadcast</li>
  <li><strong>Envoy</strong>: observability, retry, circuit breaker</li>
</ul>
<h2>ğŸ§  Má»Ÿ rá»™ng: Chi tiáº¿t Redis / Kafka / EnvoyProxy</h2>

<h3>ğŸ”´ Redis â€“ Nhá»¯ng chá»©c nÄƒng máº¡nh máº½</h3>
<ul>
  <li><strong>GET / SET</strong>: lÆ°u dá»¯ liá»‡u dáº¡ng key-value cá»±c nhanh</li>
  <li><strong>TTL / EXPIRE</strong>: key tá»± xoÃ¡ sau má»™t thá»i gian</li>
  <li><strong>INCR / DECR</strong>: Ä‘áº¿m truy cáº­p, lÆ°á»£t vote</li>
  <li><strong>Pub/Sub</strong>: push real-time event (chat, notify)</li>
  <li><strong>ZSET</strong>: sort theo score â€“ dÃ¹ng cho ranking/leaderboard</li>
  <li><strong>Stream</strong>: giá»‘ng Kafka nháº¹, há»— trá»£ nhÃ³m, backlog</li>
  <li><strong>Distributed Lock</strong>: SETNX + EXPIRE giÃºp lock an toÃ n</li>
</ul>

<h3>ğŸ”¶ Kafka â€“ CÃ¡c thÃ nh pháº§n cá»‘t lÃµi</h3>
<ul>
  <li><strong>Topic</strong>: nÆ¡i cÃ¡c producer ghi vÃ  consumer Ä‘á»c</li>
  <li><strong>Partition</strong>: giÃºp scale, Ä‘áº£m báº£o thá»© tá»± trong partition</li>
  <li><strong>Consumer Group</strong>: chia táº£i â€“ má»—i partition â†’ 1 consumer trong group</li>
  <li><strong>Offset</strong>: vá»‹ trÃ­ message trong partition</li>
  <li><strong>Payload</strong>: ná»™i dung message, dáº¡ng []byte â†’ thÆ°á»ng lÃ  JSON, Protobuf</li>
  <li><strong>Retention</strong>: lÆ°u message nhiá»u giá»/ngÃ y Ä‘á»ƒ replay</li>
</ul>

<h3>ğŸ“Œ Kafka Patterns</h3>
<ul>
  <li><strong>Fan-out</strong>: 1 event â†’ nhiá»u service xá»­ lÃ½ song song</li>
  <li><strong>Retry Queue</strong>: gá»­i láº¡i náº¿u consumer fail</li>
  <li><strong>Compaction</strong>: chá»‰ giá»¯ báº£n má»›i nháº¥t theo key</li>
</ul>

<h3>ğŸ”µ Envoy â€“ Kháº£ nÄƒng máº¡nh</h3>
<ul>
  <li><strong>gRPC transcoding</strong>: REST â†’ gRPC â†’ handler</li>
  <li><strong>Per-route policy</strong>: config riÃªng tá»«ng endpoint</li>
  <li><strong>Rate limit</strong>: cháº·n láº¡m dá»¥ng theo header/client IP</li>
  <li><strong>Retry & Circuit breaker</strong>: Ä‘áº£m báº£o resiliency khi backend fail</li>
  <li><strong>RBAC / AuthZ</strong>: cháº·n/cho phÃ©p request theo role, path, header</li>
  <li><strong>Access log</strong>: JSON log cho má»i request</li>
  <li><strong>Tracing</strong>: tÃ­ch há»£p Zipkin/Jaeger</li>
</ul>

<h2>ğŸ¯ CÃ¢u há»i phá»ng váº¥n â€“ Má»¥c 25: Distributed Systems (Redis, Kafka, Envoy)</h2>

<h3>ğŸ”´ Redis</h3>

<ul>
  <li>
    <strong>Q:</strong> CÃ³ nhá»¯ng pattern caching phá»• biáº¿n nÃ o vá»›i Redis?
    <pre><code>1. Cache Aside (lazy): chá»‰ cache khi miss â†’ phá»• biáº¿n nháº¥t.
2. Write-through: update cache + DB cÃ¹ng lÃºc â†’ Ä‘áº£m báº£o nháº¥t quÃ¡n, nhÆ°ng tÄƒng latency.
3. Write-behind: ghi cache trÆ°á»›c, flush vá» DB sau â†’ hiá»‡u suáº¥t cao nhÆ°ng dá»… máº¥t dá»¯ liá»‡u.
4. Read-through: client chá»‰ gá»i Redis, backend lo fallback â†’ tÄƒng coupling.</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Redis há»— trá»£ nhá»¯ng eviction policy nÃ o? Khi nÃ o nÃªn dÃ¹ng tá»«ng loáº¡i?
    <pre><code>- noeviction: lá»—i náº¿u Ä‘áº§y (thÆ°á»ng dÃ¹ng cho queue).
- allkeys-lru: xÃ³a key Ã­t dÃ¹ng nháº¥t (default cho cache toÃ n há»‡ thá»‘ng).
- volatile-lru: nhÆ° trÃªn nhÆ°ng chá»‰ key cÃ³ TTL.
- volatile-ttl: xÃ³a key sáº¯p háº¿t háº¡n nháº¥t.
- random: fallback nháº¹ náº¿u workload khÃ´ng predictable.</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Redis Pub/Sub khÃ¡c gÃ¬ Redis Stream?
    <pre><code>- Pub/Sub: khÃ´ng cÃ³ backlog, chá»‰ gá»­i realtime â†’ ai khÃ´ng subscribe thÃ¬ máº¥t.
- Stream: cÃ³ offset, consumer group, replay message Ä‘Æ°á»£c â†’ phÃ¹ há»£p há»‡ thá»‘ng event.</code></pre>
  </li>

  <li>
    <strong>Q:</strong> LÃ m tháº¿ nÃ o Ä‘á»ƒ implement distributed lock an toÃ n vá»›i Redis?
    <pre><code>- DÃ¹ng SET key value NX EX 10
- Kiá»ƒm tra value Ä‘á»ƒ trÃ¡nh unlock nháº§m (lock chá»‰ do 1 service sá»Ÿ há»¯u).
- Náº¿u cáº§n multi-node, nÃªn dÃ¹ng RedLock (cÆ¡ cháº¿ Ä‘á»“ng thuáº­n qua nhiá»u Redis instance).</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Nhá»¯ng lá»—i phá»• biáº¿n khi dÃ¹ng Redis lÃ  gÃ¬?
    <pre><code>- QuÃªn TTL â†’ memory leak
- DÃ¹ng KEYS * â†’ gÃ¢y block toÃ n Redis instance
- KhÃ´ng handle cache stampede
- DÃ¹ng Redis lÃ m primary store thay vÃ¬ cache</code></pre>
  </li>
</ul>

<h3>ğŸ“¨ Kafka</h3>

<ul>
  <li>
    <strong>Q:</strong> Kafka cÃ³ thá»ƒ Ä‘áº£m báº£o thá»© tá»± message khÃ´ng?
    <pre><code>CÃ³ â€“ nhÆ°ng chá»‰ trong 1 partition.
â†’ Náº¿u cáº§n toÃ n bá»™ message ordered, chÃºng pháº£i Ä‘i cÃ¹ng 1 key â†’ 1 partition â†’ khÃ´ng scale.</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Kafka scale consumer group nhÆ° tháº¿ nÃ o?
    <pre><code>- Má»—i partition chá»‰ cÃ³ 1 consumer active trong group.
- Náº¿u sá»‘ consumer > sá»‘ partition â†’ consumer thá»«a sáº½ idle.
â†’ Thiáº¿t káº¿ partition count nÃªn â‰¥ sá»‘ consumer mong muá»‘n.</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Giáº£i thÃ­ch cÃ¡c kiá»ƒu delivery: at-most-once, at-least-once, exactly-once?
    <pre><code>- at-most-once: xá»­ lÃ½ xong má»›i commit offset â†’ an toÃ n, khÃ´ng máº¥t, nhÆ°ng cÃ³ thá»ƒ duplicate.
- at-least-once: commit trÆ°á»›c xá»­ lÃ½ â†’ máº¥t dá»¯ liá»‡u náº¿u fail.
- exactly-once: cáº§n báº­t idempotent producer + transaction API â†’ phá»©c táº¡p, latency cao.</code></pre>
  </li>

  <li>
    <strong>Q:</strong> So sÃ¡nh Kafka vÃ  RabbitMQ?
    <pre><code>Kafka:
- Log-based, giá»¯ message lÃ¢u
- High throughput, partition Ä‘á»ƒ scale
- PhÃ¹ há»£p event sourcing, audit, analytics

RabbitMQ:
- Queue-based, push-based
- HÃ ng Ä‘á»£i biáº¿n máº¥t khi consumer ack
- PhÃ¹ há»£p task queue, fanout realtime</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Khi nÃ o cáº§n cÃ¢n nháº¯c sá»‘ partition? TÃ¡c Ä‘á»™ng lÃ  gÃ¬?
    <pre><code>- Nhiá»u partition â†’ tÄƒng parallelism, throughput
- NhÆ°ng tÄƒng overhead: file handle, memory, replica lag
- TÄƒng partition khÃ´ng giáº£m latency náº¿u consumer khÃ´ng Ä‘á»§</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Kafka cÃ³ há»— trá»£ delay queue khÃ´ng?
    <pre><code>KhÃ´ng natively. Cáº§n workaround nhÆ°:
- Gá»­i vÃ o topic riÃªng cÃ³ tÃªn delay
- Consumer filter thá»i gian
- DÃ¹ng stream processor Ä‘á»ƒ delay message</code></pre>
  </li>
</ul>

<h3>ğŸŒ Envoy (Proxy, Gateway, Observability)</h3>

<ul>
  <li>
    <strong>Q:</strong> Envoy hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o trong há»‡ thá»‘ng microservice?
    <pre><code>Envoy lÃ  L7 proxy trung gian:
- LÃ m load balancer ná»™i bá»™
- Gáº¯n auth, tracing, retry
- LÃ m gRPC gateway hoáº·c sidecar proxy (service mesh)</code></pre>
  </li>

  <li>
    <strong>Q:</strong> CÃ¡c loáº¡i gRPC RPC cÃ³ gÃ¬ khÃ¡c biá»‡t?
    <pre><code>- Unary: 1 request â€“ 1 response
- Server streaming: 1 req â€“ stream res
- Client streaming: stream req â€“ 1 res
- Bidirectional streaming: cáº£ 2 chiá»u stream song song</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Interceptor trong gRPC lÃ  gÃ¬? CÃ³ bao nhiÃªu loáº¡i?
    <pre><code>- LÃ  middleware cá»§a gRPC
- Unary Interceptor: apply cho RPC 1-1
- Stream Interceptor: apply cho stream
â†’ DÃ¹ng Ä‘á»ƒ logging, auth, tracing, panic recovery</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Envoy há»— trá»£ retry & circuit breaker nhÆ° tháº¿ nÃ o?
    <pre><code>- Retry: cáº¥u hÃ¬nh timeout, backoff, retry on code
- Circuit breaker: giá»›i háº¡n concurrent conn, pending request
â†’ TrÃ¡nh overload backend khi lá»—i</code></pre>
  </li>

  <li>
    <strong>Q:</strong> LÃ m sao Envoy há»— trá»£ tracing vÃ  logging táº­p trung?
    <pre><code>- Truyá»n trace-id (x-request-id) tá»« upstream xuá»‘ng
- TÃ­ch há»£p Zipkin/Jaeger â†’ theo dÃµi xuyÃªn microservice
- Log structured JSON cho ELK / Loki / Datadog</code></pre>
  </li>

  <li>
    <strong>Q:</strong> Envoy so vá»›i NGINX thÃ¬ nÃªn dÃ¹ng cÃ¡i nÃ o?
    <pre><code>Envoy:
- Native HTTP/2, gRPC
- Hot reload config, dynamic routing
- CÃ³ built-in observability (metrics, trace)

NGINX:
- Hiá»‡u nÄƒng cao
- Phá»• biáº¿n, nhÆ°ng cáº¥u hÃ¬nh gRPC phá»©c táº¡p
â†’ DÃ¹ng Envoy cho há»‡ thá»‘ng service mesh / gRPC-based</code></pre>
  </li>
</ul>

<h2 id="mistake-1-interface-vs-nil">âŒ Mistake #1 â€“ So sÃ¡nh interface vá»›i nil nhÆ°ng váº«n khÃ´ng báº±ng nil</h2>

<p>Má»™t trong nhá»¯ng lá»—i phá»• biáº¿n vÃ  nguy hiá»ƒm nháº¥t trong Go lÃ  so sÃ¡nh má»™t interface vá»›i <code>nil</code> vÃ  ká»³ vá»ng ráº±ng nÃ³ sáº½ tráº£ vá» <code>true</code>, nhÆ°ng thá»±c táº¿ láº¡i tráº£ vá» <code>false</code> â€“ dáº«n Ä‘áº¿n logic sai.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Interface trong Go gá»“m 2 pháº§n: <strong>type</strong> vÃ  <strong>value</strong>. Khi báº¡n gÃ¡n má»™t con trá» nil vÃ o interface, nÃ³ váº«n giá»¯ pháº§n <code>type</code>, do Ä‘Ã³ toÃ n bá»™ interface khÃ´ng cÃ²n lÃ  <code>nil</code> ná»¯a.</p>

<pre><code class="go">// âŒ Sai: err khÃ´ng pháº£i lÃ  nil
type MyError struct{}

func (e *MyError) Error() string { return "err" }

func Do() error {
    var e *MyError = nil
    return e // âš ï¸ interface error â‰  nil
}

func main() {
    if Do() == nil {
        fmt.Println("No error") // khÃ´ng in ra!
    } else {
        fmt.Println("Error detected") // in ra
    }
}
</code></pre>

<h3>âœ… CÃ¡ch fix</h3>
<p>LuÃ´n kiá»ƒm tra giÃ¡ trá»‹ nil trÆ°á»›c khi gÃ¡n vÃ o interface:</p>

<pre><code class="go">func Do() error {
    var e *MyError = nil
    if e == nil {
        return nil
    }
    return e
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Táº¡i sao má»™t con trá» nil gÃ¡n vÃ o interface láº¡i khÃ´ng pháº£i lÃ  nil?</li>
  <li><strong>Tráº£ lá»i:</strong> VÃ¬ interface trong Go gá»“m (type, value). Khi gÃ¡n nil pointer vÃ o, <code>type â‰  nil</code> dÃ¹ <code>value = nil</code>, nÃªn toÃ n interface váº«n khÃ¡c nil.</li>

  <li><strong>Q:</strong> LÃ m sao Ä‘á»ƒ Ä‘áº£m báº£o tráº£ vá» error thá»±c sá»± lÃ  nil?</li>
  <li><strong>Tráº£ lá»i:</strong> Pháº£i kiá»ƒm tra giÃ¡ trá»‹ trÆ°á»›c khi return. Náº¿u lÃ  pointer nil â†’ return nil trá»±c tiáº¿p thay vÃ¬ return interface chá»©a pointer nil.</li>
</ul>


<h2 id="mistake-2-closure-trong-vÃ²ng-láº·p">âŒ Mistake #2 â€“ Closure trong vÃ²ng láº·p dÃ¹ng sai biáº¿n loop</h2>

<p>Lá»—i phá»• biáº¿n khi dÃ¹ng <code>closure</code> (hÃ m áº©n danh) trong vÃ²ng láº·p: táº¥t cáº£ closure "báº¯t" cÃ¹ng má»™t biáº¿n loop, dáº«n Ä‘áº¿n giÃ¡ trá»‹ sai lá»‡ch hoáº·c khÃ´ng Ä‘oÃ¡n Ä‘Æ°á»£c.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Trong vÃ²ng láº·p, biáº¿n <code>i</code> Ä‘Æ°á»£c cáº­p nháº­t sau má»—i iteration. Náº¿u closure khÃ´ng táº¡o báº£n sao, táº¥t cáº£ goroutine sáº½ truy cáº­p cÃ¹ng má»™t biáº¿n â€” dáº«n Ä‘áº¿n sai lá»‡ch giÃ¡ trá»‹ hoáº·c race.</p>

<pre><code class="go">// âŒ Sai: táº¥t cáº£ closure in ra cÃ¹ng giÃ¡ trá»‹ cuá»‘i cÃ¹ng
for i := 0; i < 3; i++ {
    go func() {
        fmt.Println(i)
    }()
}
// Káº¿t quáº£ cÃ³ thá»ƒ: 3, 3, 3
</code></pre>

---

<h3>âœ… CÃ¡ch fix: táº¡o báº£n sao biáº¿n vÃ²ng láº·p</h3>

<pre><code class="go">for i := 0; i < 3; i++ {
    iCopy := i
    go func() {
        fmt.Println(iCopy) // In Ä‘Ãºng 0, 1, 2
    }()
}
</code></pre>

<h3>âœ… Hoáº·c truyá»n biáº¿n lÃ m tham sá»‘ cho closure</h3>

<pre><code class="go">for i := 0; i < 3; i++ {
    go func(val int) {
        fmt.Println(val)
    }(i)
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Táº¡i sao táº¥t cáº£ goroutine in cÃ¹ng má»™t giÃ¡ trá»‹ trong vÃ²ng láº·p?</li>
  <li><strong>Tráº£ lá»i:</strong> VÃ¬ closure dÃ¹ng biáº¿n <code>i</code> cá»§a vÃ²ng láº·p, vÃ  <code>i</code> Ä‘Æ°á»£c thay Ä‘á»•i sau má»—i vÃ²ng â†’ táº¥t cáº£ goroutine dÃ¹ng chung biáº¿n nÃ y.</li>

  <li><strong>Q:</strong> CÃ¡ch trÃ¡nh bug nÃ y?</li>
  <li><strong>Tráº£ lá»i:</strong> Táº¡o biáº¿n má»›i trong tá»«ng vÃ²ng láº·p (shadowing) hoáº·c truyá»n biáº¿n Ä‘Ã³ vÃ o func nhÆ° tham sá»‘.</li>

  <li><strong>Q:</strong> ÄÃ¢y lÃ  lá»—i runtime hay compile-time?</li>
  <li><strong>Tráº£ lá»i:</strong> LÃ  lá»—i logic â€“ compile váº«n cháº¡y, nhÆ°ng káº¿t quáº£ khÃ´ng Ä‘Ãºng â†’ khÃ³ debug náº¿u khÃ´ng hiá»ƒu closure scope.</li>
</ul>


<h2 id="mistake-3-defer-trong-vÃ²ng-láº·p">âŒ Mistake #3 â€“ DÃ¹ng defer trong vÃ²ng láº·p gÃ¢y giá»¯ tÃ i nguyÃªn</h2>

<p><code>defer</code> trong Go sáº½ chá»‰ Ä‘Æ°á»£c thá»±c thi khi hÃ m káº¿t thÃºc. Náº¿u Ä‘áº·t defer trong vÃ²ng láº·p (vÃ­ dá»¥ khi má»Ÿ file, DB, network...), báº¡n sáº½ <strong>giá»¯ tÃ i nguyÃªn Ä‘áº¿n cuá»‘i function</strong> thay vÃ¬ giáº£i phÃ³ng sau má»—i vÃ²ng láº·p.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Go dÃ¹ng mÃ´ hÃ¬nh <code>LIFO</code> cho defer: cÃ ng gá»i defer sau thÃ¬ thá»±c thi cÃ ng trÆ°á»›c. NhÆ°ng náº¿u vÃ²ng láº·p má»Ÿ 100 file vÃ  Ä‘á»u defer close â€“ thÃ¬ táº¥t cáº£ 100 file chá»‰ Ä‘Æ°á»£c Ä‘Ã³ng á»Ÿ cuá»‘i cÃ¹ng â†’ dá»… gÃ¢y <strong>file descriptor leak</strong>.</p>

<pre><code class="go">// âŒ Sai: defer Ä‘Æ°á»£c hoÃ£n Ä‘áº¿n háº¿t vÃ²ng láº·p â†’ quÃ¡ nhiá»u file má»Ÿ
for _, path := range files {
    f, err := os.Open(path)
    if err != nil {
        continue
    }
    defer f.Close()
    // xá»­ lÃ½ file
}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: gá»i close ngay trong vÃ²ng láº·p</h3>

<pre><code class="go">for _, path := range files {
    f, err := os.Open(path)
    if err != nil {
        continue
    }

    // dÃ¹ng anonymous func Ä‘á»ƒ defer Ä‘Æ°á»£c thá»±c thi Ä‘Ãºng thá»i Ä‘iá»ƒm
    func() {
        defer f.Close()
        // xá»­ lÃ½ file táº¡i Ä‘Ã¢y
    }()
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> VÃ¬ sao khÃ´ng nÃªn dÃ¹ng defer trong vÃ²ng láº·p xá»­ lÃ½ nhiá»u file hoáº·c connection?</li>
  <li><strong>Tráº£ lá»i:</strong> VÃ¬ defer chá»‰ cháº¡y khi function káº¿t thÃºc, nÃªn náº¿u cÃ³ nhiá»u iteration â†’ táº¥t cáº£ resource (file, conn) bá»‹ giá»¯ má»Ÿ Ä‘áº¿n cuá»‘i.</li>

  <li><strong>Q:</strong> Go thá»±c thi defer theo thá»© tá»± nÃ o?</li>
  <li><strong>Tráº£ lá»i:</strong> LIFO â€“ Last In First Out. Defer gá»i sau sáº½ Ä‘Æ°á»£c thá»±c thi trÆ°á»›c.</li>

  <li><strong>Q:</strong> Giáº£i phÃ¡p nÃ o Ä‘á»ƒ váº«n dÃ¹ng defer mÃ  khÃ´ng giá»¯ tÃ i nguyÃªn quÃ¡ lÃ¢u?</li>
  <li><strong>Tráº£ lá»i:</strong> Äáº·t defer trong má»™t closure (anonymous function) ná»™i bá»™ má»—i vÃ²ng láº·p â€“ giÃºp thá»±c thi defer ngay khi closure káº¿t thÃºc.</li>
</ul>


<h2 id="mistake-4-truy-cáº­p-map-tá»«-nhiá»u-goroutine">âŒ Mistake #4 â€“ Truy cáº­p map tá»« nhiá»u goroutine khÃ´ng Ä‘á»“ng bá»™</h2>

<p>Trong Go, <code>map</code> khÃ´ng thread-safe. Náº¿u báº¡n Ä‘á»c/ghi map Ä‘á»“ng thá»i tá»« nhiá»u goroutine mÃ  khÃ´ng dÃ¹ng Ä‘á»“ng bá»™ hÃ³a, chÆ°Æ¡ng trÃ¬nh cÃ³ thá»ƒ crash vá»›i lá»—i <code>fatal error: concurrent map read and map write</code>.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Map trong Go Ä‘Æ°á»£c tá»‘i Æ°u cho hiá»‡u nÄƒng Ä‘Æ¡n luá»“ng. Khi cÃ³ concurrent write hoáº·c mix read/write, nÃ³ cÃ³ thá»ƒ bá»‹ panic hoáº·c táº¡o ra race condition khÃ³ debug.</p>

<pre><code class="go">// âŒ Sai: concurrent write gÃ¢y panic
m := make(map[string]int)

for i := 0; i < 10; i++ {
    go func(i int) {
        key := fmt.Sprintf("k%d", i)
        m[key] = i // Ghi Ä‘á»“ng thá»i!
    }(i)
}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: dÃ¹ng sync.Mutex hoáº·c sync.Map</h3>

<pre><code class="go">// âœ… CÃ¡ch 1: sync.Mutex
var mu sync.Mutex
m := make(map[string]int)

for i := 0; i < 10; i++ {
    go func(i int) {
        key := fmt.Sprintf("k%d", i)
        mu.Lock()
        m[key] = i
        mu.Unlock()
    }(i)
}
</code></pre>

<pre><code class="go">// âœ… CÃ¡ch 2: sync.Map (map an toÃ n cho concurrent)
var m sync.Map

for i := 0; i < 10; i++ {
    go func(i int) {
        key := fmt.Sprintf("k%d", i)
        m.Store(key, i)
    }(i)
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Map trong Go cÃ³ thread-safe khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng. Ghi hoáº·c Ä‘á»c/ghi Ä‘á»“ng thá»i mÃ  khÃ´ng khÃ³a sáº½ panic hoáº·c gÃ¢y race condition.</li>

  <li><strong>Q:</strong> LÃ m sao xá»­ lÃ½ map an toÃ n khi dÃ¹ng vá»›i nhiá»u goroutine?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng <code>sync.Mutex</code> Ä‘á»ƒ báº£o vá»‡ tá»«ng thao tÃ¡c, hoáº·c <code>sync.Map</code> náº¿u workload phÃ¹ há»£p (ráº¥t nhiá»u read, Ã­t write).</li>

  <li><strong>Q:</strong> Khi nÃ o nÃªn dÃ¹ng <code>sync.Map</code> thay vÃ¬ <code>map + mutex</code>?</li>
  <li><strong>Tráº£ lá»i:</strong> Khi báº¡n cÃ³ ráº¥t nhiá»u goroutine chá»‰ Ä‘á»c hoáº·c update Ä‘á»™c láº­p tá»«ng key, khÃ´ng cáº§n full control logic.</li>
</ul>


<h2 id="mistake-4-truy-cáº­p-map-tá»«-nhiá»u-goroutine">âŒ Mistake #4 â€“ Truy cáº­p map tá»« nhiá»u goroutine khÃ´ng Ä‘á»“ng bá»™</h2>

<p>Trong Go, <code>map</code> khÃ´ng thread-safe. Náº¿u báº¡n Ä‘á»c/ghi map Ä‘á»“ng thá»i tá»« nhiá»u goroutine mÃ  khÃ´ng dÃ¹ng Ä‘á»“ng bá»™ hÃ³a, chÆ°Æ¡ng trÃ¬nh cÃ³ thá»ƒ crash vá»›i lá»—i <code>fatal error: concurrent map read and map write</code>.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Map trong Go Ä‘Æ°á»£c tá»‘i Æ°u cho hiá»‡u nÄƒng Ä‘Æ¡n luá»“ng. Khi cÃ³ concurrent write hoáº·c mix read/write, nÃ³ cÃ³ thá»ƒ bá»‹ panic hoáº·c táº¡o ra race condition khÃ³ debug.</p>

<pre><code class="go">// âŒ Sai: concurrent write gÃ¢y panic
m := make(map[string]int)

for i := 0; i < 10; i++ {
    go func(i int) {
        key := fmt.Sprintf("k%d", i)
        m[key] = i // Ghi Ä‘á»“ng thá»i!
    }(i)
}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: dÃ¹ng sync.Mutex hoáº·c sync.Map</h3>

<pre><code class="go">// âœ… CÃ¡ch 1: sync.Mutex
var mu sync.Mutex
m := make(map[string]int)

for i := 0; i < 10; i++ {
    go func(i int) {
        key := fmt.Sprintf("k%d", i)
        mu.Lock()
        m[key] = i
        mu.Unlock()
    }(i)
}
</code></pre>

<pre><code class="go">// âœ… CÃ¡ch 2: sync.Map (map an toÃ n cho concurrent)
var m sync.Map

for i := 0; i < 10; i++ {
    go func(i int) {
        key := fmt.Sprintf("k%d", i)
        m.Store(key, i)
    }(i)
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Map trong Go cÃ³ thread-safe khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng. Ghi hoáº·c Ä‘á»c/ghi Ä‘á»“ng thá»i mÃ  khÃ´ng khÃ³a sáº½ panic hoáº·c gÃ¢y race condition.</li>

  <li><strong>Q:</strong> LÃ m sao xá»­ lÃ½ map an toÃ n khi dÃ¹ng vá»›i nhiá»u goroutine?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng <code>sync.Mutex</code> Ä‘á»ƒ báº£o vá»‡ tá»«ng thao tÃ¡c, hoáº·c <code>sync.Map</code> náº¿u workload phÃ¹ há»£p (ráº¥t nhiá»u read, Ã­t write).</li>

  <li><strong>Q:</strong> Khi nÃ o nÃªn dÃ¹ng <code>sync.Map</code> thay vÃ¬ <code>map + mutex</code>?</li>
  <li><strong>Tráº£ lá»i:</strong> Khi báº¡n cÃ³ ráº¥t nhiá»u goroutine chá»‰ Ä‘á»c hoáº·c update Ä‘á»™c láº­p tá»«ng key, khÃ´ng cáº§n full control logic.</li>
</ul>


<h2 id="mistake-5-goroutine-leak-khÃ´ng-listen-channel">âŒ Mistake #5 â€“ Goroutine leak vÃ¬ khÃ´ng listen channel</h2>

<p>Má»™t goroutine gá»­i vÃ o channel mÃ  khÃ´ng cÃ³ ai nháº­n, hoáº·c Ä‘ang block chá» nháº­n mÃ  channel khÃ´ng cÃ³ ai gá»­i â€“ sáº½ bá»‹ <strong>block mÃ£i mÃ£i</strong>. Náº¿u Ä‘iá»u nÃ y xáº£y ra hÃ ng loáº¡t trong production, sáº½ gÃ¢y leak tÃ i nguyÃªn hoáº·c deadlock toÃ n há»‡ thá»‘ng.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Channel trong Go lÃ  <strong>synchronous</strong> náº¿u khÃ´ng cÃ³ buffer. Náº¿u khÃ´ng cÃ³ ai nháº­n (<code>&lt;-chan</code>) thÃ¬ lá»‡nh <code>chan &lt;- value</code> sáº½ block. Náº¿u goroutine block mÃ  khÃ´ng Ä‘Æ°á»£c cancel hoáº·c timeout, nÃ³ sáº½ bá»‹ â€œrÃ² rá»‰â€.</p>

<pre><code class="go">// âŒ Sai â€“ khÃ´ng cÃ³ ai nháº­n tá»« ch, goroutine bá»‹ block mÃ£i mÃ£i
ch := make(chan int)

go func() {
    ch <- 42 // bá»‹ block vÃ¬ khÃ´ng ai Ä‘á»c
}()
</code></pre>

---

<h3>âœ… CÃ¡ch fix #1: luÃ´n Ä‘áº£m báº£o cÃ³ receiver</h3>

<pre><code class="go">ch := make(chan int)

go func() {
    ch <- 42
}()

val := <-ch
fmt.Println("Received:", val)
</code></pre>

<h3>âœ… CÃ¡ch fix #2: dÃ¹ng channel cÃ³ buffer (náº¿u async Ä‘Æ¡n giáº£n)</h3>

<pre><code class="go">ch := make(chan int, 1)

go func() {
    ch <- 42 // OK, vÃ¬ cÃ³ buffer
}()
</code></pre>

<h3>âœ… CÃ¡ch fix #3: dÃ¹ng context Ä‘á»ƒ huá»· goroutine náº¿u bá»‹ block lÃ¢u</h3>

<pre><code class="go">ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()

done := make(chan struct{})

go func() {
    select {
    case <-time.After(10 * time.Second): // giáº£ láº­p block
        done <- struct{}{}
    case <-ctx.Done():
        fmt.Println("Goroutine canceled")
    }
}()
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u má»™t goroutine gá»­i vÃ o channel mÃ  khÃ´ng ai nháº­n?</li>
  <li><strong>Tráº£ lá»i:</strong> Goroutine sáº½ bá»‹ block mÃ£i mÃ£i â†’ gÃ¢y leak vÃ  tÄƒng sá»‘ lÆ°á»£ng goroutine trong runtime.</li>

  <li><strong>Q:</strong> LÃ m sao trÃ¡nh goroutine leak?</li>
  <li><strong>Tráº£ lá»i:</strong> LuÃ´n Ä‘áº£m báº£o:
    <ul>
      <li>CÃ³ ngÆ°á»i nháº­n tá»« channel (hoáº·c channel cÃ³ buffer)</li>
      <li>Goroutine Ä‘Æ°á»£c huá»· báº±ng context timeout hoáº·c cancel</li>
    </ul>
  </li>

  <li><strong>Q:</strong> DÃ¹ng lá»‡nh gÃ¬ Ä‘á»ƒ debug sá»‘ goroutine trong runtime?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng <code>runtime.NumGoroutine()</code> hoáº·c <code>pprof</code> Ä‘á»ƒ kiá»ƒm tra lÆ°á»£ng goroutine hiá»‡n táº¡i.</li>
</ul>


<h2 id="mistake-6-truyá»n-slice-mÃ -tÆ°á»Ÿng-ráº±ng-copy">âŒ Mistake #6 â€“ Truyá»n slice mÃ  tÆ°á»Ÿng ráº±ng copy</h2>

<p>Nhiá»u láº­p trÃ¬nh viÃªn nghÄ© ráº±ng khi truyá»n má»™t <code>slice</code> vÃ o hÃ m, nÃ³ lÃ  copy Ä‘á»™c láº­p. Thá»±c ra, slice chá»‰ lÃ  â€œviewâ€ trÃªn underlying array â€“ tá»©c lÃ  thay Ä‘á»•i slice cÅ©ng thay Ä‘á»•i dá»¯ liá»‡u gá»‘c.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Slice trong Go gá»“m 3 pháº§n: <code>pointer</code> tá»›i máº£ng gá»‘c, <code>length</code> vÃ  <code>capacity</code>. Khi truyá»n slice vÃ o hÃ m, báº¡n chá»‰ copy pháº§n â€œviewâ€, khÃ´ng pháº£i dá»¯ liá»‡u â€“ nÃªn má»i thay Ä‘á»•i sáº½ áº£nh hÆ°á»Ÿng gá»‘c náº¿u dÃ¹ng cÃ¹ng underlying array.</p>

<pre><code class="go">// âŒ Sai: tÆ°á»Ÿng ráº±ng s2 lÃ  báº£n sao
s1 := []int{1, 2, 3}
s2 := s1
s2[0] = 999

fmt.Println(s1) // [999 2 3] â€“ bá»‹ thay Ä‘á»•i theo!
</code></pre>

---

<h3>âœ… CÃ¡ch fix: dÃ¹ng copy() Ä‘á»ƒ táº¡o slice hoÃ n toÃ n má»›i</h3>

<pre><code class="go">s1 := []int{1, 2, 3}
s2 := make([]int, len(s1))
copy(s2, s1)

s2[0] = 999
fmt.Println(s1) // [1 2 3] â€“ an toÃ n
</code></pre>

---

<h3>âœ… Náº¿u muá»‘n read-only: truyá»n slice vÃ  khÃ´ng modify</h3>

<pre><code class="go">func printOnly(data []int) {
    for _, v := range data {
        fmt.Println(v)
    }
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Khi truyá»n slice vÃ o hÃ m, liá»‡u cÃ³ copy dá»¯ liá»‡u khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng. Chá»‰ copy pháº§n view (pointer + len + cap). Dá»¯ liá»‡u váº«n trá» vá» máº£ng gá»‘c.</li>

  <li><strong>Q:</strong> LÃ m sao Ä‘á»ƒ clone slice thá»±c sá»±?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng <code>copy(newSlice, oldSlice)</code> sau khi táº¡o slice má»›i báº±ng <code>make</code>.</li>

  <li><strong>Q:</strong> CÃ³ khi nÃ o 2 slice khÃ¡c nhau nhÆ°ng trá» vá» cÃ¹ng underlying array?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³ â€“ náº¿u slice Ä‘Æ°á»£c cáº¯t tá»« cÃ¹ng má»™t máº£ng hoáº·c slice cha. Äiá»u nÃ y ráº¥t dá»… gÃ¢y bug ngáº§m náº¿u khÃ´ng cáº©n tháº­n.</li>
</ul>

<h2 id="mistake-7-dÃ¹ng-value-receiver-khi-cáº§n-pointer">âŒ Mistake #7 â€“ DÃ¹ng value receiver khi cáº§n pointer</h2>

<p>Khi method Ä‘Æ°á»£c khai bÃ¡o vá»›i <code>value receiver</code>, má»i thay Ä‘á»•i trÃªn struct trong method sáº½ chá»‰ lÃ  báº£n sao â€“ khÃ´ng áº£nh hÆ°á»Ÿng dá»¯ liá»‡u gá»‘c. Náº¿u báº¡n muá»‘n mutate (thay Ä‘á»•i) giÃ¡ trá»‹ trong method, báº¡n pháº£i dÃ¹ng <code>pointer receiver</code>.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Value receiver táº¡o báº£n sao cá»§a struct, má»i thao tÃ¡c trÃªn nÃ³ khÃ´ng lÃ m thay Ä‘á»•i dá»¯ liá»‡u gá»‘c.</p>

<pre><code class="go">// âŒ Sai â€“ name khÃ´ng thay Ä‘á»•i sau SetName
type User struct {
    Name string
}

func (u User) SetName(name string) {
    u.Name = name
}

func main() {
    u := User{}
    u.SetName("Gopher")
    fmt.Println(u.Name) // ""
}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: dÃ¹ng pointer receiver Ä‘á»ƒ mutate dá»¯ liá»‡u</h3>

<pre><code class="go">func (u *User) SetName(name string) {
    u.Name = name
}

func main() {
    u := User{}
    u.SetName("Gopher")
    fmt.Println(u.Name) // "Gopher"
}
</code></pre>

---

<h3>ğŸ¯ Khi nÃ o dÃ¹ng pointer vs value receiver?</h3>
<ul>
  <li>DÃ¹ng <strong>pointer</strong> náº¿u:
    <ul>
      <li>Báº¡n cáº§n thay Ä‘á»•i dá»¯ liá»‡u (mutate)</li>
      <li>Struct cÃ³ kÃ­ch thÆ°á»›c lá»›n â†’ trÃ¡nh copy tá»‘n chi phÃ­</li>
    </ul>
  </li>
  <li>DÃ¹ng <strong>value</strong> náº¿u:
    <ul>
      <li>Struct nhá», thao tÃ¡c Ä‘á»c-only</li>
      <li>KhÃ´ng muá»‘n method gÃ¢y side effect</li>
    </ul>
  </li>
</ul>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> DÃ¹ng value receiver trong method thÃ¬ cÃ³ mutate Ä‘Æ°á»£c dá»¯ liá»‡u khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng. Value receiver hoáº¡t Ä‘á»™ng trÃªn báº£n sao â€“ má»i thay Ä‘á»•i khÃ´ng áº£nh hÆ°á»Ÿng dá»¯ liá»‡u gá»‘c.</li>

  <li><strong>Q:</strong> CÃ³ thá»ƒ gá»i method pointer tá»« biáº¿n struct khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³ â€“ Go tá»± Ä‘á»™ng láº¥y Ä‘á»‹a chá»‰ khi cáº§n. Báº¡n cÃ³ thá»ƒ gá»i <code>u.SetName()</code> dÃ¹ SetName lÃ  method dÃ¹ng <code>*User</code>.</li>

  <li><strong>Q:</strong> Náº¿u cÃ³ mix pointer vÃ  value receiver trong cÃ¹ng struct, cÃ³ váº¥n Ä‘á» gÃ¬ khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng compile lá»—i, nhÆ°ng gÃ¢y khÃ³ hiá»ƒu vÃ  bug tiá»m áº©n. NÃªn thá»‘ng nháº¥t.</li>
</ul>

<h2 id="mistake-8-context-khÃ´ng-bá»‹-cancel">âŒ Mistake #8 â€“ KhÃ´ng cancel context â†’ goroutine leak</h2>

<p>Go cho phÃ©p truyá»n <code>context.Context</code> Ä‘á»ƒ quáº£n lÃ½ vÃ²ng Ä‘á»i goroutine. Náº¿u báº¡n táº¡o context cÃ³ timeout/cancel nhÆ°ng khÃ´ng gá»i <code>cancel()</code>, goroutine sáº½ tiáº¿p tá»¥c sá»‘ng â€“ gÃ¢y leak tÃ i nguyÃªn vÃ  giá»¯ connection khÃ´ng cáº§n thiáº¿t.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Context lÃ  cÆ¡ cháº¿ tiÃªu chuáº©n trong Go Ä‘á»ƒ huá»· cÃ¡c tÃ¡c vá»¥ dÃ i hoáº·c khÃ´ng cÃ²n cáº§n thiáº¿t. Náº¿u báº¡n khÃ´ng gá»i <code>cancel()</code> vá»›i <code>WithCancel</code>, <code>WithTimeout</code>, hoáº·c <code>WithDeadline</code>, thÃ¬:</p>
<ul>
  <li>Goroutine sáº½ chá» mÃ£i</li>
  <li>Socket hoáº·c DB khÃ´ng Ä‘Æ°á»£c Ä‘Ã³ng</li>
  <li>Runtime cÃ³ thá»ƒ Ä‘áº§y goroutine mÃ  báº¡n khÃ´ng kiá»ƒm soÃ¡t</li>
</ul>

<pre><code class="go">// âŒ Sai â€“ khÃ´ng gá»i cancel
ctx, _ := context.WithTimeout(context.Background(), 2*time.Second)
go func() {
    select {
    case <-ctx.Done():
        fmt.Println("done")
    }
}()
</code></pre>

---

<h3>âœ… CÃ¡ch fix: luÃ´n gá»i cancel (báº±ng defer náº¿u cÃ³ thá»ƒ)</h3>

<pre><code class="go">ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel() // âœ… trÃ¡nh leak

go func() {
    select {
    case <-ctx.Done():
        fmt.Println("done")
    }
}()
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u báº¡n táº¡o context mÃ  khÃ´ng cancel?</li>
  <li><strong>Tráº£ lá»i:</strong> Goroutine sá»­ dá»¥ng context Ä‘Ã³ cÃ³ thá»ƒ khÃ´ng bao giá» Ä‘Æ°á»£c giáº£i phÃ³ng â†’ memory leak hoáº·c giá»¯ tÃ i nguyÃªn quÃ¡ lÃ¢u (DB, socket, HTTP).</li>

  <li><strong>Q:</strong> Khi nÃ o cáº§n gá»i <code>cancel()</code>?</li>
  <li><strong>Tráº£ lá»i:</strong> Ngay sau khi táº¡o context cÃ³ cancel control (WithCancel, WithTimeout, WithDeadline). NÃªn dÃ¹ng <code>defer cancel()</code> Ä‘á»ƒ Ä‘áº£m báº£o.</li>

  <li><strong>Q:</strong> Context propagation cÃ³ há»— trá»£ huá»· nhiá»u táº§ng khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³. Khi má»™t context cha bá»‹ huá»·, toÃ n bá»™ context con sáº½ bá»‹ huá»· theo â†’ ráº¥t quan trá»ng trong há»‡ thá»‘ng microservice hoáº·c job processing.</li>
</ul>

<h2 id="mistake-9-panic-khÃ´ng-Ä‘Æ°á»£c-recover">âŒ Mistake #9 â€“ Panic khÃ´ng Ä‘Æ°á»£c recover Ä‘Ãºng cÃ¡ch</h2>

<p>Go khÃ´ng cÃ³ try-catch nhÆ° cÃ¡c ngÃ´n ngá»¯ khÃ¡c. Thay vÃ o Ä‘Ã³, báº¡n pháº£i dÃ¹ng <code>panic</code>, <code>defer</code> vÃ  <code>recover()</code>. Náº¿u báº¡n khÃ´ng gá»i <code>recover</code> Ä‘Ãºng cÃ¡ch, panic sáº½ crash toÃ n bá»™ chÆ°Æ¡ng trÃ¬nh â€“ ká»ƒ cáº£ khi xáº£y ra trong 1 goroutine nhá».</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p><code>recover()</code> chá»‰ hoáº¡t Ä‘á»™ng khi Ä‘Æ°á»£c gá»i bÃªn trong má»™t <code>defer</code> trong cÃ¹ng goroutine vá»›i panic. Náº¿u gá»i ngoÃ i <code>defer</code>, hoáº·c gá»i trong goroutine khÃ¡c â†’ khÃ´ng cÃ³ tÃ¡c dá»¥ng.</p>

<pre><code class="go">// âŒ Sai â€“ panic khÃ´ng Ä‘Æ°á»£c recover â†’ program crash
func main() {
    recover() // khÃ´ng cÃ³ tÃ¡c dá»¥ng
    panic("BOOM")
}
</code></pre>

---

<h3>âœ… CÃ¡ch Ä‘Ãºng: recover trong defer</h3>

<pre><code class="go">func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("ÄÃ£ recover tá»« panic:", r)
        }
    }()
    panic("BOOM") // khÃ´ng crash
}
</code></pre>

---

<h3>âœ… Recover goroutine riÃªng biá»‡t</h3>

<pre><code class="go">go func() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in goroutine:", r)
        }
    }()
    panic("panic trong goroutine")
}()
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Äiá»u kiá»‡n Ä‘á»ƒ <code>recover()</code> hoáº¡t Ä‘á»™ng?</li>
  <li><strong>Tráº£ lá»i:</strong> Pháº£i Ä‘Æ°á»£c gá»i trong <code>defer</code> náº±m trong cÃ¹ng goroutine vá»›i panic. Náº¿u gá»i ngoÃ i defer hoáº·c trong goroutine khÃ¡c, recover khÃ´ng cÃ³ tÃ¡c dá»¥ng.</li>

  <li><strong>Q:</strong> á»¨ng dá»¥ng nÃ o trong thá»±c táº¿ cáº§n recover?</li>
  <li><strong>Tráº£ lá»i:</strong> Middleware HTTP (nhÆ° gin, echo), worker job pool, consumer message queue â€“ báº¥t ká»³ nÆ¡i nÃ o báº¡n cáº§n giá»¯ server cháº¡y á»•n Ä‘á»‹nh dÃ¹ gáº·p lá»—i báº¥t ngá».</li>

  <li><strong>Q:</strong> Recover cÃ³ dá»«ng Ä‘Æ°á»£c toÃ n bá»™ crash khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³, nhÆ°ng pháº£i dÃ¹ng Ä‘Ãºng cÃ¡ch. NÃªn log láº¡i panic, traceID, vÃ  context Ä‘á»ƒ dá»… debug. Tuyá»‡t Ä‘á»‘i khÃ´ng â€œnuá»‘tâ€ lá»—i trong silence.</li>
</ul>

<h2 id="mistake-10-type-assertion-khÃ´ng-check-ok">âŒ Mistake #10 â€“ Type assertion khÃ´ng check <code>ok</code></h2>

<p>Khi dÃ¹ng <code>interface{}</code>, Ä‘á»ƒ láº¥y giÃ¡ trá»‹ tháº­t, báº¡n pháº£i dÃ¹ng type assertion. Náº¿u báº¡n khÃ´ng kiá»ƒm tra <code>ok</code> khi Ã©p kiá»ƒu vÃ  loáº¡i khÃ´ng khá»›p â€“ chÆ°Æ¡ng trÃ¬nh sáº½ panic.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Type assertion trong Go cÃ³ 2 dáº¡ng:</p>
<ul>
  <li><code>val := i.(T)</code> â†’ panic náº¿u <code>i</code> khÃ´ng chá»©a type <code>T</code></li>
  <li><code>val, ok := i.(T)</code> â†’ an toÃ n, khÃ´ng panic, kiá»ƒm tra Ä‘Æ°á»£c káº¿t quáº£</li>
</ul>

<pre><code class="go">// âŒ Sai â€“ khÃ´ng kiá»ƒm tra kiá»ƒu â†’ panic náº¿u sai
var i interface{} = "hello"
n := i.(int) // panic: interface conversion: string is not int
</code></pre>

---

<h3>âœ… CÃ¡ch fix: kiá»ƒm tra <code>ok</code></h3>

<pre><code class="go">var i interface{} = "hello"
n, ok := i.(int)
if ok {
    fmt.Println("Value:", n)
} else {
    fmt.Println("Sai kiá»ƒu: khÃ´ng pháº£i int")
}
</code></pre>

---

<h3>âœ… DÃ¹ng type switch náº¿u cáº§n xá»­ lÃ½ nhiá»u kiá»ƒu</h3>

<pre><code class="go">switch v := i.(type) {
case string:
    fmt.Println("Chuá»—i:", v)
case int:
    fmt.Println("Sá»‘ nguyÃªn:", v)
default:
    fmt.Println("KhÃ´ng xÃ¡c Ä‘á»‹nh")
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u type assertion sai kiá»ƒu mÃ  khÃ´ng check <code>ok</code>?</li>
  <li><strong>Tráº£ lá»i:</strong> ChÆ°Æ¡ng trÃ¬nh sáº½ panic ngay â€“ gÃ¢y crash náº¿u khÃ´ng Ä‘Æ°á»£c recover.</li>

  <li><strong>Q:</strong> Khi nÃ o nÃªn dÃ¹ng type assertion?</li>
  <li><strong>Tráº£ lá»i:</strong> Khi báº¡n xá»­ lÃ½ <code>interface{}</code> vÃ  biáº¿t trÆ°á»›c kiá»ƒu. Náº¿u khÃ´ng cháº¯c cháº¯n â†’ luÃ´n check <code>ok</code> hoáº·c dÃ¹ng type switch.</li>

  <li><strong>Q:</strong> CÃ³ khÃ¡c gÃ¬ giá»¯a <code>i.(T)</code> vÃ  <code>i.(*T)</code>?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng â€“ Ä‘á»u lÃ  assertion vá» type. NhÆ°ng báº¡n pháº£i khá»›p exact type (pointer â‰  value).</li>
</ul>

<h2 id="mistake-11-slice-capacity-bá»‹-giá»¯-ngáº§m">âŒ Mistake #11 â€“ Slice giá»¯ capacity ngáº§m gÃ¢y memory leak</h2>

<p>Khi báº¡n cáº¯t má»™t slice tá»« má»™t slice lá»›n hÆ¡n, báº¡n cÃ³ thá»ƒ vÃ´ tÃ¬nh giá»¯ láº¡i toÃ n bá»™ underlying array â€“ dÃ¹ báº¡n chá»‰ dÃ¹ng má»™t pháº§n nhá». Äiá»u nÃ y khiáº¿n bá»™ nhá»› khÃ´ng Ä‘Æ°á»£c giáº£i phÃ³ng â†’ <strong>memory leak</strong> ngáº§m.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Slice trong Go trá» vá» cÃ¹ng underlying array. Khi báº¡n cáº¯t slice con, pháº§n cÃ²n láº¡i cá»§a array váº«n Ä‘Æ°á»£c giá»¯ trong bá»™ nhá»› náº¿u báº¡n khÃ´ng tÃ¡ch riÃªng nÃ³.</p>

<pre><code class="go">// âŒ Sai â€“ giá»¯ cáº£ array dÃ¹ chá»‰ cáº§n 1 pháº§n
data := make([]byte, 1000000)
sub := data[:10] // sub giá»¯ nguyÃªn underlying array 1MB!
process(sub)
</code></pre>

---

<h3>âœ… CÃ¡ch fix: copy slice con ra slice má»›i</h3>

<pre><code class="go">data := make([]byte, 1000000)
sub := make([]byte, 10)
copy(sub, data[:10]) // chá»‰ giá»¯ 10 byte
process(sub)
</code></pre>

---

<h3>âœ… DÃ¹ng append vá»›i nil slice cÅ©ng lÃ  cÃ¡ch táº¡o báº£n sao</h3>

<pre><code class="go">sub := append([]byte(nil), data[:10]...)
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Khi slice má»™t máº£ng lá»›n, báº¡n cÃ³ cháº¯c bá»™ nhá»› Ä‘Æ°á»£c giáº£i phÃ³ng khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng cháº¯c. Náº¿u slice má»›i váº«n dÃ¹ng cÃ¹ng underlying array, pháº§n cÃ²n láº¡i váº«n bá»‹ giá»¯.</li>

  <li><strong>Q:</strong> LÃ m sao Ä‘áº£m báº£o slice khÃ´ng giá»¯ bá»™ nhá»› dÆ°?</li>
  <li><strong>Tráº£ lá»i:</strong> Copy slice ra slice má»›i vá»›i <code>copy()</code> hoáº·c <code>append([]T(nil), ...)</code>.</li>

  <li><strong>Q:</strong> CÃ³ tool nÃ o giÃºp phÃ¡t hiá»‡n lá»—i nÃ y?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³ â€“ dÃ¹ng <code>pprof</code> Ä‘á»ƒ xem heap profile hoáº·c <code>staticcheck</code> Ä‘á»ƒ cáº£nh bÃ¡o slice aliasing.</li>
</ul>


<h2 id="mistake-12-ghi-map-áº©n-trong-json">âŒ Mistake #12 â€“ Map khi marshal JSON cÃ³ thá»© tá»± khÃ´ng xÃ¡c Ä‘á»‹nh</h2>

<p>Nhiá»u láº­p trÃ¬nh viÃªn mong Ä‘á»£i ráº±ng khi <code>json.Marshal</code> má»™t map trong Go, káº¿t quáº£ sáº½ giá»¯ nguyÃªn thá»© tá»± key. Thá»±c táº¿ thÃ¬ khÃ´ng â€“ thá»© tá»± <strong>khÃ´ng Ä‘Æ°á»£c Ä‘áº£m báº£o</strong>, vÃ¬ Go map lÃ  unordered by design.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Map trong Go Ä‘Æ°á»£c thiáº¿t káº¿ lÃ  <strong>khÃ´ng cÃ³ thá»© tá»±</strong>. Má»—i láº§n báº¡n láº·p qua map hoáº·c marshal JSON tá»« map, thá»© tá»± key cÃ³ thá»ƒ khÃ¡c nhau, tháº­m chÃ­ má»—i láº§n run sáº½ khÃ¡c nhau Ä‘á»ƒ chá»‘ng phá»¥ thuá»™c vÃ o thá»© tá»±.</p>

<pre><code class="go">// âŒ Sai â€“ thá»© tá»± key khÃ´ng á»•n Ä‘á»‹nh
m := map[string]int{
    "a": 1,
    "b": 2,
    "c": 3,
}
data, _ := json.Marshal(m)
fmt.Println(string(data)) // cÃ³ thá»ƒ lÃ  {"b":2,"a":1,"c":3}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: dÃ¹ng struct hoáº·c slice key-value cÃ³ thá»© tá»±</h3>

<pre><code class="go">type Entry struct {
    Key   string `json:"key"`
    Value int    `json:"value"`
}

entries := []Entry{
    {"a", 1},
    {"b", 2},
    {"c", 3},
}
data, _ := json.Marshal(entries)
fmt.Println(string(data)) // [{"key":"a","value":1},...]
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Táº¡i sao map trong Go khÃ´ng cÃ³ thá»© tá»±?</li>
  <li><strong>Tráº£ lá»i:</strong> VÃ¬ map Ä‘Æ°á»£c thiáº¿t káº¿ Ä‘á»ƒ optimize cho tá»‘c Ä‘á»™ truy cáº­p, khÃ´ng pháº£i cho iteration order â€“ tá»« Go 1.12 trá»Ÿ Ä‘i cÃ²n deliberately randomized Ä‘á»ƒ trÃ¡nh phá»¥ thuá»™c.</li>

  <li><strong>Q:</strong> LÃ m sao Ä‘á»ƒ giá»¯ thá»© tá»± khi marshal JSON tá»« dá»¯ liá»‡u map?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng struct slice, hoáº·c build <code>[]Entry</code> rá»“i marshal â€“ báº¡n cÃ³ toÃ n quyá»n kiá»ƒm soÃ¡t thá»© tá»±.</li>

  <li><strong>Q:</strong> CÃ³ thá»ƒ kiá»ƒm soÃ¡t thá»© tá»± trong map khi dÃ¹ng <code>range</code> khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng. Náº¿u cáº§n, hÃ£y sort key riÃªng vÃ  láº·p theo key slice.</li>
</ul>


<h2 id="mistake-13-defer-cÃ³-thá»©-tá»±-lifo">âŒ Mistake #13 â€“ Nháº§m láº«n thá»© tá»± thá»±c thi defer (LIFO)</h2>

<p>Nhiá»u láº­p trÃ¬nh viÃªn nháº§m tÆ°á»Ÿng cÃ¡c lá»‡nh <code>defer</code> trong Go Ä‘Æ°á»£c thá»±c thi theo thá»© tá»± xuáº¥t hiá»‡n. Thá»±c táº¿, <strong>defer Ä‘Æ°á»£c thá»±c thi theo kiá»ƒu LIFO</strong> â€“ Last In, First Out.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Má»—i khi Go gáº·p lá»‡nh <code>defer</code>, nÃ³ push vÃ o stack. Khi hÃ m káº¿t thÃºc, cÃ¡c lá»‡nh Ä‘Æ°á»£c pop ra vÃ  thá»±c thi theo thá»© tá»± ngÆ°á»£c láº¡i. Äiá»u nÃ y cá»±c ká»³ quan trá»ng khi báº¡n cáº§n release resource hoáº·c debug theo trace.</p>

<pre><code class="go">// âŒ Nháº§m tÆ°á»Ÿng in ra 1 â†’ 2 â†’ 3
func main() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
}
// Káº¿t quáº£ thá»±c táº¿: 3 â†’ 2 â†’ 1
</code></pre>

---

<h3>âœ… á»¨ng dá»¥ng Ä‘Ãºng: xá»­ lÃ½ resource, trace, rollback</h3>

<pre><code class="go">defer unlock()
defer log("done")
defer rollback()
</code></pre>

<p>Thá»© tá»± thá»±c thi: rollback â†’ log â†’ unlock</p>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Defer Ä‘Æ°á»£c thá»±c thi theo thá»© tá»± nÃ o?</li>
  <li><strong>Tráº£ lá»i:</strong> Theo nguyÃªn táº¯c LIFO â€“ lá»‡nh <code>defer</code> gá»i sau sáº½ Ä‘Æ°á»£c thá»±c thi trÆ°á»›c.</li>

  <li><strong>Q:</strong> Náº¿u trong nhiá»u defer cÃ³ panic, chuyá»‡n gÃ¬ xáº£y ra?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ¡c defer trÆ°á»›c panic váº«n cháº¡y. NhÆ°ng náº¿u panic xáº£y ra trong chÃ­nh defer, chÆ°Æ¡ng trÃ¬nh sáº½ crash náº¿u khÃ´ng recover.</li>

  <li><strong>Q:</strong> Khi nÃ o nÃªn dÃ¹ng nhiá»u defer?</li>
  <li><strong>Tráº£ lá»i:</strong> Khi báº¡n cáº§n Ä‘Ã³ng nhiá»u tÃ i nguyÃªn theo thá»© tá»± ngÆ°á»£c láº¡i lÃºc má»Ÿ: file, lock, transaction, network streamâ€¦</li>
</ul>


<h2 id="mistake-14-buffered-channel-váº«n-deadlock">âŒ Mistake #14 â€“ Buffered channel váº«n cÃ³ thá»ƒ gÃ¢y deadlock</h2>

<p>Nhiá»u ngÆ°á»i nghÄ© ráº±ng <code>buffered channel</code> sáº½ luÃ´n trÃ¡nh Ä‘Æ°á»£c deadlock. Thá»±c táº¿, náº¿u sá»‘ lÆ°á»£ng gá»­i vÆ°á»£t quÃ¡ buffer mÃ  khÃ´ng cÃ³ consumer ká»‹p thá»i â€“ chÆ°Æ¡ng trÃ¬nh váº«n sáº½ <strong>block vÃ  deadlock</strong>.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Buffered channel chá»‰ cho phÃ©p <code>n</code> lá»‡nh gá»­i khÃ´ng block (vá»›i <code>n</code> lÃ  buffer size). Sau Ä‘Ã³, náº¿u khÃ´ng cÃ³ ngÆ°á»i nháº­n, lá»‡nh gá»­i tiáº¿p theo sáº½ block. ÄÃ¢y lÃ  behavior hoÃ n toÃ n giá»‘ng nhÆ° unbuffered channel sau khi Ä‘áº§y.</p>

<pre><code class="go">// âŒ Sai â€“ gá»­i quÃ¡ buffer nhÆ°ng khÃ´ng cÃ³ ngÆ°á»i nháº­n
ch := make(chan int, 2)
ch <- 1
ch <- 2
ch <- 3 // deadlock táº¡i Ä‘Ã¢y!
</code></pre>

---

<h3>âœ… CÃ¡ch fix #1: táº¡o consumer ká»‹p thá»i</h3>

<pre><code class="go">ch := make(chan int, 2)

go func() {
    for v := range ch {
        fmt.Println("Received:", v)
    }
}()

ch <- 1
ch <- 2
ch <- 3
close(ch)
</code></pre>

<h3>âœ… CÃ¡ch fix #2: khÃ´ng gá»­i quÃ¡ má»©c buffer náº¿u khÃ´ng cÃ³ receiver</h3>

<pre><code class="go">if len(ch) < cap(ch) {
    ch <- value
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Buffered channel cÃ³ giÃºp trÃ¡nh deadlock khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng hoÃ n toÃ n. NÃ³ chá»‰ giÃºp gá»­i khÃ´ng block <strong>tá»›i giá»›i háº¡n buffer</strong>. Sau Ä‘Ã³ váº«n block náº¿u khÃ´ng cÃ³ receiver.</li>

  <li><strong>Q:</strong> LÃ m sao Ä‘á»ƒ trÃ¡nh deadlock vá»›i buffered channel?</li>
  <li><strong>Tráº£ lá»i:</strong> LuÃ´n Ä‘áº£m báº£o:
    <ul>
      <li>CÃ³ receiver cháº¡y song song trÆ°á»›c khi gá»­i</li>
      <li>KhÃ´ng gá»­i vÆ°á»£t buffer náº¿u chÆ°a cháº¯c cÃ³ ngÆ°á»i nháº­n</li>
    </ul>
  </li>

  <li><strong>Q:</strong> CÃ³ nÃªn dÃ¹ng buffered channel nhÆ° hÃ ng Ä‘á»£i?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³ â€“ nhÆ°ng chá»‰ khi báº¡n kiá»ƒm soÃ¡t tá»‘t sá»‘ lÆ°á»£ng message vÃ  Ä‘áº£m báº£o drain ká»‹p thá»i.</li>
</ul>

<h2 id="mistake-15-pointer-trÃªn-loop-variable">âŒ Mistake #15 â€“ Trá» tá»›i biáº¿n vÃ²ng láº·p â†’ táº¥t cáº£ trá» cÃ¹ng Ä‘á»‹a chá»‰</h2>

<p>Khi báº¡n dÃ¹ng <code>range</code> vÃ  láº¥y Ä‘á»‹a chá»‰ cá»§a biáº¿n vÃ²ng láº·p, táº¥t cáº£ pointer cÃ³ thá»ƒ trá» vá» cÃ¹ng má»™t vÃ¹ng nhá»› â€“ gÃ¢y bug khÃ³ phÃ¡t hiá»‡n vÃ¬ dá»¯ liá»‡u bá»‹ ghi Ä‘Ã¨ lÃªn nhau.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Biáº¿n láº·p <code>v</code> trong <code>for _, v := range slice</code> lÃ  biáº¿n Ä‘Æ°á»£c <strong>reuse</strong> qua má»—i vÃ²ng â€“ khÃ´ng pháº£i má»—i láº§n táº¡o biáº¿n má»›i. Khi báº¡n láº¥y Ä‘á»‹a chá»‰ <code>&v</code> â†’ táº¥t cáº£ pháº§n tá»­ trong káº¿t quáº£ Ä‘á»u trá» cÃ¹ng Ä‘á»‹a chá»‰.</p>

<pre><code class="go">// âŒ Sai â€“ táº¥t cáº£ p Ä‘á»u trá» Ä‘áº¿n cÃ¹ng 1 biáº¿n v
s := []string{"a", "b", "c"}
ptrs := []*string{}

for _, v := range s {
    ptrs = append(ptrs, &v)
}

for _, p := range ptrs {
    fmt.Println(*p) // in "c", "c", "c"
}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: táº¡o biáº¿n má»›i trong scope vÃ²ng láº·p</h3>

<pre><code class="go">for _, v := range s {
    val := v
    ptrs = append(ptrs, &val)
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> VÃ¬ sao <code>&v</code> trong vÃ²ng láº·p <code>range</code> khÃ´ng táº¡o pointer khÃ¡c nhau?</li>
  <li><strong>Tráº£ lá»i:</strong> VÃ¬ <code>v</code> Ä‘Æ°á»£c reuse qua má»—i vÃ²ng â€“ nÃ³ lÃ  1 biáº¿n duy nháº¥t. Táº¥t cáº£ pointer Ä‘á»u trá» vá» cÃ¹ng Ä‘á»‹a chá»‰.</li>

  <li><strong>Q:</strong> CÃ¡ch nÃ o Ä‘á»ƒ má»—i pointer trá» Ä‘áº¿n Ä‘Ãºng pháº§n tá»­?</li>
  <li><strong>Tráº£ lá»i:</strong> Táº¡o biáº¿n má»›i trong thÃ¢n vÃ²ng láº·p (<code>val := v</code>) rá»“i láº¥y Ä‘á»‹a chá»‰ <code>&val</code>.</li>

  <li><strong>Q:</strong> DÃ¹ng slice index trá»±c tiáº¿p Ä‘á»ƒ láº¥y Ä‘á»‹a chá»‰ thÃ¬ cÃ³ an toÃ n khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³ â€“ <code>&s[i]</code> lÃ  Ä‘á»‹a chá»‰ pháº§n tá»­ thá»±c trong slice, khÃ´ng bá»‹ áº£nh hÆ°á»Ÿng bá»Ÿi reuse.</li>
</ul>


<h2 id="mistake-16-lá»—i-fmtprintf-sai-kiá»ƒu">âŒ Mistake #16 â€“ DÃ¹ng fmt.Printf sai kiá»ƒu Ä‘á»‹nh dáº¡ng</h2>

<p>Go khÃ´ng kiá»ƒm tra kiá»ƒu Ä‘á»‹nh dáº¡ng `Printf` lÃºc compile, nhÆ°ng náº¿u báº¡n dÃ¹ng sai Ä‘á»‹nh dáº¡ng (format specifier), output sáº½ sai â€“ hoáº·c tá»‡ hÆ¡n lÃ  crash, gÃ¢y lá»—i runtime hoáº·c output khÃ´ng Ä‘á»c Ä‘Æ°á»£c.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>CÃ¡c hÃ m nhÆ° <code>fmt.Printf</code>, <code>fmt.Sprintf</code> dÃ¹ng cÃ¡c Ä‘á»‹nh dáº¡ng nhÆ° <code>%d</code> (int), <code>%s</code> (string), <code>%f</code> (float)... Náº¿u truyá»n nháº§m kiá»ƒu â€“ vÃ­ dá»¥ <code>%d</code> mÃ  truyá»n string â€“ káº¿t quáº£ in ra sáº½ sai hoáº·c panic trong cÃ¡c trÆ°á»ng há»£p nháº¥t Ä‘á»‹nh.</p>

<pre><code class="go">// âŒ Sai â€“ truyá»n string cho %d
name := "Gopher"
fmt.Printf("TÃªn: %d\n", name) // runtime warning hoáº·c káº¿t quáº£ rÃ¡c
</code></pre>

---

<h3>âœ… CÃ¡ch fix: dÃ¹ng Ä‘Ãºng Ä‘á»‹nh dáº¡ng tÆ°Æ¡ng á»©ng vá»›i kiá»ƒu dá»¯ liá»‡u</h3>

<pre><code class="go">fmt.Printf("TÃªn: %s\n", name) // âœ… Ä‘Ãºng format
</code></pre>

---

<h3>âœ… Báº­t `go vet` Ä‘á»ƒ kiá»ƒm tra format sai kiá»ƒu</h3>

<pre><code class="bash">go vet ./...
# report: possible formatting directive mismatch
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u dÃ¹ng `%d` Ä‘á»ƒ in string?</li>
  <li><strong>Tráº£ lá»i:</strong> Output sai Ä‘á»‹nh dáº¡ng (in ra ASCII value hoáº·c giÃ¡ trá»‹ khÃ´ng xÃ¡c Ä‘á»‹nh), Ä‘Ã´i khi lÃ  panic náº¿u káº¿t há»£p nhiá»u lá»—i.</li>

  <li><strong>Q:</strong> LÃ m sao kiá»ƒm tra lá»—i kiá»ƒu Ä‘á»‹nh dáº¡ng khi dÃ¹ng fmt?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng <code>go vet</code> hoáº·c <code>staticcheck</code>. ChÃºng phÃ¢n tÃ­ch vÃ  phÃ¡t hiá»‡n mismatch giá»¯a Ä‘á»‹nh dáº¡ng vÃ  type.</li>

  <li><strong>Q:</strong> CÃ³ Ä‘á»‹nh dáº¡ng nÃ o dÃ¹ng Ä‘Æ°á»£c cho má»i kiá»ƒu?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³, dÃ¹ng <code>%v</code> Ä‘á»ƒ in báº¥t ká»³ giÃ¡ trá»‹ nÃ o theo default format.</li>
</ul>

<h2 id="mistake-17-struct-tag-khÃ´ng-Ä‘Æ°á»£c-parser">âŒ Mistake #17 â€“ Struct tag sai Ä‘á»‹nh dáº¡ng nÃªn bá»‹ bá» qua</h2>

<p>Náº¿u báº¡n viáº¿t sai cÃº phÃ¡p struct tag, Go khÃ´ng bÃ¡o lá»—i compile, nhÆ°ng cÃ¡c thÆ° viá»‡n nhÆ° <code>json.Marshal</code>, <code>gorm</code>, hoáº·c <code>yaml</code> sáº½ silently ignore tag â€“ dáº«n Ä‘áº¿n dá»¯ liá»‡u khÃ´ng map Ä‘Ãºng.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Struct tag trong Go lÃ  string Ä‘á»‹nh dáº¡ng Ä‘áº·c biá»‡t, vÃ­ dá»¥: <code>`json:"field_name"`</code>. Náº¿u báº¡n quÃªn dáº¥u nhÃ¡y kÃ©p hoáº·c viáº¿t nháº§m kiá»ƒu, thÆ° viá»‡n sáº½ khÃ´ng map field Ä‘Ã³.</p>

<pre><code class="go">// âŒ Sai â€“ thiáº¿u dáº¥u nhÃ¡y kÃ©p â†’ json bá»‹ ignore
type User struct {
    Name string `json:name` // khÃ´ng marshal Ä‘Æ°á»£c field "name"
}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: dÃ¹ng cÃº phÃ¡p tag chuáº©n</h3>

<pre><code class="go">type User struct {
    Name string `json:"name"`
}
</code></pre>

---

<h3>âœ… Náº¿u muá»‘n bá» qua field: dÃ¹ng <code>`json:"-"`</code></h3>

<pre><code class="go">Password string `json:"-"`
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u báº¡n viáº¿t sai struct tag?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng cÃ³ lá»—i compile, nhÆ°ng thÆ° viá»‡n sáº½ khÃ´ng Ä‘á»c Ä‘Æ°á»£c tag Ä‘Ã³ â†’ field bá»‹ bá» qua khi marshal/unmarshal.</li>

  <li><strong>Q:</strong> LÃ m sao kiá»ƒm tra tag sai?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng linter nhÆ° <code>staticcheck</code>, <code>golangci-lint</code> hoáº·c test trá»±c tiáº¿p vá»›i JSON Ä‘á»ƒ verify output.</li>

  <li><strong>Q:</strong> CÃ³ thá»ƒ viáº¿t nhiá»u tag cÃ¹ng lÃºc khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³. DÃ¹ng cÃ¡ch viáº¿t: <code>`json:"name" gorm:"column:name"`</code> â€“ chÃº Ã½ pháº£i Ä‘Ãºng Ä‘á»‹nh dáº¡ng & cÃ³ khoáº£ng tráº¯ng giá»¯a cÃ¡c cáº·p.</li>
</ul>


<h2 id="mistake-18-sync-waitgroup-dÃ¹ng-thiáº¿u-done">âŒ Mistake #18 â€“ WaitGroup khÃ´ng gá»i Done â†’ block mÃ£i mÃ£i</h2>

<p>Go cung cáº¥p <code>sync.WaitGroup</code> Ä‘á»ƒ chá» cÃ¡c goroutine hoÃ n táº¥t. NhÆ°ng náº¿u báº¡n quÃªn gá»i <code>wg.Done()</code> sau khi goroutine cháº¡y xong, lá»‡nh <code>wg.Wait()</code> sáº½ chá» mÃ£i mÃ£i â†’ gÃ¢y deadlock.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Khi báº¡n gá»i <code>wg.Add(1)</code>, báº¡n pháº£i Ä‘áº£m báº£o tÆ°Æ¡ng á»©ng gá»i <code>wg.Done()</code>. Náº¿u goroutine panic, return sá»›m hoáº·c gáº·p lá»—i logic khiáº¿n <code>Done()</code> khÃ´ng Ä‘Æ°á»£c gá»i â†’ <code>Wait()</code> khÃ´ng bao giá» káº¿t thÃºc.</p>

<pre><code class="go">// âŒ Sai â€“ quÃªn gá»i Done()
var wg sync.WaitGroup

wg.Add(1)
go func() {
    fmt.Println("run")
    // thiáº¿u wg.Done()
}()

wg.Wait() // block mÃ£i mÃ£i
</code></pre>

---

<h3>âœ… CÃ¡ch fix: luÃ´n dÃ¹ng <code>defer wg.Done()</code> Ä‘á»ƒ Ä‘áº£m báº£o an toÃ n</h3>

<pre><code class="go">wg.Add(1)
go func() {
    defer wg.Done() // âœ… luÃ´n Ä‘áº£m báº£o Ä‘Æ°á»£c gá»i
    fmt.Println("run")
}()
</code></pre>

---

<h3>âœ… Kiá»ƒm soÃ¡t lá»—i vá»›i recover() náº¿u goroutine cÃ³ thá»ƒ panic</h3>

<pre><code class="go">go func() {
    defer wg.Done()
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("panic recovered:", r)
        }
    }()
    doSomethingRisky()
}()
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Äiá»u gÃ¬ xáº£y ra náº¿u báº¡n gá»i <code>Wait()</code> mÃ  thiáº¿u <code>Done()</code>?</li>
  <li><strong>Tráº£ lá»i:</strong> ChÆ°Æ¡ng trÃ¬nh sáº½ block mÃ£i mÃ£i, vÃ¬ counter cá»§a WaitGroup khÃ´ng bao giá» vá» 0.</li>

  <li><strong>Q:</strong> Táº¡i sao nÃªn dÃ¹ng <code>defer wg.Done()</code> trong goroutine?</li>
  <li><strong>Tráº£ lá»i:</strong> Äá»ƒ Ä‘áº£m báº£o <code>Done()</code> luÃ´n Ä‘Æ°á»£c gá»i â€“ ká»ƒ cáº£ khi cÃ³ panic hoáº·c return sá»›m.</li>

  <li><strong>Q:</strong> WaitGroup cÃ³ thread-safe khÃ´ng? CÃ³ thá»ƒ gá»i tá»« nhiá»u goroutine?</li>
  <li><strong>Tráº£ lá»i:</strong> CÃ³ â€“ WaitGroup Ä‘Æ°á»£c thiáº¿t káº¿ Ä‘á»ƒ gá»i <code>Add</code>, <code>Done</code>, vÃ  <code>Wait</code> tá»« cÃ¡c goroutine khÃ¡c nhau.</li>
</ul>

<h2 id="mistake-19-khÃ´ng-wrap-error-gá»‘c">âŒ Mistake #19 â€“ KhÃ´ng wrap error â†’ máº¥t ngá»¯ cáº£nh khi debug</h2>

<p>Náº¿u báº¡n chá»‰ tráº£ vá» lá»—i gá»‘c mÃ  khÃ´ng wrap (gÃ³i) láº¡i, báº¡n sáº½ máº¥t ngá»¯ cáº£nh: lá»—i xáº£y ra á»Ÿ Ä‘Ã¢u, trong tÃ¬nh huá»‘ng gÃ¬. Äiá»u nÃ y khiáº¿n viá»‡c debug trong production trá»Ÿ nÃªn cá»±c ká»³ khÃ³ khÄƒn.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Go 1.13+ há»— trá»£ wrap error báº±ng <code>fmt.Errorf(... %w ...)</code>. Äiá»u nÃ y giÃºp báº¡n:</p>
<ul>
  <li>Giá»¯ lá»—i gá»‘c (Ä‘á»ƒ dÃ¹ng <code>errors.Is</code>, <code>errors.As</code>)</li>
  <li>ThÃªm ngá»¯ cáº£nh phÃ­a trÃªn stack: function, service, param</li>
  <li>Hiá»ƒn thá»‹ lá»—i cÃ³ trace rÃµ rÃ ng trong log</li>
</ul>

<pre><code class="go">// âŒ Sai â€“ return lá»—i thÃ´, khÃ´ng rÃµ Ä‘áº¿n tá»« Ä‘Ã¢u
if err := repo.Save(user); err != nil {
    return err
}
</code></pre>

---

<h3>âœ… CÃ¡ch fix: wrap lá»—i vá»›i ngá»¯ cáº£nh</h3>

<pre><code class="go">if err := repo.Save(user); err != nil {
    return fmt.Errorf("user service: save failed: %w", err)
}
</code></pre>

---

<h3>âœ… DÃ¹ng <code>errors.Is</code> vÃ  <code>errors.As</code> Ä‘á»ƒ phÃ¢n tÃ­ch chain lá»—i</h3>

<pre><code class="go">if errors.Is(err, sql.ErrNoRows) {
    // xá»­ lÃ½ lá»—i cá»¥ thá»ƒ
}
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> VÃ¬ sao nÃªn wrap error thay vÃ¬ return trá»±c tiáº¿p?</li>
  <li><strong>Tráº£ lá»i:</strong> Äá»ƒ giá»¯ lá»—i gá»‘c vÃ  thÃªm ngá»¯ cáº£nh má»›i. Äiá»u nÃ y giÃºp trace Ä‘Æ°á»£c chuá»—i call gÃ¢y lá»—i.</li>

  <li><strong>Q:</strong> Sá»± khÃ¡c biá»‡t giá»¯a <code>%w</code> vÃ  <code>%v</code> trong fmt.Errorf lÃ  gÃ¬?</li>
  <li><strong>Tráº£ lá»i:</strong> <code>%w</code> dÃ¹ng Ä‘á»ƒ wrap error cho <code>errors.Is/As</code>. <code>%v</code> chá»‰ format chuá»—i, khÃ´ng wrap Ä‘Æ°á»£c.</li>

  <li><strong>Q:</strong> Náº¿u báº¡n wrap error nhiá»u láº§n, cÃ³ máº¥t lá»—i gá»‘c khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> KhÃ´ng â€“ báº¡n cÃ³ thá»ƒ unwrap chain nhiá»u táº§ng Ä‘á»ƒ tÃ¬m lá»—i gá»‘c báº±ng <code>errors.Unwrap()</code>.</li>
</ul>

<h2 id="mistake-20-shadow-biáº¿n-lÃ m-hiá»ƒu-nháº§m-logic">âŒ Mistake #20 â€“ Biáº¿n bá»‹ shadow trong block â†’ bug ngáº§m</h2>

<p>Trong Go, báº¡n cÃ³ thá»ƒ khai bÃ¡o má»™t biáº¿n má»›i trÃ¹ng tÃªn biáº¿n cÅ© trong pháº¡m vi háº¹p hÆ¡n. Äiá»u nÃ y Ä‘Æ°á»£c gá»i lÃ  <strong>variable shadowing</strong>. Náº¿u khÃ´ng cáº©n tháº­n, báº¡n sáº½ thao tÃ¡c sai biáº¿n mÃ  khÃ´ng nháº­n ra.</p>

<h3>ğŸ§  Giáº£i thÃ­ch</h3>
<p>Dáº¥u <code>:=</code> trong Go sáº½ khai bÃ¡o biáº¿n má»›i náº¿u cÃ³ Ã­t nháº¥t má»™t biáº¿n chÆ°a tá»“n táº¡i trong scope hiá»‡n táº¡i. Náº¿u báº¡n dÃ¹ng láº¡i tÃªn biáº¿n cÅ© vá»›i <code>:=</code>, nÃ³ khÃ´ng cáº­p nháº­t biáº¿n cÅ© â€“ mÃ  táº¡o biáº¿n má»›i trong scope má»›i â†’ logic cÃ³ thá»ƒ sai hoÃ n toÃ n.</p>

<pre><code class="go">// âŒ Sai â€“ biáº¿n err bá»‹ shadow â†’ log khÃ´ng Ä‘Ãºng lá»—i tháº­t
var err error
if err := doSomething(); err != nil {
    log.Println("error:", err) // OK
}
fmt.Println(err) // err ban Ä‘áº§u váº«n lÃ  nil!
</code></pre>

---

<h3>âœ… CÃ¡ch fix: tÃ¡ch riÃªng biáº¿n má»›i hoáº·c dÃ¹ng <code>=</code> náº¿u biáº¿n Ä‘Ã£ tá»“n táº¡i</h3>

<pre><code class="go">err = doSomething()
if err != nil {
    log.Println("error:", err)
}
</code></pre>

---

<h3>âœ… DÃ¹ng linter Ä‘á»ƒ phÃ¡t hiá»‡n shadow</h3>

<pre><code class="bash">golangci-lint run --enable=shadow
</code></pre>

---

<h3>ğŸ¯ CÃ¢u há»i phá»ng váº¥n</h3>
<ul>
  <li><strong>Q:</strong> Variable shadowing lÃ  gÃ¬? CÃ³ gÃ¢y bug khÃ´ng?</li>
  <li><strong>Tráº£ lá»i:</strong> LÃ  viá»‡c khai bÃ¡o biáº¿n má»›i trÃ¹ng tÃªn vá»›i biáº¿n cÅ© trong block nhá» hÆ¡n. CÃ³ thá»ƒ gÃ¢y bug vÃ¬ tÆ°á»Ÿng ráº±ng Ä‘ang dÃ¹ng biáº¿n ngoÃ i nhÆ°ng thá»±c cháº¥t lÃ  biáº¿n má»›i.</li>

  <li><strong>Q:</strong> LÃ m sao Ä‘á»ƒ trÃ¡nh bug do shadow biáº¿n?</li>
  <li><strong>Tráº£ lá»i:</strong> DÃ¹ng <code>=</code> náº¿u biáº¿n Ä‘Ã£ khai bÃ¡o, trÃ¡nh láº·p <code>:=</code>. Báº­t linter nhÆ° <code>shadow</code> Ä‘á»ƒ cáº£nh bÃ¡o.</li>

  <li><strong>Q:</strong> Lá»‡nh <code>:=</code> hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?</li>
  <li><strong>Tráº£ lá»i:</strong> NÃ³ sáº½ khai bÃ¡o biáº¿n má»›i náº¿u báº¥t ká»³ biáº¿n nÃ o bÃªn trÃ¡i chÆ°a cÃ³ trong scope hiá»‡n táº¡i. NgÆ°á»£c láº¡i, náº¿u táº¥t cáº£ Ä‘Ã£ tá»“n táº¡i â†’ compile error.</li>
</ul>


</main>
<div class="sidebar-image">
  <img src="Golang.png" alt="System Overview" />
</div>
  <script src="main.js"></script>
</body>
</html>
